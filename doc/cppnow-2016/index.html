<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Experimental Boost.DI</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">

C++Now 2016

# C++14 Dependency Injection Library

https://github.com/boost-experimental/di

Kris Jusiak

==============================================================================

##Dependency Injection

----

(DI) involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client’s state. It is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test

Rob Stewart

----

## "Let's make some coffee!"

<center>[![Coffee Maker](images/coffee_maker.png)](images/coffee_maker.png)</center>

----

##No Dependency Injection

```cpp
class coffee_maker {
public:
  // create dependencies in the constructor
  coffee_maker()
    : heater(std::make_shared<electric_heater>())
    , pump(std::make_unique<heat_pump>(heater))
  { }

  void brew() {
    heater->on();
    pump->pump();
  }

private:
  std::shared_ptr<iheater> heater;
  std::unique_ptr<ipump> pump;
};
```

----

##Dependency Injection

```cpp
class coffee_maker {
public:
  // inject dependencies via constructor
  coffee_maker(std::shared_ptr<iheater> heater
             , std::unique_ptr<ipump> pump)
    : heater(heater), pump(move(pump))
  { }

  void brew() {
    heater->on();
    pump->pump();
  }

private:
  std::shared_ptr<iheater> heater;
  std::unique_ptr<ipump> pump;
};
```

----

##It's all about the construction!

> "Don't call us, we'll call you", Hollywood principle

----

##Do I need Dependency Injection?

----

##Depends...

----

* DI provides loosely coupled code
  * separation of business logic and object creation
* DI provides easier to maintain code
  * different objects might be easily injected
* DI provides easier to test code
  * fakes objects might be injected

==============================================================================

##Do I need a DI Framework/Library?

----

Depending on a project and its scale you may put up with or without a DI library, however, in any project
a DI framework may **free you** from maintaining a following (boilerplate) code...

----

```cpp
auto create() {
  logger logger_;
  renderer renderer_;
  view view_{renderer_, logger_};
  model model_{logger_};
  controller controller_{model_, view_, logger_};
  user user_{logger_};
  ...
  return make_unique<app>(controller, user_, logger_).run();
}
```

----

Notice that **ORDER** in which above dependencies are created is **IMPORTANT** as well as that
**ANY** change in **ANY** of the objects constructor will **REQUIRE** a change in the code!

----

###Showcase

---

http://wandbox.com

----

DI library, not only let you forget about maintaining this code,
but also can help you with...

----

* Testing
* Serializing
* Understanding dependencies
* Restricting allowed types

----

###Try it yourself online!

---

http://boost-experimental.github.io/di/try_it

----

##Still not convinced?

----

###Real-life example?

----

> Let's make a web match-3 game in C++14

* Model-View-Controller
* Dependency Injection
* Meta State Machine
* Range-V3

---

[Thursday, May 12 / 9:00am - 10:30am](https://cppnow2016.sched.org/event/6Sg4/lets-make-a-web-match-3-game-in-c14-using-dependency-injectionexperimental-boostdi-meta-state-machineexperimental-boostmsm-lite-rangev3-and-msvc-and-emscripten)

---

[https://github.com/modern-cpp-examples/match3](https://github.com/modern-cpp-examples/match3)

==============================================================================

##C++ vs Java vs C# Libraries

----

###Writing a DI library in C++ is not an easy task

----

* Performance is important
* Lack of static reflection
* Pointers, References, Rvalues, Smart Pointers, ...
* Qualifiers - const, volatile, ...
* Templates, Concepts, ...

----

###DI Libraries...

----

![Libraries](images/libraries.png)

----

##Benchmarks

----

TODO

----

###More Benchmarks

---

http://boost-experimental.github.io/di/benchmarks

==============================================================================

##Experimental Boost.DI

==============================================================================

##Overview

----

###A bit of history

----

2012 - 2014

---

Version C++98 / C++11 - never released

---

https://github.com/boost-experimental/di/tree/cpp03

----

* Compiled slowly (Boost.MPL)
* Enormous error messages
* A lot of preprocessor magic (BOOST_PP)
* A lot of workarounds for compilers (MSVC 2013)

----

2014 - Now

---

Version C++14 - v1.0.0

---

https://github.com/boost-experimental/di/tree/cpp14

---

----

* One header (boost/di.hpp) / generated
* 3k lines
* Neither Boost nor STL is required
* No 'if' branches
* No 'virtual' methods
* No 'exceptions' (-fno-exceptions)

----

##Tested compilers

----

* [Clang-3.4+](https://travis-ci.org/boost-experimental/di)

* [XCode-6.1+](https://travis-ci.org/boost-experimental/di)

* [GCC-5.2+](https://travis-ci.org/boost-experimental/di)

* [MSVC-2015+](https://ci.appveyor.com/project/krzysztof-jusiak/di)

----

##Quality (per commit)

> CONTINOUS INTEGRATION

----

* Travis/Appveyor build on Linux/OS X/Windows (Boost-Build/CMake)
  * Clang-3.4/3.5/3.6/3.7/3.8 (libc++ / stdlibc++)
  * GCC-5
  * MSVC-2015
* Clang static analysis / Clang-tidy (static check)
* Valgrind / Dr. Memory (dynamic memory check)
* Clang-format (style check)
* Deploy documentation to 'GitHub/gh-pages'

----

###Tests

----

##99% test code coverage

----

* Unit tests
* Functional tests
* Performance tests (benchmarks)
* Compilation-error tests (validates error message)
* Run-time generation tests (compares generated assembler opcodes)

==============================================================================

##Design

----

##Goals

----

* ###Be as fast as possible

  * Boost.DI has none or minimal run-time overhead

----

* ###Compile as fast as possible

  * Boost.DI compiles **faster than Java-Dagger2!**

----

* ###Guarantee object creation at compile-time

  * Boost.DI resolves types at compile-time and gives short and intuitive error messages

> If it compiles it will work!

----

* ###Be as non-intrusive as possible

  * Boost.DI deduces constructor parameters without reflection

----

* ###Be easy to extend

  * Boost.DI provides easy way to write custom scopes/policies/providers

----

###Architecture

----

<img style="height:550px;" src="images/di.png" />

----

* Bindings

  * DSL to create dependencies representation which will be used by core to resolve types

----

* Scopes

  * Responsible for maintain objects life time

----

* Providers

  * Responsible for providing object instance

----

* Policies

  * Compile-time limitations for types / Run-time types visitor

----

* Config

  * Configuration for Policies and Providers

----

##In a nutshell (Pseudo-code)

----

```cpp
template<class TConfig, class... TBindings>
class core::injector {
  template<class T> constexpr auto create() const noexcept {
    TConfig::policies<T>()...;

    auto&& dependency = binder{}.resolve<T>(TBindings...);
    using ctor = ctor_traits<injector, T>();

    return wrapper<T>{
      dependency.create( // create in a dependency scope
        TConfig::provider{}.get<decltype(dependency.impl)>(
          create<ctor>()...))
    };
  }
};
```

[https://github.com/boost-experimental/di](https://github.com/boost-experimental/di)

==============================================================================

##User Guide

----

###Create objects tree

----

[![Create objects tree](images/tutorial_create_objects_tree.png)](images/tutorial_create_objects_tree.png)

----

```cpp
struct renderer { int device; };
class iview {
public:
  virtual ~iview() = default;
  virtual void update() = 0;
};
class model {};
class controller {
public:
  controller(model&, view&) {}
};
class user {};
class app {
public:
  app(controller&, user&) {}
};
```

----

###Usual approach to create `app`

----

```cpp
renderer renderer_;
view view_{"title", renderer_};
model model_;
controller controller_{model_, view_};
user user_;
app app_{controller_, user_};
```

----

###With Boost.DI

----

```cpp
auto app = di::make_injector().create<app>();
```

----

###Where

----

```cpp
template<class TConfig = di::config, class... TDeps>
  requires configurable<TConfig>() && boundable<TDeps...>()
auto make_injector(TDeps&&...) noexcept;
```

```cpp
template<class... TDeps> requires boundable<TDeps...>()
class injector {
public:
  injector(injector&&) = default;
  explicit injector(TDeps&&...) noexcept;

  template<class T> requires creatable<T>()
  constexpr auto create() const;

  template<class T> requires !creatable<T>()
  [[deprecated("creatable constraint not satisfied")]]
  constexpr auto create() const;
};
```

----

###How is that possible without static reflection?

----

###User-defined/implicit/generic conversion operator

----

```cpp
struct any_type {
  template<class T>
  constexpr operator T(); // non explicit
};

int main() {
  struct example {
    example(int, double);
  };

  static_assert(
    std::is_constructible<example, any_type, any_type>::value);
}
```
https://wandbox.com

----

###Limitations

----

It doesn't work for constructor with one parameter!

> Copy constructor / Move constructor

---

> Generic converting constructor
```cpp
class example {
public:
  template<class T>
  example(T); // non explicit
};
```

----

###Disable the operator when type T is convertible to the parent type

----

```cpp
template<class TParent>
struct any_type {
  template<class T, class =
    std::enable_if_t<!std::is_convertible<TParent, T>{}>
  > constexpr operator T();
};

int main() {
  struct example {
    example(int, double);
  };

  static_assert(
    !std::is_constructible<example, any_type<example>>::value);
}
```
https://wandbox.com

----

###Calculate the number of parameters?

----

```cpp
constexpr auto BOOST_DI_CFG_CTOR_LIMIT_SIZE = 10;

template<class T, std::size_t>
using any_type_t = any_type<T>;

template<class...>
struct is_constructible;

template<class T, std::size_t... Ns>
struct is_constructible<T, std::index_sequence<Ns...>>
  : std::is_constructible<T, any_type_t<T, Ns>...>
{ };
```

----

```cpp
template <class T, std::size_t... Ns>
constexpr auto ctor(std::index_sequence<Ns...>) noexcept {
  auto value = 0;
  int _[]{0, (is_constructible<T, std::make_index_sequence<Ns>>{}
    ? value = Ns : value)...};
  return value;
}

int main() {
  struct example {
    example(int, double, float);
  };

  static_assert(3 == ctor<example>(
    std::make_index_sequence<BOOST_DI_CFG_CTOR_LIMIT_SIZE>{}));
}
```
https://wandbox.com

----

###How it's done in DI?

----

###is braces constructible

----

```cpp
template <class T, class... TArgs>
decltype(void(T{declval<TArgs>()...}), true_type{})
test_is_braces_constructible(int);

template <class, class...>
false_type test_is_braces_constructible(...);

template <class T, class... TArgs>
using is_braces_constructible =
  decltype(test_is_braces_constructible<T, TArgs...>(0));

template <class T, class... TArgs>
using is_braces_constructible_t =
  typename is_braces_constructible<T, TArgs...>::type;

```

```cpp
struct example { int a; int b; };
static_assert(is_braces_constructible<example, any_type, any_type>{});
```

----

###Implementation (Pseudo-code)

----

```cpp
template<class TInjector, class TParent>
struct any_type {
  template<class T, class =
    std::enable_if_t<!std::is_convertible<TParent, T>{}>
  > constexpr operator T() {
    return injector_.template create<T>();
  }

  const TInjector& injector_;
};
```

----

```cpp
template<class TInjector, class T> auto ctor_traits() {
  if (has_inject<T>() { // BOOST_DI_INJECT
    return pair<direct, typename T::inject>{};
  }
  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i >= 0; --i) {
    if (is_constructible<T, any_type<TInjector, T>...>())
      return pair<direct, any_type<TInjector, T>...>{};
    }
  }
  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i >= 0; --i) {
    if (is_braces_constructible<T, any_type<TInjector, T>...>())
      return pair<uniform, any_type<TInjector, T>...>{};
    }
  }
  return error(...); // concepts emulation
};
```

----

###Coming back to the design

----

```cpp
template<class TConfig, class... TBindings>
class core::injector {
  template<class T> constexpr auto create() const noexcept {
    TConfig::policies<T>()...;
    auto&& dependency = binder{}.resolve<T>(TBindings...);

    using ctor = ctor_traits<injector, T>(); // -\
     // pair<direct/uniform, TCtor...>  <--------/

    return wrapper<T>{
      dependency.create( // create in a dependency scope
        TConfig::provider{}.get<decltype(dependency.impl)>(
          create<ctor>()...))
    };
  }
};
```

----

##Bindings

> DI Configuration

----

###Interfaces

----

```cpp
class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};

class gui_view: public iview {
public:
  gui_view(std::string title, const renderer&) {}
  void update() override {}
};

class text_view: public iview {
public:
  void update() override {}
};
```

----

```cpp
auto injector = di::make_injector(
  di::bind<iview>.to<gui_view>() // bind interface to implementation
);
```

```cpp
assert(dynamic_cast<gui_view*>(
  injector.create<std::unique_ptr<iview>().get())
);
```

----

###Values

----

```cpp
struct T { // create using uniform initialization
  int& a;  // might be used to serialize
  double b;
};
```

```cpp
 auto i = 42;
 auto injector = di::make_injector(
    di::bind<int>.to(i),
    di::bind<double>.to(87.0)
 );
 injector.create<T>(); // will create T{i, 87.0};
```
https://wandbox.com

----

###Dynamic conditions

----

```cpp
auto use_gui_view = true/false;

auto injector = di::make_injector(
  di::bind<iview>.to([&](const auto& injector) -> iview& {
    return use_gui_view ?
      injector.template create<gui_view&>() :
      injector.template create<text_view&>();
  })
);
```

```cpp
use_gui_view = true;
assert(dynamic_cast<gui_view*>(
  injector.create<std::unique_ptr<iview>().get())
);

use_gui_view = false;
assert(dynamic_cast<text_view*>(
  injector.create<std::unique_ptr<iview>().get())
);
```

----

###This way XML injection might be easily achieved

---

[XML Injection](http://boost-experimental.github.io/di/extensions/index.html#xml-injection)

----

###Vectors/Lists/Arrays/...

----

###Using initializer list

----

```cpp
auto injector = di::make_injector(
  di::bind<int[]>().to({1, 2, 3})
);

auto v = injector.create<std::vector<int>>();
  // or std::array / std::set

assert(3 == v.size());
assert(1 == v[0]);
assert(2 == v[1]);
assert(3 == v[2]);
```

----

###Using list of types

----

```cpp
auto injector = di::make_injector(
  di::bind<interface*[]>().to<implementation1, implementation2>()
);
```

```cpp
auto v = injector.create<
  std::vector<std::unique_ptr<interface>>>();
    // or std::array / std::set with
    // std::shared_ptr, raw pointer, reference, ...

assert(2 == v.size());
assert(dynamic_cast<implementation1*>(v[0].get()));
assert(dynamic_cast<implementation2*>(v[1].get()));
```

----

##Scopes

> Objects life time

----

* deduce scope (default)
* instance scope (bind<>.to(value) where value is maintained by the user)
* unique scope (one instance per request)
* singleton scope (shared instance)

----

```
+-------------------------------------------------+ singleton scope
|
|          unique scope     unique scope
|          +---+            +------+
|          |                |
+--+-------+----------------+---------------------> Application life time
   |
   |
   +------------------------+ instance / user scope
                             (is not controlled by DI)
```

----

###Scopes deduction

----

| Type | Scope |
|------|-------|
| `T`, `T&&`, `T*`, `const T*`, `std::unique_ptr<T>` | unique |
| `T&`, `const T&`, `std::shared_ptr<T>`, `boost::shared_ptr<T>`, `std::weak_ptr<T>` | singleton |

----

###Explicit change of the scope for a given type

----

```cpp
auto injector = di::make_injector(
  di::bind<iview>.to<gui_view>().in(di::singleton) // explicitly
);
```
----

##Injections / Annotations

----

```cpp
class model {
 public:
   model(int size, double precision) { }
   model(int rows, int cols) { }
};
```

> Constructor ambiguity (compilation error)

----

###Solution

----

```cpp
class model {
 public:
   model(int size, double precision) { }
   BOOST_DI_INJECT(model, int rows, int cols); // pick me!
};

model::model(int rows, int cols) {} // implementation is not affected
```
----

###Distinguish rows from columns

----

###Annotations / Names

----

```cpp
class model {
 public:
   model(int size, double precision) { }

   BOOST_DI_INJECT(model, (named = "rows"_s) int rows
                        , (named = "cols"_s) int cols);
};

model::model(int rows, int cols) {} // implementation stays the same
```

```cpp
auto injector = di::make_injector(
  di::bind<int>.named("rows"_s).to(6)
, di::bind<int>.named("cols"_s).to(8)
);
```

----

###Where

----

```cpp
template <char...>
struct string {};

template <class T, T... Ts>
constexpr auto operator""_s() {
  return string<Ts...>{}
}
```

> It's not standard!
> For a standard solution use unique types instead

----

##Modules

> Split DI configuration

----

```cpp
auto view_module = [] {
  return di::make_injector(
    di::bind<icanvas>.to<sdl_canvas>()
  , di::bind<irenderer>.to<gui_renderer>()
  );
};

auto model_module = [] {
  return di::make_injector(
    di::bind<config>.to({6, 8})
  , di::bind<irandom>.to<mt19937_random>()
  );
};
```

```cpp
auto injector = di::make_injector(
  view_module(), model_module()
);

injector.create<app>();
```

----

###Module in CPP file

----

###Expose types via injector

> Only exposed types will be creatable

----

```cpp
di::injector<view&> view_module() { // expose view
  return di::make_injector(
    di::bind<icanvas>.to<sdl_canvas>()
  , di::bind<irenderer>.to<gui_renderer>()
  );
}
```

```cpp
di::injector<model&> model_module() { // expose model
  return di::make_injector(
    di::bind<config>.to({6, 8})
  , di::bind<irandom>.to<mt19937_random>()
  );
}
```

```cpp
auto injector = di::make_injector(
  view_module(), model_module()
);

injector.create<app>();
```

==============================================================================

##Error messages / Concepts

----

###Concepts emulation

----

###"Standard" way without concepts

----

```cpp
#define REQUIRES(...) \
  typename std::enable_if<__VA_ARGS__, int>::type = 0
```

----

```cpp
template <class...>
using is_valid_expr = true_type;
```

```cpp
template <class T>
std::false_type providable_impl(...); // or some type error message

template <class T>
auto providable_impl(T&& t) -> is_valid_expr<
  decltype(t.template is_creatable<T>()),
  decltype(t.template get<T>())
>;

template <class T>
constexpr auto providable() {
  return decltype(providable_impl(std::declval<T>()))::value;
}
```

----

###How to get better error messages?

----

###Transport the substitution failures

----

```cpp
#define REQUIRES(...) \
  typename get_errors_from_types<__VA_ARGS__>::type
```

----

###Problem

> User-defined/implicit/generic conversion operator

----

```cpp
struct any_type {
  template<class T>
  constexpr operator T(); // no easy way to return a failure from T
};
```

----

###Solution

----

###Split concepts emulation into 2 parts

----

###Check the predicate

----

###Display the error message

----

###How?

----

###Creatable

----

```cpp
template <class T, class TDependency = binder::resolve_t<T>>
using creatable = std::is_convertible<
  TDependency::template try_create<T>(
    provider<ctor_traits<typename TDependency::impl>>{}
  );
>;
```

```cpp
template <class T, class TProvider>
auto try_create(const TProvider& provider) -> wrapper<
  unique, decltype(provider.get())> // `auto -> decltype` will disable
                                    // function if not applicable
try_create(const TProvider&);
```

----

```cpp
struct any_type {
  template <class T, REQUIRES(creatable<T>())>
  constexpr operator T(); // disabled when type is not creatable
};
```

----

```cpp
template<class T, class... TArgs, // TArgs migth be disabled by any_type
  REQUIRES(std::is_constructible<T, TArgs...>{})>
constexpr auto create_impl(TArgs&&... args) {
  return T{std::forward<TArgs>(args...)};
}

template<class T, class... TArgs,
  REQUIRES(!std::is_constructible<T, TArgs...>{})>
constexpr auto create_impl(TArgs&&... args) {
  return show_the_error<T>{};
}
```

----

###Show the error

----

```cpp
template<class T>
constexpr auto show_the_error() {
  return aux::is_polymorphic<T>{} ? // return the proper type
    abstract_type<T>::is_not_bound{} :
    type<T>::cant_be_created{}; // simplified version
};
```

----

> Static inline function without implementation will show
  a warning without a CALL STACK!

----

###Abstract type is not bound

----

```cpp
template <class T>
struct abstract_type {
  struct is_not_bound {
    constexpr operator T() const { return error(); }

    // no implementation
    static inline T
      error(_ = "type is not bound, did you forget to add:
          'di::bind<interface>.to<implementation>()'?");
  };
};
```

----

###Change the warning into error

----

```cpp
#if defined(__clang__)
#pragma clang diagnostic error "-Wundefined-inline"
#elif defined(__GCC__)
#pragma GCC diagnostic error "-Werror"
#elif defined(__MSVC__)
#pragma warning(disable : 4822) // function does not have a body
#endif
```

----

###From top to bottom

----

```cpp
template <class T, REQUIRES(creatable<T>())>
constexpr T create() const {
  return create_successful_impl(type<T>{}); // compilation time speed up
}

template <class T, REQUIRES(!creatable<T>())>
[[deprecated("creatable constraint not satisfied")]]
constexpr T create() const {
  return create_impl(type<T>{});
}
```

----

###Example

----

```cpp
struct renderer {
  int device;
};
class view {
public:
  view(std::string title, const renderer&);
};
class model {};
class controller {
public:
  controller(model&, view&) {}
};
class user {};
class app {
public:
  app(controller&, user&) {}
};
```

```cpp
auto injector = di::make_injector(); // no bindings for iview
injector.create<app>();
```

----

###Clang

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
  injector.create<app>();
           ^
note 'create<app>' has been explicitly marked deprecated here
  create
  ^
error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

----

###GCC

----

```cpp
error: ‘T injector<...>::create() const [with T = app]’ is deprecated:
  creatable constraint not satisfied
   injector.create<app>();
                        ^
note declared here
   create
   ^
error: inline function ‘abstract_type<T>::is_not_bound::error(_)
  [with T = iview]’ used but never defined
  error(_ = "type is not bound, did you forget to add:
            'di::bind<interface>.to<implementation>()'?");
```

----

###MSVC

----

```cpp
error C4996: 'injector<...>::create': creatable constraint not
                                      satisfied
        with
        [
            TConfig=config
        ]
note see declaration of 'injector<...>::create'
        with
        [
            TConfig=config
        ]
error C4506: no definition for inline function
            'abstract_type<T>::is_not_bound::error(_)'
        with
        [
            T=iview
        ]
```

----

###BOOST DI CFG DIAGNOSTICS LEVEL

----

##BOOST DI CFG DIAGNOSTICS LEVEL=0

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
```

----

##BOOST DI CFG DIAGNOSTICS LEVEL=1

> Default

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied
  injector.create<app>();

error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```
----

##BOOST DI CFG DIAGNOSTICS LEVEL=2

----

```cpp
error: 'create<app>' is deprecated: creatable constraint not satisfied

error: function ‘T creating<T>::type(_) [with T = app]’
error: function ‘T creating<T>::type(_) [with T = controller]’

error: inline function 'abstract_type<iview>::is_not_bound::error'
 error(_ = "type is not bound, did you forget to add:
           'di::bind<interface>.to<implementation>()'?");
```

==============================================================================

##Extensions

----

###Provide an easy way to extend DI functionality without changing the core

----

###Print types / Policy

----

```cpp
struct types_dumper : di::config {
  static auto policies(...) noexcept {
    return di::make_policies([](auto type) {
      using T = decltype(type);
      using ctor = typename T::type;
      using impl = typename T::given;
      std::cout << ... << std::endl;
    });
  }
};
```

----

###Example Output

----

```cpp
class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};
struct model { std::vector<int> board; };
class controller {
public:
  controller(model&, iview&) {}
};
struct user {};

class app {
public:
  app(controller&, user&) {}
};
```

----

```cpp
auto injector = di::make_injector<types_dumper>(
  di::bind<iview>.to<gui_view>()
);

injector.create<app>();
```

* app
    * controller
        * model
            * int[]
        * iview -> gui_view
    * user

----

###Serialize / Policy

> PODs only

----

###Serializable

----

```cpp
struct serializable : di::config {
  template <class TInjector>
  static auto policies(const TInjector& injector) noexcept {
    return di::make_policies([&](auto type) {
      using T = decltype(type);
      ...
      auto& serialize = injector.template create<serializable&>();
      auto ptr = reinterpret_cast<char*>(&injector.template create<T&>());
      const auto offset = calculate_offset(sizeof(T), alignof(T));
      serialize.emplace_back({get_type<T>(), ptr, offset});
      ...
    }
  }
};
```

----

###Serialize

----

```cpp
auto serialize = [](const auto& injector, auto& str) {
  serializable_call_t::apply(injector, [&](const auto& o, auto t) {
    str << o.path << " "
        << o.type << " "
        << o.offset << " "
        << std::to_string(
             *reinterpret_cast<decltype(t)*>(o.ptr() + o.offset)
           )
        << std::endl;
  });
};
```

----

###Deserialize

----

```cpp
auto deserialize = [](const auto& injector, auto& str) {
  serializable_call_t::apply(
    injector, [&](const auto& o, auto t, auto line) {
    std::string line, path, type;
    decltype(t) value = {};
    auto offset = 0;
    std::istringstream iss{line};
    iss >> path >> type >> offset >> value;
    *reinterpret_cast<decltype(t)*>(o.ptr() + offset) = value;
  });
};
```

----

###Example Output

----

```cpp
struct data { unsigned int ui; long l; float f; };
struct even_more_data { double d; bool b; long long ll; };
struct more_data { int i; long double ld; even_more_data d; short s; };

class example {
public:
  example(data& d, more_data& md) : d(d), md(md) {}

  void update(); // change data, more_data

private:
  data& d;
  more_data& md;
};
```

----

```cpp
auto injector = di::make_injector<serializable>();
injector.create<example>();
```

```cpp
std::stringstream str;
serialize(injector, str);
```

```cpp
deserialize(injector, str);
```

----

```cpp
example->data unsigned_int 13
example->data long 23
example->data float 0.330000
example->more_data int 44
example->more_data long_double 42.000000
example->more_data->even_more_data double 55.000000
example->more_data->even_more_data bool 1
example->more_data->even_more_data long_long 66
example->more_data short 77
```

----

###Constructible / Policy

----

###Let's Disallow types which are not PODs or are not bound

----

```cpp
struct is_pod_or_is_bound : di::config {
  static auto policies(...) noexcept {
    using namespace di::policies;
    return di::make_policies(
      constructible(std::is_pod<_>{} || is_bound<_>{})
    );
  }
};
```

----

```cpp
struct not_a_pod { virtual ~not_a_pod() = default; };
struct example { example(not_a_pod, int, double) { } };
```

```cpp
auto injector = di::make_injector<is_pod_or_is_bound>(
  di::bind<>().to(42)
, di::bind<not_a_pod>().to(not_a_pod{})
);

injector.create<example>();
```

----

###Error case / compilation error

----

```cpp
di::make_injector<is_pod_or_is_bound>().create<example>();
```

```cpp
error: 'create<example>' is deprecated: creatable constraint not satisfied
  injector.create<example>();
           ^
error: inline function 'type<not_a_pod>::not_allowed_by<
  or_<std::is_pod<_>, is_bound<_>>>::error'

  error(_ = "type disabled by constructible policy
           , added by BOOST_DI_CFG or make_injector<CONFIG>!");
```

----

###Mocks injector / Provider

----

###Automatic injection of mocks for interfaces

----

```cpp
struct mocks_provider : di::config {
  struct mock_provider {
    template <class T, class TInit, class TMemory, class... TArgs>
    std::enable_if_t<!std::is_polymorphic<T>::value, T*> get(
    get(const TInit&, const TMemory&, TArgs&&... args) {
      return new T{std::forward<TArgs>(args)...);
    }

    template <class T, class TInit, class TMemory, class... TArgs>
    std::enable_if_t<std::is_polymorphic<T>::value, T*> get(
      return &get_mock<T>();
    }
  };

public:
  static auto provider(...) noexcept { return mock_provider{}; }
};
```

----

###Get mock

---

> https://github.com/eranpeer/FakeIt
https://github.com/dascandy/hippomocks

----

###Example

----

```cpp
class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};
struct model { std::vector<int> board; };
class controller {
public:
  controller(model&, iview&) {}
};
struct user {};

class app {
public:
  app(controller&, user&) {}
};
```

----

```cpp
auto injector = di::make_injector<mocks_provider>(
  di::bind<int[]>.to({1, 2, 3, 4, 5, 6})
  // we don't have to bind iview!
);

injector.create<app>();
```

```cpp
auto&& v = get_mock<iview>();
When(Method(v, update)).AlwaysDo([]{...});
```

---
https://github.com/modern-cpp-examples/match3

----

###More extensions

---

[Constructor Bindings](http://boost-experimental.github.io/di/extensions/index.html#constructor-bindings) | [Contextual Bindings](http://boost-experimental.github.io/di/extensions/index.html#contextual-bindings)

[XML Injection](http://boost-experimental.github.io/di/extensions/index.html#xml-injection) | [Assisted Injection](http://boost-experimental.github.io/di/extensions/index.html#assisted-injection)

[Concepts](http://boost-experimental.github.io/di/extensions/index.html#concepts) | [Lazy](http://boost-experimental.github.io/di/extensions/index.html#lazy) | [Named Parameters](http://boost-experimental.github.io/di/extensions/index.html#named-parameters)

[Types Dumper](http://boost-experimental.github.io/di/extensions/index.html#types-dumper) | [UML Dumper](http://boost-experimental.github.io/di/extensions/index.html#uml-dumper) | [Serialize](http://boost-experimental.github.io/di/extensions/index.html#serialize)

[Mocks Provider](http://boost-experimental.github.io/di/extensions/index.html#mocks-provider)

[Scoped Scope](http://boost-experimental.github.io/di/extensions/index.html#scoped-scope) | [Session Scope](http://boost-experimental.github.io/di/extensions/index.html#session-scope) | [Shared Scope](http://boost-experimental.github.io/di/extensions/index.html#shared-scope)

==============================================================================

##Performance

----

###Environment

----

2.3 GHz Intel Core i7 / 16 GB 1600 Mhz DDR3

----

##Run-time

----

###Bind type to value

----

```cpp
#include <boost/di.hpp>

namespace di = boost::di;

auto test() {
  auto injector = di::make_injector(
    di::bind<int>.to(42)
  );

  return injector.create<int>();
}
```

----

###ASM x86-64

```
mov $0x2a,%eax
retq
```

Same as...

```
return 42;
```


----

###How?

----

No run-time branches as everything is known at compile time and might be optimized!

----

```cpp
injector.create<int>();  ---------------\
  create_successful_impl(type<int>());  |   mov $0x2a,%eax
      scope.create<int>(provider);      |-  retq
        provider.get<int>();            |
          return 42; -------------------/
```

----

###Bind interface to implementation

----

```cpp
#include <boost/di.hpp>

namespace di = boost::di;
auto test() {
  auto injector = di::make_injector(
    di::bind<interface>.to<implementation>()
  );

  return injector.create<std::unique_ptr<interface>>();
}
```

----

###ASM x86-64

```
push   %rbx
mov    %rdi,%rbx
mov    $0x8,%edi
callq  0x4009f0 <_Znwm@plt>
movq   $0x400e78,(%rax)
mov    %rax,(%rbx)
mov    %rbx,%rax
pop    %rbx
retq
```

Same as...

```cpp
return std::make_unique<implementation>();
```

----

##Compile-time

----

###Include DI header

----

```cpp
#include <boost/di.hpp>

int main() {}
```

0.050s

> Nighter STL nor Boost is used

----

![Performance](images/performance.png)

```cpp
* 4248897537 instances created
* 132 different types
* 10 modules
```

----

##Speed up compilation times

----

###Always measure!

----

###Guidelines

----

###Avoid template instantiations

----

###Avoid recursive template algorithms

----

###Do checks once and as early as possible

----

###Avoid long type names (variadic templates)

----

###Use compiler built-ins and common tricks to gain performance

```cpp
template<bool...> struct bool_seq;

template<class... Ts>
using and_ = std::is_same<
    bool_seq<Ts::value...>,
    bool_seq<(Ts::value, true)...>
>;
```

```cpp
__make_index_seq is O(1) since Clang 3.9
```

----

###Implementation

----

###Resolve

----

```cpp
template<class T>
struct dependency_concept { };

template<class I, class Impl>
struct dependency : pair<dependency_concept<I>, dependency<I, Impl>> { };

template<class... Ts>
struct injector : Ts...  { };

template<class... Ts>
auto make_injector(Ts...) {
  return injector<Ts...>{};
}
```

----

```cpp
struct binder {
  template <class TDefault, class>
  static TDefault resolve_impl(...) noexcept { return {}; }

  template <class, class TConcept, class TDependency>
  static decltype(auto)
  resolve_impl(pair<TConcept, TDependency>* dep) noexcept {
    return static_cast<TDependency&>(*dep);
  }

  template <class T, class TDefault, class TDeps>
  static decltype(auto) resolve(TDeps* deps) noexcept {
    using dependency = dependency_concept<std::decay_t<T>>;
    return resolve_impl<TDefault, dependency>(deps);
  }
};
```

----

```cpp
auto injector = make_injector(dependency<i1, impl1>{});

struct default_dependency{};

static_assert(std::is_same<dependency<i1, impl1>,
  std::decay_t<decltype(
    binder{}.resolve<i1, default_dependency>(&injector))
  >>{}
);

static_assert(std::is_same<default_dependency,
  std::decay_t<decltype(
    binder{}.resolve<i2, default_dependency>(&injector)
  )>>{}
);
```
https://wandbox.com

----

###Resolve - Benchmarks

----

| Number of dependencies | Resolve time (middle dependency) |
| ---------------------- | -------------------------------- |
| 1                      | 0.077s                           |
| 16                     | 0.079s                           |
| 32                     | 0.082s                           |
| 64                     | 0.083s                           |
| 128                    | 0.089s                           |

----

###Creatable Concept

----

###Idea

----

```cpp
                            creatable<T>
                           (make it lite)
                                 |
                  /--------------+-----------------\
                Yes                                No
                 |                                 |
        create_successful_impl                  create_impl
```

----

```cpp
template <class T> requires creatable<T>()
constexpr T create() const {
  // no checks for errors!
  return create_successful_impl(type<T>{});
}

template <class T> requires !creatable<T>()
[[deprecated("creatable constraint not satisfied")]]
constexpr T create() const {
  // checks for errors to report it
  return create_impl(type<T>{});
}
```

----

###'Name' erasure

----

Long type names may increase your compilation times a LOT!

----

```cpp
template<class... Ts> auto make_injector(Ts... args) {
  return injector<Ts...>(args...); // may produces a long type name
}

auto injector = make_injector(...);
injector.create<T>(); // slow to compile
                      // a lot of long type names comparisons
```

----

###Solution - inheritance

----

```cpp
auto injector = di::make_injector(...);

struct erase_long_type_name : decltype(injector) {
  using decltype(injector)::injector;
};

erase_long_type_name{injector}.create<T>(); // quick to compile
                                            // type name =>
                                            // erase_long_type_name
```

----

###Solution - lambda expression

----

```cpp
static auto make_injector_impl = [](auto injector) {
  using injector_t = decltype(injector);

  struct i : injector_t {
    explicit i(injector_t&& other)
      : injector_t(std::move(other)) { }
  };

  return i{std::move(injector)};
};
```

----

###'Name' erasure - Benchmark

----

| Solution                         | Number of bindings | Time    |
| -------------------------------- | ------------------ | ------- |
| Long type name                   | 256                | 5.321s  |
| Name erasure / inheritance       | 256                | 2.521s  |
| Name erasure / lambda expression | 256                | 3.278s  |

----

##More Benchmarks...

----

http://boost-experimental.github.io/di/overview

==============================================================================

##DI vs ISO C++

----

###Static reflection

----

###Deduction of constructor parameters

----

```cpp
class example {
public:
  example(int, double);
};

static_assert(is_same<
  std::tuple<int, double>
, std::function_traits_t<decltype(&example::example)>::args
>{});
```

----

###User defined attributes

----

```cpp
class example {
public:
  [[inject]]
  example(double, int); // pick me!

  example(int, double);
  example(int, double, float);
};
```

----

```cpp
class example {
public:
  example([[named("int_a")]] int a, [[named("int_b")]] int b) {
    assert(42 == a);
    assert(87 == b);
  }
};
```

```cpp
auto injector = di::make_injector(
  di::bind<int>.named("int_a").to(42)
, di::bind<int>.named("int_b").to(87)
);
```

==============================================================================

<img style="height: 500px; width: 350px;" src="images/review_manager.jpg" />

==============================================================================

##Questions?

* Documentation
    * http://boost-experimental.github.io/di

* Source Code
    * https://github.com/boost-experimental/di

* Try it online
    * http://boost-experimental.github.io/di/try_it
					</script>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
