{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction\n\n\n\n\n\n\n\n\n[Boost].DI\n\n\n\n\n\n\n\n\n\n\n\n\nYour C++14 header only Dependency Injection library with no dependencies (\nTry it online!\n)\n\n\nGitHub\n\n\n\n\n\n\n\n\n\n\n Latest Release: \nv1.0.2\n (Jan 4, 2018)\n\n\n \nDownload\n \n \n \nChangelog\n \n \n \nTutorial\n \n \n \nExamples\n\n\n\n\n\nWhat is Dependency Injection?\n\n\n\n\n\"Don't call us, we'll call you\", Hollywood principle\n\n\n\n\nDependency Injection\n (DI)\n involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.\n\n\n\nIn short, DI is all about construction!\n\n\n\n\n\"Let's make some coffee!\"\n\n\n\n\n\n\n\n\n                      No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(const shared_ptr\niheater\n heater\n                              heater-\non();                   |              , unique_ptr\nipump\n pump)\n                              pump-\npump();                   |         : heater(heater), pump(move(pump))\n                              clog \n \ncoffee\n! \n endl;      |     { }\n                              heater-\noff();                  |\n                          }                                   |     void brew() {\n                                                              |         heater-\non();\n                      private:                                |         pump-\npump();\n                          shared_ptr\niheater\n heater =        |         clog \n \ncoffee!\n \n endl;\n                              make_shared\nelectric_heater\n(); |         heater-\noff();\n                                                              |     }\n                          unique_ptr\nipump\n pump =            |\n                              make_unique\nheat_pump\n(heater); | private:\n                      };                                      |     shared_ptr\niheater\n heater;\n                                                              |     unique_ptr\nipump\n pump;\n                                                              | };\n\n\n\n\nDo I use a Dependency Injection already?\n\n\n\n\nIf you are using constructors in your code then you are probably using some form of Dependency Injection too!\n\n\n\n\nclass Button {\n public:\n  Button(const std::string\n name, Position position); // Dependency Injection!\n};\n\n\n\n\nDo I use Dependency Injection correctly?\n\n\nCommon mistakes when using Dependency Injection are:\n\n\n\n\n\n\nPassing a dependency to create another dependency inside your object\n\n\nIt's a bad practice to pass dependencies to an object just in order\nto create another one with those dependencies.\nIt's much cleaner to create the latter object beforehand and pass it to the former.\n\n\n\n\n\n\nclass Model {\n public:\n   Model(int width, int height)\n     : board(std::make_unique\nBoard\n(width, height)) // Bad\n   { }\n\n   explicit Model(std::unique_ptr\nIBoard\n board) // Better\n     : board(std::move(board))\n   { }\n\n   ...\n\n private:\n  std::unique_ptr\nIBoard\n board;\n};\n\n\n\n\n\n\n\n\nCarrying dependencies\n\n\nIt's also important NOT to pass depenencies through layers of constructors (carrying them).\nIt's much better to always pass only dependecies which are required ONLY by the given constructor.\n\n\n\n\n\n\nclass Model : public Service { // Bad\n public:\n   explicit Model(std::unique_ptr\nIBoard\n board) // Bad\n     : Service(std::move(board))\n   { }\n\n   void update() {\n     Service::do_something_with_board(); // Bad\n   }\n};\n\nclass Model { // Better\n public:\n   explicit Model(std::unique_ptr\nService\n service) // Better\n     : service(std::move(service))\n   { }\n\n   void update() {\n     service-\ndo_something_with_board(); // Better\n   }\n\n private:\n   std::unique_ptr\nService\n service;\n};\n\n\n\n\n\n\n\n\nCarrying injector (Service Locator pattern)\n\n\nService locator is consider to be an anti-pattern because its instance\nis required to be passed as the ONLY constructor parameter into all\nconstructors. Such approach makes the code highly coupled to the Service Locator framework.\nIt's better to pass required dependencies direclty instead and use a DI framework to inject them.\n\n\n\n\n\n\nclass Model {\n public:\n   explicit Model(service_locator\n sl) // Bad (ask)\n     : service(sl.resolve\nunique_ptr\nService\n())\n   { }\n\n   explicit Model(std::unique_ptr\nService\n service) // Better (tell)\n     : service(std::move(service))\n   { }\n\n   ...\n\n private:\n   std::unique_ptr\nService\n service;\n};\n\n\n\n\n\n\n\n\nNot using strong typedefs for consturctor parameters\n\n\nBeing explicit and declarative is always better than being impilicit.\nUsing common types (ex. numbers) in order to define any common-like type may cause\nmissusage of the constructor interface. Using \nstrong typedefs\n is easier to follow and\nprotects against missusage of the constructor interface.\n\n\n\n\n\n\nclass Board {\n public:\n   Board(int /*width*/, int /*height*/)  // Bad; Board{2, 3} vs Board{3, 2}?\n\n   Board(width, height) // Better, explicit; Board{width{2}, height{3}};\n\n   ...\n};\n\n\n\n\nDo I need a Dependency Injection?\n\n\n\n\nDI provides loosely coupled code (separation of business logic and object creation)\n\n\nDI provides easier to maintain code (different objects might be easily injected)\n\n\nDI provides easier to test code (fakes objects might be injected)\n\n\n\n\nSTUPID vs SOLID - \"Clean Code\" Uncle Bob\n\n\n\n  \nS\nSingleton\n\n  \nT\nTight Coupling\n\n  \nU\nUntestability\n\n  \nP\nPremature Optimization\n\n  \nI\nIndescriptive Naming\n\n  \nD\nDuplication\n\n\n\n\n\n\n\nvs\n\n\n\n\n\n  \nS\nSingle Responsibility\n\n  \nO\nOpen-close\n\n  \nL\nLiskov substitution\n\n  \nI\nInterface segregation\n\n  \nD\nDependency inversion\n\n\n\n\n\nDo I need a DI Framework/Library?\n\n\nDepending on a project and its scale you may put up with or without a DI library, however, in any project\na DI framework may \nfree you\n from maintaining a following (boilerplate) code...\n\n\nlogger logger_;\nrenderer renderer_;\nview view_{renderer_, logger_};\nmodel model_{logger_};\ncontroller controller_{model_, view_, logger_};\nuser user_{logger_};\napp app_{controller_, user_};\n\n\n\n\nNotice that \nORDER\n in which above dependencies are created is \nIMPORTANT\n as well as that\n\nANY\n change in \nANY\n of the objects constructor will \nREQUIRE\n a change in this code!\n\n\nManual DI - Wiring Mess (Avoid it by using [Boost].DI)\n\n\n* Single Responsibility Principle\n  =\n\n    * A lot of classes\n    =\n\n      * Wiring Mess\n      =\n\n        * Hard to maintain + Lazy programmers (99%)\n        =\n\n          * Hacks/Workarounds (~~Single Responsibility~~)\n\n\n\n\n\n\n\n\nRight now, imagine a project with hundreds or thousands of those dependencies and a critical issue\nwhich has to be fixed ASAP. Unfortunately, in order to fix the bug properly a new non-trivial dependency has to be\nintroduced.\n\n\nNow, imagine that a 'smart' dev figured out that it will be much easier to extend the functionally\nof already passed object and sneak a workaround/'solution' this way. Such approach will possibly break the \nsingle responsibility principle\n\nof the changed object but no worries though, it might be refactored later on (meaning: most likely, the workaround will stay unchanged forever and that there are no tests).\n\n\nIf that sounds familiar\n, take a look into DI library as it helps to solve developer dilemma by taking care\nof creating all required dependencies whereas dev may focus on fixing and testing the issue.\n\n\n\n\nDI library\n, not only let you forget about maintaining dependencies creation (See \nCreate Objects Tree\n),\nbut also can help you with...\n\n\n\n\nTesting (See \nMocks Provider\n)\n\n\nSerializing (See \nSerialize\n)\n\n\nUnderstand code dependencies (See \nUML Dumper\n)\n\n\nRestrict what types and how they should be created (See \nConstructible Policy\n)\n\n\n\n\nReal Life examples?\n\n\n\n\nMatch-3 Game\n\n\nSimple web game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection / Range-V3 / Emscripten\n\n\nPlay it online!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutomatic Mocks Injector\n\n\nAutomatically create and inject required mocks to tested classes via constructors\n\n\n\n\n\n\n\n\n\n\n\n\nExperimental Boost.SML\n\n\nC++14 header only Meta State Machine library with no dependencies\n\n\n\n\n\n\n\n\nWhy [Boost].DI?\n\n\n\n\n[Boost].DI has none run-time overhead (See \nPerformance\n)\n\n\n[Boost].DI compiles fast / \nFaster than Java-\nDagger2\n!\n (See \nBenchmarks\n)\n\n\n[Boost].DI gives short diagnostic messages (See \nError messages\n)\n\n\n[Boost].DI is non-intrusive (See \nInjections\n)\n\n\n[Boost].DI reduces boilerplate code (See \nCreate Objects Tree\n)\n\n\n[Boost].DI reduces testing effort (See \nMocks Provider\n)\n\n\n[Boost].DI gives better control of what and how is created (See \nConstructible Policy\n)\n\n\n[Boost].DI gives better understanding about objects hierarchy (See \nUML Dumper\n)\n\n\n\n\n\n\nTry it online!\n\n\n\n\n\n\n\n\n\n\n\n\n[Boost].DI design goals\n\n\n\n\nBe as fast as possible (See \nPerformance\n)\n\n\nCompile as fast as possible (See \nBenchmarks\n)\n\n\nGive short and intuitive error messages (See \nError messages\n)\n\n\nGuarantee object creation at compile-time (See \nCreate Objects Tree\n)\n\n\nBe as non-intrusive as possible (See \nInjections\n)\n\n\nBe easy to extend (See \nExtensions\n)\n\n\n\n\nArticles\n\n\n\n\nInversion of Control Containers and the Dependency Injection pattern\n\n\nDIP in the Wild\n\n\nConcepts driven design with Dependency Injection\n\n\n\n\nVideos\n\n\n\n\nDependency Injection\n\n\nThe Clean Code Talks - Don't Look For Things!\n\n\nC++Now 2016: C++14 Dependency Injection Library\n | \nSlides\n\n\nMeeting C++ 2016: TDD/BDD and Dependency Injection\n | \nSlides\n\n\nBoost your design with C++14 dependency injection\n | \nSlides\n\n\nA New Type of dependency injection\n\n\nThe Future of Dependency Injection with Dagger 2\n\n\nDesign Patterns in C++: Creational\n\n\n\n\nAcknowledgements\n\n\n\n\nThanks to \nBartosz Kalinczuk\n for code review and tips how to improve \n[Boost].DI\n\n\nThanks to \nKanstantsin Chernik\n for all his contributions to \n[Boost].DI\n\n\nThanks to \nOlof Edlund\n for very useful feedback and for all the improvements to the documentation\n\n\nThanks to \nRob Stewart\n and \nRobert Ramey\n for documentation feedback and tips how to improve it\n\n\nThanks to \nSohail Somani\n for support and tips how to improve \n[Boost].DI", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "[Boost].DI       Your C++14 header only Dependency Injection library with no dependencies ( Try it online! )  GitHub", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#what-is-dependency-injection", 
            "text": "\"Don't call us, we'll call you\", Hollywood principle   Dependency Injection  (DI)  involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.  \nIn short, DI is all about construction!   \"Let's make some coffee!\"                           No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(const shared_ptr iheater  heater\n                              heater- on();                   |              , unique_ptr ipump  pump)\n                              pump- pump();                   |         : heater(heater), pump(move(pump))\n                              clog    coffee !   endl;      |     { }\n                              heater- off();                  |\n                          }                                   |     void brew() {\n                                                              |         heater- on();\n                      private:                                |         pump- pump();\n                          shared_ptr iheater  heater =        |         clog    coffee!    endl;\n                              make_shared electric_heater (); |         heater- off();\n                                                              |     }\n                          unique_ptr ipump  pump =            |\n                              make_unique heat_pump (heater); | private:\n                      };                                      |     shared_ptr iheater  heater;\n                                                              |     unique_ptr ipump  pump;\n                                                              | };", 
            "title": "What is Dependency Injection?"
        }, 
        {
            "location": "/index.html#do-i-use-a-dependency-injection-already", 
            "text": "If you are using constructors in your code then you are probably using some form of Dependency Injection too!   class Button {\n public:\n  Button(const std::string  name, Position position); // Dependency Injection!\n};", 
            "title": "Do I use a Dependency Injection already?"
        }, 
        {
            "location": "/index.html#do-i-use-dependency-injection-correctly", 
            "text": "Common mistakes when using Dependency Injection are:    Passing a dependency to create another dependency inside your object  It's a bad practice to pass dependencies to an object just in order\nto create another one with those dependencies.\nIt's much cleaner to create the latter object beforehand and pass it to the former.    class Model {\n public:\n   Model(int width, int height)\n     : board(std::make_unique Board (width, height)) // Bad\n   { }\n\n   explicit Model(std::unique_ptr IBoard  board) // Better\n     : board(std::move(board))\n   { }\n\n   ...\n\n private:\n  std::unique_ptr IBoard  board;\n};    Carrying dependencies  It's also important NOT to pass depenencies through layers of constructors (carrying them).\nIt's much better to always pass only dependecies which are required ONLY by the given constructor.    class Model : public Service { // Bad\n public:\n   explicit Model(std::unique_ptr IBoard  board) // Bad\n     : Service(std::move(board))\n   { }\n\n   void update() {\n     Service::do_something_with_board(); // Bad\n   }\n};\n\nclass Model { // Better\n public:\n   explicit Model(std::unique_ptr Service  service) // Better\n     : service(std::move(service))\n   { }\n\n   void update() {\n     service- do_something_with_board(); // Better\n   }\n\n private:\n   std::unique_ptr Service  service;\n};    Carrying injector (Service Locator pattern)  Service locator is consider to be an anti-pattern because its instance\nis required to be passed as the ONLY constructor parameter into all\nconstructors. Such approach makes the code highly coupled to the Service Locator framework.\nIt's better to pass required dependencies direclty instead and use a DI framework to inject them.    class Model {\n public:\n   explicit Model(service_locator  sl) // Bad (ask)\n     : service(sl.resolve unique_ptr Service ())\n   { }\n\n   explicit Model(std::unique_ptr Service  service) // Better (tell)\n     : service(std::move(service))\n   { }\n\n   ...\n\n private:\n   std::unique_ptr Service  service;\n};    Not using strong typedefs for consturctor parameters  Being explicit and declarative is always better than being impilicit.\nUsing common types (ex. numbers) in order to define any common-like type may cause\nmissusage of the constructor interface. Using  strong typedefs  is easier to follow and\nprotects against missusage of the constructor interface.    class Board {\n public:\n   Board(int /*width*/, int /*height*/)  // Bad; Board{2, 3} vs Board{3, 2}?\n\n   Board(width, height) // Better, explicit; Board{width{2}, height{3}};\n\n   ...\n};", 
            "title": "Do I use Dependency Injection correctly?"
        }, 
        {
            "location": "/index.html#do-i-need-a-dependency-injection", 
            "text": "DI provides loosely coupled code (separation of business logic and object creation)  DI provides easier to maintain code (different objects might be easily injected)  DI provides easier to test code (fakes objects might be injected)", 
            "title": "Do I need a Dependency Injection?"
        }, 
        {
            "location": "/index.html#stupid-vs-solid-clean-code-uncle-bob", 
            "text": "S Singleton \n   T Tight Coupling \n   U Untestability \n   P Premature Optimization \n   I Indescriptive Naming \n   D Duplication    vs   \n   S Single Responsibility \n   O Open-close \n   L Liskov substitution \n   I Interface segregation \n   D Dependency inversion", 
            "title": "STUPID vs SOLID - \"Clean Code\" Uncle Bob"
        }, 
        {
            "location": "/index.html#do-i-need-a-di-frameworklibrary", 
            "text": "Depending on a project and its scale you may put up with or without a DI library, however, in any project\na DI framework may  free you  from maintaining a following (boilerplate) code...  logger logger_;\nrenderer renderer_;\nview view_{renderer_, logger_};\nmodel model_{logger_};\ncontroller controller_{model_, view_, logger_};\nuser user_{logger_};\napp app_{controller_, user_};  Notice that  ORDER  in which above dependencies are created is  IMPORTANT  as well as that ANY  change in  ANY  of the objects constructor will  REQUIRE  a change in this code!", 
            "title": "Do I need a DI Framework/Library?"
        }, 
        {
            "location": "/index.html#manual-di-wiring-mess-avoid-it-by-using-boostdi", 
            "text": "* Single Responsibility Principle\n  = \n    * A lot of classes\n    = \n      * Wiring Mess\n      = \n        * Hard to maintain + Lazy programmers (99%)\n        = \n          * Hacks/Workarounds (~~Single Responsibility~~)    Right now, imagine a project with hundreds or thousands of those dependencies and a critical issue\nwhich has to be fixed ASAP. Unfortunately, in order to fix the bug properly a new non-trivial dependency has to be\nintroduced.  Now, imagine that a 'smart' dev figured out that it will be much easier to extend the functionally\nof already passed object and sneak a workaround/'solution' this way. Such approach will possibly break the  single responsibility principle \nof the changed object but no worries though, it might be refactored later on (meaning: most likely, the workaround will stay unchanged forever and that there are no tests).  If that sounds familiar , take a look into DI library as it helps to solve developer dilemma by taking care\nof creating all required dependencies whereas dev may focus on fixing and testing the issue.   DI library , not only let you forget about maintaining dependencies creation (See  Create Objects Tree ),\nbut also can help you with...   Testing (See  Mocks Provider )  Serializing (See  Serialize )  Understand code dependencies (See  UML Dumper )  Restrict what types and how they should be created (See  Constructible Policy )", 
            "title": "Manual DI - Wiring Mess (Avoid it by using [Boost].DI)"
        }, 
        {
            "location": "/index.html#real-life-examples", 
            "text": "Match-3 Game  Simple web game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection / Range-V3 / Emscripten  Play it online!         Automatic Mocks Injector  Automatically create and inject required mocks to tested classes via constructors       Experimental Boost.SML  C++14 header only Meta State Machine library with no dependencies", 
            "title": "Real Life examples?"
        }, 
        {
            "location": "/index.html#why-boostdi", 
            "text": "[Boost].DI has none run-time overhead (See  Performance )  [Boost].DI compiles fast /  Faster than Java- Dagger2 !  (See  Benchmarks )  [Boost].DI gives short diagnostic messages (See  Error messages )  [Boost].DI is non-intrusive (See  Injections )  [Boost].DI reduces boilerplate code (See  Create Objects Tree )  [Boost].DI reduces testing effort (See  Mocks Provider )  [Boost].DI gives better control of what and how is created (See  Constructible Policy )  [Boost].DI gives better understanding about objects hierarchy (See  UML Dumper )    Try it online!", 
            "title": "Why [Boost].DI?"
        }, 
        {
            "location": "/index.html#boostdi-design-goals", 
            "text": "Be as fast as possible (See  Performance )  Compile as fast as possible (See  Benchmarks )  Give short and intuitive error messages (See  Error messages )  Guarantee object creation at compile-time (See  Create Objects Tree )  Be as non-intrusive as possible (See  Injections )  Be easy to extend (See  Extensions )", 
            "title": "[Boost].DI design goals"
        }, 
        {
            "location": "/index.html#articles", 
            "text": "Inversion of Control Containers and the Dependency Injection pattern  DIP in the Wild  Concepts driven design with Dependency Injection", 
            "title": "Articles"
        }, 
        {
            "location": "/index.html#videos", 
            "text": "Dependency Injection  The Clean Code Talks - Don't Look For Things!  C++Now 2016: C++14 Dependency Injection Library  |  Slides  Meeting C++ 2016: TDD/BDD and Dependency Injection  |  Slides  Boost your design with C++14 dependency injection  |  Slides  A New Type of dependency injection  The Future of Dependency Injection with Dagger 2  Design Patterns in C++: Creational", 
            "title": "Videos"
        }, 
        {
            "location": "/index.html#acknowledgements", 
            "text": "Thanks to  Bartosz Kalinczuk  for code review and tips how to improve  [Boost].DI  Thanks to  Kanstantsin Chernik  for all his contributions to  [Boost].DI  Thanks to  Olof Edlund  for very useful feedback and for all the improvements to the documentation  Thanks to  Rob Stewart  and  Robert Ramey  for documentation feedback and tips how to improve it  Thanks to  Sohail Somani  for support and tips how to improve  [Boost].DI", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/overview/index.html", 
            "text": "Quick Start\n\n\n\n\nGet \nboost/di.hpp\n header\n\n\n\n\nwget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp\n\n\n\n\n\n\nInclude the header and define \ndi\n namespace alias\n\n\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\n\n\nCompile with C++14 support\n\n\n\n\n$CXX -std=c++14 ...\n\n\n\n\n \nNote\n\n[Boost].DI compiles with -fno-exceptions -fno-rtti -Wall -Wextra -Werror -pedantic -pedantic-errors\n\n\n\n\n\nTo run tests\n\n\n\n\ngit clone https://github.com/boost-experimental/di \n cd di \n make\n\n\n\n\nDependencies\n\n\n\n\nNo external dependencies are required (neither STL nor Boost)\n\n\n\n\nSupported/Tested compilers\n\n\n\n\nClang-3.4+\n\n\nGCC-5.2+\n\n\nMSVC-2015+\n\n\n\n\nConfiguration\n\n\n\n\n\n\n\n\nMacro\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_VERSION\n\n\nCurrent version of [Boost].DI (ex. 1'0'0)\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies (See \nConfig\n)\n\n\n\n\n\n\nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n\n\nLimits number of allowed constructor parameters [0-10, default=10] (See \nInjections\n)\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\nGives more information with error messages (See \nError messages\n)\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_BEGIN\n\n\nnamespace boost { namespace di { inline namespace v_1_0_0 {\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_END\n\n\n}}}\n\n\n\n\n\n\n\n\nException Safety\n\n\n\n\n[Boost].DI is not using exceptions internally and therefore might be compiled with \n-fno-exceptions\n.\n\n\nCheck \nUser Guide\n to verify which API's are marked \nnoexcept\n.\n\n\n\n\nThread Safety\n\n\n\n\n[Boost].DI is thread safe.\n\n\n\n\nError Messages\n\n\n\n\n[Boost].DI is designed to give great diagnostic errors. The examples below will show you the actual error messages for different scenarios. Check \nConcepts\n to check it out.\n\n\n\n\nPerformance\n\n\n\n\n[Boost].DI has none run-time overhead and compiles faster than Java's DI frameworks. Check \nBenchmarks\n to see more.", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/index.html#quick-start", 
            "text": "Get  boost/di.hpp  header   wget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp   Include the header and define  di  namespace alias   #include  boost/di.hpp \nnamespace di = boost::di;   Compile with C++14 support   $CXX -std=c++14 ...    Note \n[Boost].DI compiles with -fno-exceptions -fno-rtti -Wall -Wextra -Werror -pedantic -pedantic-errors   To run tests   git clone https://github.com/boost-experimental/di   cd di   make", 
            "title": "Quick Start"
        }, 
        {
            "location": "/overview/index.html#dependencies", 
            "text": "No external dependencies are required (neither STL nor Boost)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/overview/index.html#supportedtested-compilers", 
            "text": "Clang-3.4+  GCC-5.2+  MSVC-2015+", 
            "title": "Supported/Tested compilers"
        }, 
        {
            "location": "/overview/index.html#configuration", 
            "text": "Macro  Description      BOOST_DI_VERSION  Current version of [Boost].DI (ex. 1'0'0)    BOOST_DI_CFG  Global configuration allows to customize provider and policies (See  Config )    BOOST_DI_CFG_CTOR_LIMIT_SIZE  Limits number of allowed constructor parameters [0-10, default=10] (See  Injections )    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  Gives more information with error messages (See  Error messages )    BOOST_DI_NAMESPACE_BEGIN  namespace boost { namespace di { inline namespace v_1_0_0 {    BOOST_DI_NAMESPACE_END  }}}", 
            "title": "Configuration"
        }, 
        {
            "location": "/overview/index.html#exception-safety", 
            "text": "[Boost].DI is not using exceptions internally and therefore might be compiled with  -fno-exceptions .  Check  User Guide  to verify which API's are marked  noexcept .", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/overview/index.html#thread-safety", 
            "text": "[Boost].DI is thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/overview/index.html#error-messages", 
            "text": "[Boost].DI is designed to give great diagnostic errors. The examples below will show you the actual error messages for different scenarios. Check  Concepts  to check it out.", 
            "title": "Error Messages"
        }, 
        {
            "location": "/overview/index.html#performance", 
            "text": "[Boost].DI has none run-time overhead and compiles faster than Java's DI frameworks. Check  Benchmarks  to see more.", 
            "title": "Performance"
        }, 
        {
            "location": "/tutorial/index.html", 
            "text": "0. [Pre] Refactor towards DI\n\n\nIf you write a new application you can skip this step and go directly to \nstep 1\n.\nHowever, if you have a lot code which is not using DI and you wonder what can it be refactored,\nthen you are in the right place.\n\n\nBasically, there is a only one (big) step to get all benefits of Dependency Injection.\nYou have to separate creation logic from business logic, which means that your code\nshould be free of object creation inside other objects...\n\n\nclass controller {\npublic:\n  controller(config c) \n    : model_(std::make_unique\nmodel\n(c))\n  { }\n\n  void run();\n\nprivate:\n  std::unique_ptr\nmodel\n model_;\n};\n\nint main() {\n  controller controller_;\n  controller_.run();\n}\n\n\n\n\nInstead, DI approach would look like that...\n\n\nclass controller {\npublic:\n  explicit controller(model\n m) : model_(m) {}\n  void run();\n\nprivate:\n  model\n model_;\n};\n\nint main() {\n  model model_;\n  controller controller_{model_};\n  controller_.run();\n}\n\n\n\n\nSo, what happened here? We just took the responsibility of creation \nmodel\n out from the \ncontroller\n. In other words,\nwe have split the creation logic and the business logic.\n\n\nThat's basically everything you have to remember in order to create applications using DI.\nNevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,\nis NOT to pass an object into constructor if it won't be stored (\nLaw of Demeter\n).\n\n\nclass app {\npublic:\n  explicit app(model\n m) : controller_(m) {} // BAD\n  explicit app(controller\n c) : controller_(c) {} // GOOD\n\nprivate:\n  controller controller_;\n};\nclass controller {\npublic:\n  explicit controller(model\n);\n};\n\nint main() {\n  model model_;\n  app app_{model_};\n}\n\n\n\n\nAdditionally, you can consider using \nstrong typedefs\n which will make your constructor interface cleaner/stronger.\n\n\nclass button {\npublic:\n  button(int, int); // weak constructor interface (cpp file has to checked in order to figure out the meaning of int's)\n};\n\n\n\n\nbutton\n constructor is not clear because \nint's\n are ambiguous and both present just a number.\nIt can be seen more clearly in the following example.\n\n\nbutton{10, 15}; // OK, but what's 10? what's 15? Can I swap them?\nbutton{15, 10}; // Hmm, potenial missue of the constructor\n\n\n\n\nA better approach would be to introduce a strong typedefs for both numbers\nin order to avoid potential misuse of the constructor, especially when used by other/external teams.\n\n\nstruct width {\n  int value;\n  constexpr operator int() const { return value; }\n};\nstruct height {\n  int value;\n  constexpr operator int() const { return value; }\n};\nclass button {\npublic:\n  button(width, height); // strong constructor interface\n};\n\n\n\n\nRight now, \nbutton\n constructor is much easier to follow (no need to check cpp file) because\nit expresses the intention.\n\n\nbutton{width{10}, height{15}}; // OK, declartive approach\nbutton{height{10}, with{15}}; // Compile Error\nbutton{10, 15}; // Compile Error\n\n\n\n\nSimilar mechanism is used by [Boost].DI to achieve \nnamed\n parameters which and it will be presented in this tutorial later on.\n\n\n1. [Basic] Create objects tree\n\n\nBefore we will get into creating objects tree, let's first create a 'dummy' example.\nIn order to do so, firstly, we have to include (one and only) \nboost/di.hpp\n header\n\n\nwget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp\n\n\n\n\nand declare a convenient \ndi\n namespace alias.\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\nThat is enough to try out \n[Boost].DI\n!\n\n\nTo have a first complete and working example we just have to add \nmain\n function as usual.\n\n\nint main() {}\n\n\n\n\nand compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).\n\n\n$CXX -std=c++14 example.cpp\n\n\n\n\nCongrats, you are now ready to check out \n[Boost].DI\n features!\n\n\n\n\nLet's move on to creating objects tree. Applications, usually, consists of a number of objects\nwhich have to be instantiated. For example, let's consider a simplified Model View Controller code...\n\n\n\n\nThe usual approach to create \napp\n would be following...\n\n\nrenderer renderer_;\nview view_{\n, renderer_};\nmodel model_;\ncontroller controller_{model_, view_};\nuser user_;\napp app_{controller_, user_};\n\n\n\n\nWhich is alright for a really small applications. However, it's really tedious to maintain.\nJust imagine, that we have to change something here. For instance, \nview\n may need a new object \nwindow\n\nor, even worse, we refactored the code and dependencies order has changed - yea \nORDER\n of above is important!\n\nANY\n change in these classes constructors require developer input to maintain above boilerplate code!\nNot fun, not fun at all :(\n\n\nRight now imagine that your maintain effort will be minimized almost to none. How does it sound?\nWell, that might be simply achieved with \n[Boost].DI\n!\n\n\nThe same result might be achieved with [Boost].DI. All, non-ambiguous, dependencies will be automatically\nresolved and injected properly. It doesn't matter how big the hierarchy will be and/or if the order of constructor parameters will be changed in the future.\nWe just have to create \ninjector\n using \nmake_injector\n, create the \napp\n and DI will take care of injecting proper types for us.\n\n\nauto app_ = make_injector().create\napp\n(); // It will create an `app` on stack and call its copy constructor\n\n\n\n\nHow is that possible? [Boost].DI is able to figure out what parameters are required for the constructor of type T.\nAlso, [Boost].DI is able to do it recursively for all required types by the constructor T. Hence, NO information\nabout constructors parameters is required to be registered.\n\n\nMoreover, changes in the constructor of created objects will be handled automatically, so in our case\nwhen we add a \nwindow\n to \nview\n or change \nview\n to \nstd::shared_ptr\nview\n required effort will be\nexactly '0'. \n[Boost].DI\n will take care of everything for us!\n\n\n\n\n\n\n\n\nType \nT\n\n\nIs allowed?\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\nReference with \nsingleton\n / Temporary with \nunique\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::weak_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nboost_shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\n\n\nFurthermore, there is no performance penalty for using \n[Boost].DI\n (see \nPerformance\n)!\n\n\n \nNote\n\n[Boost].DI can \ninject\n dependencies using direct initialization \nT(...)\n or uniform initialization \nT{...}\n for aggregate types.\n\n\n\nAnd full example!\n\n\n\nCheck out also other examples. Please, notice that the diagram was also generated using \n[Boost].DI\n but we will get into that a bit later.\n\n\n\n\n\n\n\n\n\n\n2. [Basic] First steps with bindings\n\n\nBut objects tree is not everything. A lot of classes uses interfaces or required a value to be passed.\n\n[Boost].DI\n solution for this are \nbindings\n.\n\n\nFor purpose of this tutorial, let's change \nview\n class into interface \niview\n in order to support \ntext_view\n and \ngui_view\n.\n\n\nclass iview {\npublic:\n  virtual ~iview() noexcept = default;\n  virtual void update() =0;\n};\n\nclass gui_view: public iview {\npublic:\n  gui_view(std::string title, const renderer\n) {}\n  void update() override {}\n};\n\nclass text_view: public iview {\npublic:\n  void update() override {}\n};\n\n\n\n\nPlease, notice that \ntext_view\n doesn't require any constructor parameters, whilst \ngui_view\n does.\n\n\nSo, what will happen right now, when we try to create an \napp\n?\n\n\nauto app = make_injector().create\napp\n();\n\n\n\n\nCOMPILE error! (See also: \nError Messages\n)\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type\niview\n::is_not_bound::error'\n  error(_ = \ntype is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n);\n\n\n\n\n \nNote\n\nYou can get more info about error by increasing \nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n [0-2] value (default=1).\n\n\n\nAh, okay, we haven't bound \niview\n which means that \nBOOST.DI\n can't figure out whether we want \ntext_view\n or \ngui_view\n?\nWell, it's really simple to fix it, we just follow suggestion provided.\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n()\n);\n\n\n\n\nLet's try again. Yay! It's compiling.\n\n\nBut what about \nrender.device\n value? So far, it was value initialized by default(=0).\nWhat, if you we want to initialize it with a user defined value instead?\nWe've already seen how to bind interface to implementation.\nThe same approach might be used in order to bind a type to a value.\n\n\ndi::bind\nT\n.to(value) // bind type T to given value\n\n\n\n\nMoving back to our \nrender.device\n...\n\n\nstruct renderer {\n  int device;\n};\n\n\n\n\n \nNote\n\nIf you want change the default behaviour and be sure that all required dependencies are bound and not value initialized\ntake a look at \nconstructible\n policy.\n\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n()\n, di::bind\nint\n.to(42) // renderer.device | [Boost].DI can also deduce 'int' type for you -\n 'di::bind\n.to(42)'\n);\n\n\n\n\n \nNote\n\n[Boost].DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved\ncorrectly. No runtime exceptions or runtime asserts, EVER!\n\n\n\nAnd full example!\n\n\n\nThat's nice but I don't want to be using a dynamic (virtual) dispatch. What about concepts/templates?\nGood news, \n[Boost].DI\n can inject concepts/templates too!\n\n\ntemplate \nclass T = class Greater\n\nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind\nclass Greater\n.to\nhello\n()\n  );\n\n  auto object = injector.create\nexample\n();\n  static_assert(std::is_same\nhello, decltype(object)::type\n{});\n}\n\n\n\n\nAnd full example!\n\n\n\nGreat, but my code is more dynamic than that! I mean that I want to choose \ngui_view\n or \ntext_view\n at runtime.\n\n[Boost].DI\n can handle that too!\n\n\nauto use_gui_view = true/false;\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n    if (use_gui_view)\n      return injector.template create\ngui_view\n();\n    else\n      return injector.template create\ntext_view\n();\n  })\n, di::bind\n.to(42) // renderer device\n);\n\n\n\n\n \nNote\n\nIt is safe to throw exceptions from lambda. It will be passed through.\n\n\n\nNotice, that \ninjector\n was passed to lambda expression in order to create \ngui_view\n / \ntext_view\n.\nThis way \n[Boost].DI\n can inject appropriate dependencies into chosen types. See \nbindings\n for more details.\n\n\nAnd full example!\n\n\n\nOkay, so what about the input. We have \nuser\n, however, in the real life, we will have more clients.\n\n[Boost].DI\n allows multiple bindings to the same type for \narray/vector/set\n. Let's do it then!\n\n\nclass iclient {\n public:\n   virtual ~iclient() noexcept = default;\n   virtual void process() = 0;\n};\n\nclass user : public iclient {\n public:\n   void process() override {};\n};\n\nclass timer : public iclient {\n public:\n   void process() override {};\n};\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::unique_ptr\niclient\n);\n};\n\n\n\n\nAnd our bindings...\n\n\ndi::bind\niclient*[]\n.to\nuser, client\n()\n\n\n\n\nAnd full example!\n\n\n\nThe last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.\nWith \n[Boost].DI\n you can easily do that with \noverride\n specifier (Implemented using \noperator[](override)\n).\n\n\nconst auto injector = di::make_injector(\n  di::bind\nint\n.to(42) // renderer device\n, di::bind\nint\n.to(123) [di::override] // override renderer device\n);\n\n\n\n\nWithout the \ndi::override\n following compilation error will occur...\n\n\nboost/di.hpp:281:3: error: static_assert failed \nconstraint not satisfied\n\nboost/di.hpp:2683:80: type\nint\n::is_bound_more_than_once\n  inline auto make_injector(TDeps... args) noexcept\n\n\n\n\nAnd full example!\n\n\n\nCheck out also.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. [Basic] Decide the life times\n\n\nSo far so good but where are these objects stored?\nWell, \n[Boost].DI\n supports \nscopes\n which are response for maintaining the life time of created objects.\nBy default there are 4 scopes\n\n\n\n\ndeduce\n scope (default)\n\n\ninstance\n scope (bind\n.to(value) where value is maintained by the user)\n\n\nunique\n scope (one instance per request)\n\n\nsingleton\n scope (shared instance)\n\n\n\n\nBy default \ndeduce\n scope is used which means that scope is deduced based on a constructor parameter.\nFor instance, reference, shared_ptr will be deduced as \nsingleton\n scope and pointer, unique_ptr will be deduced as \nunique\n scope.\n\n\n\n\n\n\n\n\nType\n\n\nScope\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique\n (temporary) / \nsingleton\n\n\n\n\n\n\nT*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nstd::unique_ptr\n\n\nunique\n\n\n\n\n\n\nstd::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nboost::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nstd::weak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\nExample\n\n\nclass scopes_deduction {\n  scopes_deduction(const int\n /*singleton scope*/,\n                   std::shared_ptr\nint\n /*singleton scope*/,\n                   std::unique_ptr\nint\n /*unique scope*/,\n                   int /*unique scope*/)\n  { }\n};\n\ndi::make_injector().create\nexample\n(); // scopes will be deduced based on constructor parameter types\n\n\n\n\nComing back to our example, we got quite a few \nsingletons\n there as we just needed one instance per application life time.\nAlthough scope deduction is very useful, it's not always what we need and therefore \n[Boost].DI\n allows changing the scope for a given type.\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n().in(di::singleton) // explicitly specify singleton scope\n);\n\n\n\n\nWhat if I want to change \ngui_view\n to be a different instance per each request. Let's change the scope to \nunique\n then.\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n().in(di::unique)\n);\n\n\n\n\nWe will get a COMPILATION TIME ERROR because a unique scope can't be converted to a reference.\nIn other words, having a reference to a copy is forbidden and it won't compile!\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:897:2: error: 'scoped\nscopes::unique, gui_view\n::is_not_convertible_to\niview \n::error'\n  error(_ = \nscoped object is not convertible to the requested type, did you mistake the scope: 'di::bind\nT\n.in(scope)'?\n);\n\n\n\n\nAh, reference doesn't make much sense with \nunique\n scope because it would mean that it has to be stored somewhere.\nIt would be better to use \nstd::unique_ptr\niview\n instead.\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\n\n\nHmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to\nuse \nstd::shared_ptr\n instead.\n\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::shared_ptr\niclient\n);\n};\n\n\n\n\nBut, it would be better if \ntimer\n was always created per request, although it's a \nshared_ptr\n.\nTo do so, we just need add scope when binding it, like this...\n\n\nconst auto injector = di::make_injector(\n  di::bind\ntimer\n.in(di::unique) // different per request\n);\n\n\n\n\nCheck out the full example here.\n\n\n\nSee also.\n\n\n\n\n\n\n\n\n\n\n4. [Basic] Annotations to the rescue\n\n\nAbove example are fine and dandy, nonetheless, they don't cover one important thing.\nHow \n[Boost].DI\n knows which constructor to choose and what if they are ambiguous?\n\n\nWell, the algorithm is very simple. The longest (most parameters), unique constructor will be chosen.\nOtherwise, \n[Boost].DI\n will give up with a compile time error. However, which constructor should\nbe chosen is configurable by \nBOOST_DI_INJECT\n.\n\n\nTo illustrate this, let's modify \nmodel\n constructor.\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   model(int rows, int cols) { }\n};\n\n\n\n\nRight now, as expected, we get a compile time error!\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:942:4: error: 'type\nmodel\n::has_ambiguous_number_of_constructor_parameters::error'\n  error(_ = \nverify BOOST_DI_INJECT_TRAITS or di::ctor_traits\n);\n\n\n\n\nLet's fix it using \nBOOST_DI_INJECT\n then!\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected\n};\n\n\n\n\n \nNote\n\nWe can also write \nmodel(int rows, int cols, ...)\n to get the same result.\nBy adding \n...\n as the last parameter of the constructor it's guaranteed by [Boost].DI\nthat it will be used for injection as it will have the highest number of constructor parameters (infinite number).\n\n\n\nOkay, right now it compiles but, wait a minute, \n123\n (renderer device) was injected for both \nrows\n and \ncols\n!\nWell, it wasn't even close to what we wanted, but we can fix it easily using \nnamed\n annotations.\n\n\nFirstly, we have to create names. That's easy as names are just unique objects.\n\n\nauto Rows = []{};\nauto Cols = []{};\n\n\n\n\nSecondly, we have to tell \nmodel\n constructor about it.\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected\n};\n\nmodel::model(int rows, int cols) {}\n\n\n\n\nPlease, notice that we have separated \nmodel\n constructor definition and declaration to show that definition doesn't\nrequire named annotations.\n\n\n \nNote\n\nIf you happen to use clang/gcc compiler you can use string literals instead of creating objects,\nfor example \n(named = \"Rows\"_s)\n.\n\n\n\nFinally, we have to bind our values.\n\n\nconst auto injector = di::make_injector(\n  di::bind\nint\n.named(Rows).to(6)\n, di::bind\nint\n.named(Cols).to(8)\n);\n\n\n\n\nThat's all.\n\n\n \nNote\n\nThe same result might be accomplished with having different types for rows and cols.\n\n\n\nFull example here.\n\n\n\nCheck out also...\n\n\n\n\n\n\n\n\n\n\n5. [Basic] Split your configuration\n\n\nBut my project has hundreds of interfaces and I would like to split my bindings into separate components.\nThis is simple to do with [Boost.DI] as an \ninjector\n can be extended by other injectors.\n\n\nLet's split our configuration then and keep our \nmodel\n bindings separately from \napp\n bindings.\n\n\nauto model_module = [] {\n  return di::make_injector(\n    di::bind\nint\n.named(Rows).to(6)\n  , di::bind\nint\n.named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n.in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  );\n};\n\n\n\n\nAnd glue them into one injector the same way...\n\n\n  const auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );\n\n\n\n\n \nNote\n\nGluing many \ninjector\ns into one is order independent.\n\n\n\nAnd full example!\n\n\n\nBut I would like to have a module in \ncpp\n file, how can I do that?\nSuch design might be achieved with \n[Boost].DI\n using \ninjector\n and exposing given types.\n\n\n\n\nExpose all types (default)\n\n\n\n\nconst const auto injector = // auto exposes all types\n  di::make_injector(\n    di::bind\nint\n.to(42)\n  , di::bind\ndouble\n.to(87.0)\n  );\n\ninjector.create\nint\n(); OK\ninjector.create\ndouble\n(); // OK\n\n\n\n\n\n\nExpose only specific types\n\n\n\n\nconst di::injector\nint\n injector = // only int is exposed\n  di::make_injector(\n    di::bind\nint\n.to(42)\n  , di::bind\ndouble\n.to(87.0)\n  );\n\ninjector.create\nint\n(); OK\ninjector.create\ndouble\n(); // COMPILE TIME ERROR, double is not exposed by the injector\n\n\n\n\nWhen exposing all types using \nauto\n modules have to be implemented in a header file.\nWith \ndi::injector\nT...\n a definition might be put in a cpp file as it\u2019s just a regular type.\n\n\nSuch approach has a few benefits:\n\n It\u2019s useful for encapsulation (ex. Another team provides a module but they don't want to expose an ability to create implementation details)\n\n May also speed compilation times in case of extend usage of cpp files\n\n\n \nNote\n\nThere is no performance (compile-time, run-time) overhead between exposing all types or just a specific ones.\n\n\n\nMoving back to our example. Let's refactor it then.\n\n\ndi::injector\nmodel\n model_module() {\n  return di::make_injector(\n    di::bind\nint\n.named(Rows).to(6)\n  , di::bind\nint\n.named(Cols).to(8)\n  );\n}\n\ndi::injector\napp\n app_module(const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n.in(di::unique) // different per request\n  , di::bind\niclient*[]\n.to\nuser, timer\n() // bind many clients\n  , model_module()\n  );\n}\n\n\n\n\nRight now you can easily separate definition and declaration between \nhpp\n and \ncpp\n files.\n\n\nCheck the full example here!\n\n\n\n \nNote\n\nYou can also expose named parameters using \ndi::injector\nBOOST_DI_EXPOSE((named = Rows) int)\n.\nDifferent variations of the same type have to be exposed explicitly using \ndi::injector\nmodel\n, std::unique_ptr\nmodel\n.\nType erasure is used under the hood when types are exposed explicitly (\ndi::injector\nT\u2026\n).\n\n\nCheck out more examples here!\n\n\n\n\n\n\n\n\n\n\nCongrats! You have finished the basic part of the tutorial.\nHopefully, you have noticed potential of DI and \n[Boost].DI\n but if are still not convinced check out the \nAdvanced\n part.\n\n\n6. [Advanced] Dump/Limit your types\n\n\nIt's often a case that we would like to generate object diagram of our application in order to see code dependencies\nmore clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,\nif the responsibility for creation  objects will be given to \n[Boost].DI\n we get such functionality for free.\nThe only thing we have to do is to implement how to dump our objects.\n\n\nLet's dump our dependencies using \nPlant UML\n format.\n\n\n\n\n\n\nSee also.  \n\n\n\n\n\n\n\n\nOn the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow\nsmart pointers and disallow raw pointers too. We may want to have a \nview\n only with const parameters being passed, etc.\n\n[Boost].DI\n allows you to do so by using \nconstructible\n policy or writing a custom \npolicy\n.\n\n\n\n\nSee also.\n\n\n\n\n\n\n7. [Advanced] Customize it\n\n\n[Boost].DI\n was design having extensibility in mind. You can easily customize\n\n\n\n\nscopes\n - to have custom life time of an object\n\n\nproviders\n - to have custom way of creating objects, for example by using preallocated memory\n\n\npolicies\n - to have custom way of dumping types at run-time or limiting them at compile-time\n\n\n\n\n\n\n\n\n\n\n\n\n8. [Advanced] Extend it\n\n\nAs mentioned before, \n[Boost].DI\n is quite easy to extend and therefore a lot of extensions exists already.\nPlease check them out and write your own!\n\n\n\n\nConstructor Bindings\n\n\nAssisted Injection\n\n\nConcepts\n\n\nLazy\n\n\nNamed Parameters\n\n\nXML Injection\n\n\nTypes Dumper\n\n\nUML Dumper\n\n\nMocks Provider\n\n\nScoped Scope\n\n\nSession Scope\n\n\nShared Scope", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/index.html#0-pre-refactor-towards-di", 
            "text": "If you write a new application you can skip this step and go directly to  step 1 .\nHowever, if you have a lot code which is not using DI and you wonder what can it be refactored,\nthen you are in the right place.  Basically, there is a only one (big) step to get all benefits of Dependency Injection.\nYou have to separate creation logic from business logic, which means that your code\nshould be free of object creation inside other objects...  class controller {\npublic:\n  controller(config c) \n    : model_(std::make_unique model (c))\n  { }\n\n  void run();\n\nprivate:\n  std::unique_ptr model  model_;\n};\n\nint main() {\n  controller controller_;\n  controller_.run();\n}  Instead, DI approach would look like that...  class controller {\npublic:\n  explicit controller(model  m) : model_(m) {}\n  void run();\n\nprivate:\n  model  model_;\n};\n\nint main() {\n  model model_;\n  controller controller_{model_};\n  controller_.run();\n}  So, what happened here? We just took the responsibility of creation  model  out from the  controller . In other words,\nwe have split the creation logic and the business logic.  That's basically everything you have to remember in order to create applications using DI.\nNevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,\nis NOT to pass an object into constructor if it won't be stored ( Law of Demeter ).  class app {\npublic:\n  explicit app(model  m) : controller_(m) {} // BAD\n  explicit app(controller  c) : controller_(c) {} // GOOD\n\nprivate:\n  controller controller_;\n};\nclass controller {\npublic:\n  explicit controller(model );\n};\n\nint main() {\n  model model_;\n  app app_{model_};\n}  Additionally, you can consider using  strong typedefs  which will make your constructor interface cleaner/stronger.  class button {\npublic:\n  button(int, int); // weak constructor interface (cpp file has to checked in order to figure out the meaning of int's)\n};  button  constructor is not clear because  int's  are ambiguous and both present just a number.\nIt can be seen more clearly in the following example.  button{10, 15}; // OK, but what's 10? what's 15? Can I swap them?\nbutton{15, 10}; // Hmm, potenial missue of the constructor  A better approach would be to introduce a strong typedefs for both numbers\nin order to avoid potential misuse of the constructor, especially when used by other/external teams.  struct width {\n  int value;\n  constexpr operator int() const { return value; }\n};\nstruct height {\n  int value;\n  constexpr operator int() const { return value; }\n};\nclass button {\npublic:\n  button(width, height); // strong constructor interface\n};  Right now,  button  constructor is much easier to follow (no need to check cpp file) because\nit expresses the intention.  button{width{10}, height{15}}; // OK, declartive approach\nbutton{height{10}, with{15}}; // Compile Error\nbutton{10, 15}; // Compile Error  Similar mechanism is used by [Boost].DI to achieve  named  parameters which and it will be presented in this tutorial later on.", 
            "title": "0. [Pre] Refactor towards DI"
        }, 
        {
            "location": "/tutorial/index.html#1-basic-create-objects-tree", 
            "text": "Before we will get into creating objects tree, let's first create a 'dummy' example.\nIn order to do so, firstly, we have to include (one and only)  boost/di.hpp  header  wget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp  and declare a convenient  di  namespace alias.  #include  boost/di.hpp \nnamespace di = boost::di;  That is enough to try out  [Boost].DI !  To have a first complete and working example we just have to add  main  function as usual.  int main() {}  and compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).  $CXX -std=c++14 example.cpp  Congrats, you are now ready to check out  [Boost].DI  features!   Let's move on to creating objects tree. Applications, usually, consists of a number of objects\nwhich have to be instantiated. For example, let's consider a simplified Model View Controller code...   The usual approach to create  app  would be following...  renderer renderer_;\nview view_{ , renderer_};\nmodel model_;\ncontroller controller_{model_, view_};\nuser user_;\napp app_{controller_, user_};  Which is alright for a really small applications. However, it's really tedious to maintain.\nJust imagine, that we have to change something here. For instance,  view  may need a new object  window \nor, even worse, we refactored the code and dependencies order has changed - yea  ORDER  of above is important! ANY  change in these classes constructors require developer input to maintain above boilerplate code!\nNot fun, not fun at all :(  Right now imagine that your maintain effort will be minimized almost to none. How does it sound?\nWell, that might be simply achieved with  [Boost].DI !  The same result might be achieved with [Boost].DI. All, non-ambiguous, dependencies will be automatically\nresolved and injected properly. It doesn't matter how big the hierarchy will be and/or if the order of constructor parameters will be changed in the future.\nWe just have to create  injector  using  make_injector , create the  app  and DI will take care of injecting proper types for us.  auto app_ = make_injector().create app (); // It will create an `app` on stack and call its copy constructor  How is that possible? [Boost].DI is able to figure out what parameters are required for the constructor of type T.\nAlso, [Boost].DI is able to do it recursively for all required types by the constructor T. Hence, NO information\nabout constructors parameters is required to be registered.  Moreover, changes in the constructor of created objects will be handled automatically, so in our case\nwhen we add a  window  to  view  or change  view  to  std::shared_ptr view  required effort will be\nexactly '0'.  [Boost].DI  will take care of everything for us!     Type  T  Is allowed?  Note      T  \u2714  -    T*  \u2714  Ownership transfer!    const T*  \u2714  Ownership transfer!    T  \u2714  -    const T  \u2714  Reference with  singleton  / Temporary with  unique    T  \u2714  -    std::unique_ptr T  \u2714  -    std::shared_ptr T  \u2714  -    std::weak_ptr T  \u2714  -    boost_shared_ptr T  \u2714  -     Furthermore, there is no performance penalty for using  [Boost].DI  (see  Performance )!    Note \n[Boost].DI can  inject  dependencies using direct initialization  T(...)  or uniform initialization  T{...}  for aggregate types.  And full example!  Check out also other examples. Please, notice that the diagram was also generated using  [Boost].DI  but we will get into that a bit later.", 
            "title": "1. [Basic] Create objects tree"
        }, 
        {
            "location": "/tutorial/index.html#2-basic-first-steps-with-bindings", 
            "text": "But objects tree is not everything. A lot of classes uses interfaces or required a value to be passed. [Boost].DI  solution for this are  bindings .  For purpose of this tutorial, let's change  view  class into interface  iview  in order to support  text_view  and  gui_view .  class iview {\npublic:\n  virtual ~iview() noexcept = default;\n  virtual void update() =0;\n};\n\nclass gui_view: public iview {\npublic:\n  gui_view(std::string title, const renderer ) {}\n  void update() override {}\n};\n\nclass text_view: public iview {\npublic:\n  void update() override {}\n};  Please, notice that  text_view  doesn't require any constructor parameters, whilst  gui_view  does.  So, what will happen right now, when we try to create an  app ?  auto app = make_injector().create app ();  COMPILE error! (See also:  Error Messages )  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type iview ::is_not_bound::error'\n  error(_ =  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'? );    Note \nYou can get more info about error by increasing  BOOST_DI_CFG_DIAGNOSTICS_LEVEL  [0-2] value (default=1).  Ah, okay, we haven't bound  iview  which means that  BOOST.DI  can't figure out whether we want  text_view  or  gui_view ?\nWell, it's really simple to fix it, we just follow suggestion provided.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ()\n);  Let's try again. Yay! It's compiling.  But what about  render.device  value? So far, it was value initialized by default(=0).\nWhat, if you we want to initialize it with a user defined value instead?\nWe've already seen how to bind interface to implementation.\nThe same approach might be used in order to bind a type to a value.  di::bind T .to(value) // bind type T to given value  Moving back to our  render.device ...  struct renderer {\n  int device;\n};    Note \nIf you want change the default behaviour and be sure that all required dependencies are bound and not value initialized\ntake a look at  constructible  policy.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ()\n, di::bind int .to(42) // renderer.device | [Boost].DI can also deduce 'int' type for you -  'di::bind .to(42)'\n);    Note \n[Boost].DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved\ncorrectly. No runtime exceptions or runtime asserts, EVER!  And full example!  That's nice but I don't want to be using a dynamic (virtual) dispatch. What about concepts/templates?\nGood news,  [Boost].DI  can inject concepts/templates too!  template  class T = class Greater \nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind class Greater .to hello ()\n  );\n\n  auto object = injector.create example ();\n  static_assert(std::is_same hello, decltype(object)::type {});\n}  And full example!  Great, but my code is more dynamic than that! I mean that I want to choose  gui_view  or  text_view  at runtime. [Boost].DI  can handle that too!  auto use_gui_view = true/false;\n\nconst auto injector = di::make_injector(\n  di::bind iview .to([ ](const auto  injector) -  iview  {\n    if (use_gui_view)\n      return injector.template create gui_view ();\n    else\n      return injector.template create text_view ();\n  })\n, di::bind .to(42) // renderer device\n);    Note \nIt is safe to throw exceptions from lambda. It will be passed through.  Notice, that  injector  was passed to lambda expression in order to create  gui_view  /  text_view .\nThis way  [Boost].DI  can inject appropriate dependencies into chosen types. See  bindings  for more details.  And full example!  Okay, so what about the input. We have  user , however, in the real life, we will have more clients. [Boost].DI  allows multiple bindings to the same type for  array/vector/set . Let's do it then!  class iclient {\n public:\n   virtual ~iclient() noexcept = default;\n   virtual void process() = 0;\n};\n\nclass user : public iclient {\n public:\n   void process() override {};\n};\n\nclass timer : public iclient {\n public:\n   void process() override {};\n};\n\nclass app {\n public:\n  app(controller , std::vector std::unique_ptr iclient );\n};  And our bindings...  di::bind iclient*[] .to user, client ()  And full example!  The last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.\nWith  [Boost].DI  you can easily do that with  override  specifier (Implemented using  operator[](override) ).  const auto injector = di::make_injector(\n  di::bind int .to(42) // renderer device\n, di::bind int .to(123) [di::override] // override renderer device\n);  Without the  di::override  following compilation error will occur...  boost/di.hpp:281:3: error: static_assert failed  constraint not satisfied \nboost/di.hpp:2683:80: type int ::is_bound_more_than_once\n  inline auto make_injector(TDeps... args) noexcept  And full example!  Check out also.", 
            "title": "2. [Basic] First steps with bindings"
        }, 
        {
            "location": "/tutorial/index.html#3-basic-decide-the-life-times", 
            "text": "So far so good but where are these objects stored?\nWell,  [Boost].DI  supports  scopes  which are response for maintaining the life time of created objects.\nBy default there are 4 scopes   deduce  scope (default)  instance  scope (bind .to(value) where value is maintained by the user)  unique  scope (one instance per request)  singleton  scope (shared instance)   By default  deduce  scope is used which means that scope is deduced based on a constructor parameter.\nFor instance, reference, shared_ptr will be deduced as  singleton  scope and pointer, unique_ptr will be deduced as  unique  scope.     Type  Scope      T  unique    T  singleton    const T  unique  (temporary) /  singleton    T*  unique  (ownership transfer)    const T*  unique  (ownership transfer)    T  unique    std::unique_ptr  unique    std::shared_ptr  singleton    boost::shared_ptr  singleton    std::weak_ptr  singleton     Example  class scopes_deduction {\n  scopes_deduction(const int  /*singleton scope*/,\n                   std::shared_ptr int  /*singleton scope*/,\n                   std::unique_ptr int  /*unique scope*/,\n                   int /*unique scope*/)\n  { }\n};\n\ndi::make_injector().create example (); // scopes will be deduced based on constructor parameter types  Coming back to our example, we got quite a few  singletons  there as we just needed one instance per application life time.\nAlthough scope deduction is very useful, it's not always what we need and therefore  [Boost].DI  allows changing the scope for a given type.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ().in(di::singleton) // explicitly specify singleton scope\n);  What if I want to change  gui_view  to be a different instance per each request. Let's change the scope to  unique  then.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ().in(di::unique)\n);  We will get a COMPILATION TIME ERROR because a unique scope can't be converted to a reference.\nIn other words, having a reference to a copy is forbidden and it won't compile!  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:897:2: error: 'scoped scopes::unique, gui_view ::is_not_convertible_to iview  ::error'\n  error(_ =  scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind T .in(scope)'? );  Ah, reference doesn't make much sense with  unique  scope because it would mean that it has to be stored somewhere.\nIt would be better to use  std::unique_ptr iview  instead.     Type/Scope  unique  singleton  instance      T  \u2714  -  \u2714    T  -  \u2714  \u2714    const T  \u2714 (temporary)  \u2714  \u2714    T* (transfer ownership)  \u2714  -  -    const T*  \u2714  -  -    T  \u2714  -  \u2714    std::unique_ptr  \u2714  -  -    std::shared_ptr  \u2714  \u2714  \u2714    boost::shared_ptr  \u2714  \u2714  - / \u2714 converted to    std::weak_ptr  -  \u2714  - / \u2714 converted to     Hmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to\nuse  std::shared_ptr  instead.  class app {\n public:\n  app(controller , std::vector std::shared_ptr iclient );\n};  But, it would be better if  timer  was always created per request, although it's a  shared_ptr .\nTo do so, we just need add scope when binding it, like this...  const auto injector = di::make_injector(\n  di::bind timer .in(di::unique) // different per request\n);  Check out the full example here.  See also.", 
            "title": "3. [Basic] Decide the life times"
        }, 
        {
            "location": "/tutorial/index.html#4-basic-annotations-to-the-rescue", 
            "text": "Above example are fine and dandy, nonetheless, they don't cover one important thing.\nHow  [Boost].DI  knows which constructor to choose and what if they are ambiguous?  Well, the algorithm is very simple. The longest (most parameters), unique constructor will be chosen.\nOtherwise,  [Boost].DI  will give up with a compile time error. However, which constructor should\nbe chosen is configurable by  BOOST_DI_INJECT .  To illustrate this, let's modify  model  constructor.  class model {\n public:\n   model(int size, double precision) { }\n   model(int rows, int cols) { }\n};  Right now, as expected, we get a compile time error!  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:942:4: error: 'type model ::has_ambiguous_number_of_constructor_parameters::error'\n  error(_ =  verify BOOST_DI_INJECT_TRAITS or di::ctor_traits );  Let's fix it using  BOOST_DI_INJECT  then!  class model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected\n};    Note \nWe can also write  model(int rows, int cols, ...)  to get the same result.\nBy adding  ...  as the last parameter of the constructor it's guaranteed by [Boost].DI\nthat it will be used for injection as it will have the highest number of constructor parameters (infinite number).  Okay, right now it compiles but, wait a minute,  123  (renderer device) was injected for both  rows  and  cols !\nWell, it wasn't even close to what we wanted, but we can fix it easily using  named  annotations.  Firstly, we have to create names. That's easy as names are just unique objects.  auto Rows = []{};\nauto Cols = []{};  Secondly, we have to tell  model  constructor about it.  class model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected\n};\n\nmodel::model(int rows, int cols) {}  Please, notice that we have separated  model  constructor definition and declaration to show that definition doesn't\nrequire named annotations.    Note \nIf you happen to use clang/gcc compiler you can use string literals instead of creating objects,\nfor example  (named = \"Rows\"_s) .  Finally, we have to bind our values.  const auto injector = di::make_injector(\n  di::bind int .named(Rows).to(6)\n, di::bind int .named(Cols).to(8)\n);  That's all.    Note \nThe same result might be accomplished with having different types for rows and cols.  Full example here.  Check out also...", 
            "title": "4. [Basic] Annotations to the rescue"
        }, 
        {
            "location": "/tutorial/index.html#5-basic-split-your-configuration", 
            "text": "But my project has hundreds of interfaces and I would like to split my bindings into separate components.\nThis is simple to do with [Boost.DI] as an  injector  can be extended by other injectors.  Let's split our configuration then and keep our  model  bindings separately from  app  bindings.  auto model_module = [] {\n  return di::make_injector(\n    di::bind int .named(Rows).to(6)\n  , di::bind int .named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview .to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer .in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  );\n};  And glue them into one injector the same way...    const auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );    Note \nGluing many  injector s into one is order independent.  And full example!  But I would like to have a module in  cpp  file, how can I do that?\nSuch design might be achieved with  [Boost].DI  using  injector  and exposing given types.   Expose all types (default)   const const auto injector = // auto exposes all types\n  di::make_injector(\n    di::bind int .to(42)\n  , di::bind double .to(87.0)\n  );\n\ninjector.create int (); OK\ninjector.create double (); // OK   Expose only specific types   const di::injector int  injector = // only int is exposed\n  di::make_injector(\n    di::bind int .to(42)\n  , di::bind double .to(87.0)\n  );\n\ninjector.create int (); OK\ninjector.create double (); // COMPILE TIME ERROR, double is not exposed by the injector  When exposing all types using  auto  modules have to be implemented in a header file.\nWith  di::injector T...  a definition might be put in a cpp file as it\u2019s just a regular type.  Such approach has a few benefits:  It\u2019s useful for encapsulation (ex. Another team provides a module but they don't want to expose an ability to create implementation details)  May also speed compilation times in case of extend usage of cpp files    Note \nThere is no performance (compile-time, run-time) overhead between exposing all types or just a specific ones.  Moving back to our example. Let's refactor it then.  di::injector model  model_module() {\n  return di::make_injector(\n    di::bind int .named(Rows).to(6)\n  , di::bind int .named(Cols).to(8)\n  );\n}\n\ndi::injector app  app_module(const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview .to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer .in(di::unique) // different per request\n  , di::bind iclient*[] .to user, timer () // bind many clients\n  , model_module()\n  );\n}  Right now you can easily separate definition and declaration between  hpp  and  cpp  files.  Check the full example here!    Note \nYou can also expose named parameters using  di::injector BOOST_DI_EXPOSE((named = Rows) int) .\nDifferent variations of the same type have to be exposed explicitly using  di::injector model , std::unique_ptr model .\nType erasure is used under the hood when types are exposed explicitly ( di::injector T\u2026 ).  Check out more examples here!      Congrats! You have finished the basic part of the tutorial.\nHopefully, you have noticed potential of DI and  [Boost].DI  but if are still not convinced check out the  Advanced  part.", 
            "title": "5. [Basic] Split your configuration"
        }, 
        {
            "location": "/tutorial/index.html#6-advanced-dumplimit-your-types", 
            "text": "It's often a case that we would like to generate object diagram of our application in order to see code dependencies\nmore clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,\nif the responsibility for creation  objects will be given to  [Boost].DI  we get such functionality for free.\nThe only thing we have to do is to implement how to dump our objects.  Let's dump our dependencies using  Plant UML  format.    See also.       On the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow\nsmart pointers and disallow raw pointers too. We may want to have a  view  only with const parameters being passed, etc. [Boost].DI  allows you to do so by using  constructible  policy or writing a custom  policy .   See also.", 
            "title": "6. [Advanced] Dump/Limit your types"
        }, 
        {
            "location": "/tutorial/index.html#7-advanced-customize-it", 
            "text": "[Boost].DI  was design having extensibility in mind. You can easily customize   scopes  - to have custom life time of an object  providers  - to have custom way of creating objects, for example by using preallocated memory  policies  - to have custom way of dumping types at run-time or limiting them at compile-time", 
            "title": "7. [Advanced] Customize it"
        }, 
        {
            "location": "/tutorial/index.html#8-advanced-extend-it", 
            "text": "As mentioned before,  [Boost].DI  is quite easy to extend and therefore a lot of extensions exists already.\nPlease check them out and write your own!   Constructor Bindings  Assisted Injection  Concepts  Lazy  Named Parameters  XML Injection  Types Dumper  UML Dumper  Mocks Provider  Scoped Scope  Session Scope  Shared Scope", 
            "title": "8. [Advanced] Extend it"
        }, 
        {
            "location": "/try_it/index.html", 
            "text": "", 
            "title": "Try It Online!"
        }, 
        {
            "location": "/benchmarks/index.html", 
            "text": "Performance\n\n\n\n\nRun-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions / \ngdb -batch -ex 'file ./a.out' -ex 'disassemble main'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompile-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[Boost].DI header\n\n\nTime [s]\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\n0.050s\n\n\n\n\n\n\n\n\nLegend:\n    ctor    = raw constructor: T(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(T, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector\nT\n configure();\n\n\n\n\n\n\n* 4248897537 instances created\n* 132 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 1862039751439806464 instances created\n* 200 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules\n\n\n\n\nC++ Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].DI (\nSee Performance\n)\n\n\ndicpp\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\nVersion\n\n\n1.0.1\n\n\nHEAD\n\n\n2.0.2\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nC++11\n\n\nC++11\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\nheader only\n\n\nlibrary\n\n\n\n\n\n\nDependencies\n\n\n-\n\n\nboost system/boost thread\n\n\n-\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile/run-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors/exceptions\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make\n\n\n\n\n\n\nC++ vs Java vs C# Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].DI\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nJava\n\n\nJava\n\n\nC#\n\n\n\n\n\n\nVersion\n\n\n1.0.1\n\n\n4.0\n\n\n2.4\n\n\n3.2\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\njar\n\n\njar\n\n\ndll\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile-time (annotation processor)\n\n\nrun-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors\n\n\nexceptions\n\n\n\n\n\n\n\n\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\n$CXX -O2/Java8/Mono4.2\n\n\n\n\n\n\n\n\n\n\n\n\nBaseline\n\n\nManual object creation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a unique objects tree for each iteration\nTYPES: 64\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7 -O2 / Java8 / Mono4.2 --aot\n\n\nBaseline\n\n\n[Boost].DI\n\n\nGoogle.Fruit\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\nCompilation time\n\n\n0.063s\n\n\n0.376s\n\n\n2.329s / FRUIT_NO_LOOP_CHECK\n\n\n0.570s\n\n\n1.411s\n\n\n0.144s + 0.079s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.5K\n\n\n213K\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.002s\n\n\n0.002s\n\n\n0.037s\n\n\n0.528s\n\n\n0.157s\n\n\n1.131s\n\n\n\n\n\n\nTYPES: 128\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.082s\n\n\n0.706s\n\n\n4.375s / FRUIT_NO_LOOP_CHECK\n\n\n0.642s\n\n\n1.903s\n\n\n0.149s + 0.093s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.5K\n\n\n513K\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.002s\n\n\n0.002s\n\n\n0.074s\n\n\n0.544s\n\n\n0.210s\n\n\n2.230s\n\n\n\n\n\n\nTYPES: 256\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.131s\n\n\n1.328s\n\n\n9.641s / FRUIT_NO_LOOP_CHECK\n\n\n0.783s\n\n\n2.814s\n\n\n0.151s + 0.114s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.7K\n\n\n1.4M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.003s\n\n\n0.003s\n\n\n0.154s\n\n\n0.723s\n\n\n0.323s\n\n\n4.838s\n\n\n\n\n\n\nTYPES: 512\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.215s\n\n\n2.459s\n\n\n23.924s / FRUIT_NO_LOOP_CHECK\n\n\n1.054s\n\n\n4.231s\n\n\n0.157s + 0.161\n\n\n\n\n\n\nExecutable size\n\n\n8.2K\n\n\n13K\n\n\n4.2M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.003s\n\n\n0.003s\n\n\n0.328s\n\n\n0.943s\n\n\n0.547s\n\n\n11.123s\n\n\n\n\n\n\nTYPES: 1024\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.402s\n\n\n4.911s\n\n\n1m9.601s / FRUIT_NO_LOOP_CHECK\n\n\n1.357s\n\n\n5.943s\n\n\n0.167s + 0.258\n\n\n\n\n\n\nExecutable size\n\n\n12K\n\n\n17K\n\n\n15M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.004s\n\n\n0.004s\n\n\n0.765s\n\n\n1.334s\n\n\n0.998s\n\n\n21.808s\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make\n\n\n\n\n\n\nUsage of C++ vs Java vs C# Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Interface\n\n\nPerformance\n\n\n\n\n\n\n\n\n\n\n[Boost].DI\n\n\n\n\nASM x86-64\n\n\n\n\n\n\ndicpp\n\n\n\n\nASM x86-64\n\n\n\n\n\n\nGoogle.Fruit\n\n\n\n\nASM x86-64\n\n\n\n\n\n\nGoogle.Guice\n\n\n\n\n\n\n\n\n\n\nDagger2\n\n\n\n\n\n\n\n\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Value\n\n\nPerformance\n\n\n\n\n\n\n\n\n\n\n[Boost].DI\n\n\n\n\nASM x86-64\n\n\n\n\n\n\ndicpp\n\n\n\n\nASM x86-64\n\n\n\n\n\n\nGoogle.Fruit\n\n\n\n\nASM x86-64\n\n\n\n\n\n\nGoogle.Guice\n\n\n\n\n\n\n\n\n\n\nDagger2\n\n\n\n\n\n\n\n\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nMissing Bindings Error\n\n\n\n\n\n\n\n\n\n\n[Boost].DI\n\n\n\n\n\n\n\n\ndicpp\n\n\n\n\n\n\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\nGoogle.Guice\n\n\n\n\n\n\n\n\nDagger2\n\n\n\n\n\n\n\n\nNinject", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/benchmarks/index.html#performance", 
            "text": "Run-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions /  gdb -batch -ex 'file ./a.out' -ex 'disassemble main'              Compile-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions          [Boost].DI header  Time [s]      #include  boost/di.hpp  0.050s     Legend:\n    ctor    = raw constructor: T(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(T, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector T  configure();   * 4248897537 instances created\n* 132 different types\n* 10 modules    * 1862039751439806464 instances created\n* 200 different types\n* 10 modules    * 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules", 
            "title": "Performance"
        }, 
        {
            "location": "/benchmarks/index.html#c-libraries", 
            "text": "Library  [Boost].DI ( See Performance )  dicpp  Google.Fruit      Version  1.0.1  HEAD  2.0.2    Language  C++14  C++11  C++11    License  Boost 1.0  Boost 1.0  Apache 2.0    Linkage  header only  header only  library    Dependencies  -  boost system/boost thread  -    Approach  compile-time  run-time  compile/run-time    Errors  compile-time errors  exceptions  compile-time errors/exceptions      To run benchmarks   cd benchmark   make", 
            "title": "C++ Libraries"
        }, 
        {
            "location": "/benchmarks/index.html#c-vs-java-vs-c-libraries", 
            "text": "Library  [Boost].DI  Google.Guice  Dagger2  Ninject      Language  C++14  Java  Java  C#    Version  1.0.1  4.0  2.4  3.2    License  Boost 1.0  Apache 2.0  Apache 2.0  Apache 2.0    Linkage  header only  jar  jar  dll    Approach  compile-time  run-time  compile-time (annotation processor)  run-time    Errors  compile-time errors  exceptions  compile-time errors  exceptions      Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  $CXX -O2/Java8/Mono4.2       Baseline  Manual object creation        Create a unique objects tree for each iteration TYPES: 64    BINDINGS: 0    ITERATIONS: 1024            Clang-3.7 -O2 / Java8 / Mono4.2 --aot  Baseline  [Boost].DI  Google.Fruit  Google.Guice  Dagger2  Ninject    Compilation time  0.063s  0.376s  2.329s / FRUIT_NO_LOOP_CHECK  0.570s  1.411s  0.144s + 0.079s    Executable size  4.2K  8.5K  213K  -  -  -    Execution time  0.002s  0.002s  0.037s  0.528s  0.157s  1.131s    TYPES: 128    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.082s  0.706s  4.375s / FRUIT_NO_LOOP_CHECK  0.642s  1.903s  0.149s + 0.093s    Executable size  4.2K  8.5K  513K  -  -  -    Execution time  0.002s  0.002s  0.074s  0.544s  0.210s  2.230s    TYPES: 256    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.131s  1.328s  9.641s / FRUIT_NO_LOOP_CHECK  0.783s  2.814s  0.151s + 0.114s    Executable size  4.2K  8.7K  1.4M  -  -  -    Execution time  0.003s  0.003s  0.154s  0.723s  0.323s  4.838s    TYPES: 512    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.215s  2.459s  23.924s / FRUIT_NO_LOOP_CHECK  1.054s  4.231s  0.157s + 0.161    Executable size  8.2K  13K  4.2M  -  -  -    Execution time  0.003s  0.003s  0.328s  0.943s  0.547s  11.123s    TYPES: 1024    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.402s  4.911s  1m9.601s / FRUIT_NO_LOOP_CHECK  1.357s  5.943s  0.167s + 0.258    Executable size  12K  17K  15M  -  -  -    Execution time  0.004s  0.004s  0.765s  1.334s  0.998s  21.808s      To run benchmarks   cd benchmark   make", 
            "title": "C++ vs Java vs C# Libraries"
        }, 
        {
            "location": "/benchmarks/index.html#usage-of-c-vs-java-vs-c-libraries", 
            "text": "Library  Bind Interface  Performance      [Boost].DI   ASM x86-64    dicpp   ASM x86-64    Google.Fruit   ASM x86-64    Google.Guice      Dagger2      Ninject          Library  Bind Value  Performance      [Boost].DI   ASM x86-64    dicpp   ASM x86-64    Google.Fruit   ASM x86-64    Google.Guice      Dagger2      Ninject          Library  Missing Bindings Error      [Boost].DI     dicpp     Google.Fruit     Google.Guice     Dagger2     Ninject", 
            "title": "Usage of C++ vs Java vs C# Libraries"
        }, 
        {
            "location": "/user_guide/index.html", 
            "text": "Injector\n\n\ndi::make_injector\n\n\n\n\n\n\nBindings\n\n\ndi::bind\n\n\n\n\n\n\nInjections\n\n\nautomatic (default)\n\n\nBOOST_DI_INJECT\n\n\nBOOST_DI_INJECT_TRAITS\n\n\ndi::inject\n\n\ndi::ctor_traits\n\n\n\n\n\n\nAnnotations\n\n\n(named = name)\n\n\n\n\n\n\nScopes\n\n\ndi::deduce (default)\n\n\ndi::instance (di::bind\n.to(value))\n\n\ndi::singleton\n\n\ndi::unique\n\n\n\n\n\n\nModules\n\n\nBOOST_DI_EXPOSE\n\n\n\n\n\n\nProviders\n\n\ndi::providers::stack_over_heap (default)\n\n\ndi::providers::heap\n\n\n\n\n\n\nPolicies\n\n\ndi::policies::constructible\n\n\n\n\n\n\nConcepts\n\n\ndi::concepts::boundable\n\n\ndi::concepts::callable\n\n\ndi::concepts::configurable\n\n\ndi::concepts::creatable\n\n\ndi::concepts::providable\n\n\ndi::concepts::scopable\n\n\n\n\n\n\nConfiguration\n\n\ndi::config\n\n\n\n\n\n\nImplementation details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBindings\n\n\nDSL to create dependencies representation which will be used by core to resolve types\n\n\n\n\n\n\nScopes\n\n\nResponsible for maintain objects life time\n\n\n\n\n\n\nProviders\n\n\nResponsible for providing object instance\n\n\n\n\n\n\nPolicies\n\n\nCompile-time limitations for types / Run-time types vistor\n\n\n\n\n\n\nConfig\n\n\nConfiguration for [Policies] and [Providers]\n\n\n\n\n\n\nCore\n\n\nResponsible for resolving requested types (implementation detail)\n\n\n\n\n\n\nWrappers\n\n\nResponsible for conversion to required type (implementation detail)\n\n\n\n\n\n\n\n\n\n\nLet's assume all examples below include \nboost/di.hpp\n header and define a convenient \ndi\n\nnamespace alias as well as some basic interfaces and types.\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\nstruct i1 { virtual ~i1() = default; virtual void dummy1() = 0; };\nstruct i2 { virtual ~i2() = default; virtual void dummy2() = 0; };\nstruct impl1 : i1 { void dummy1() override { } };\nstruct impl2 : i2 { void dummy2() override { } };\nstruct impl : i1, i2 { void dummy1() override { } void dummy2() override { } };\n\n\n\n\nInjector\n\n\n\n\nInjector is a core component providing types creation functionality using \nbindings\n.\n\n\n--- \ndi::make_injector\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates \ninjector\n type.\n\n\nSemantics\n\n\ntemplate\nclass... TDeps\n requires boundable\nTDeps...\n\nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector\n) = default;\n  template \nclass... Ts\n // no requirements\n  injector(core::injector\nTs...\n) noexcept;\n  explicit injector(const TDeps\n...) noexcept;\n\n  template \nclass T\n\n  injector\n operator=(T\n other) noexcept;\n\n  template\nclass T\n requires creatable\nT\n\n  T create() const;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTDeps...\n\n\nboundable\nTDeps...>\n\n\nBindings\n to be used as configuration\n\n\n-\n\n\n\n\n\n\ncreate\nT\n()\n\n\ncreatable\nT>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType \nT\n\n\nIs allowed?\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\nReference with \nsingleton\n / Temporary with \nunique\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::weak_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nboost_shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\n\n\ntemplate\n\n  class TConfig = di::config\n, class... TBindings\n\n requires configurable\nTConfig\n \n boundable\nTBindings...\n\nauto make_injector(TBindings...) noexcept;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTConfig\n\n\nconfigurable\nTConfig>\n\n\nConfiguration\n per \ninjector\n\n\n-\n\n\n\n\n\n\nmake_injector(TBindings...)\n\n\nboundable\nTBindings...>\n\n\nCreates \ninjector\n with given \nBindings\n\n\ninjector\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nInjection in a nutshell\n (implementation detail)\n\n\nThe main interface of the injector is a \ncreate\n method.\nWhen \ncreate\n method is called for type \nT\n the magic happens.\nFirstly, policies are verified (for example, whether the type \nT\n is allowed to be created).\nThen, the constructor traits are deduced (\nctor_traits\n ) for type \nT\n and dependencies of the constructor\nparameters are resolved (\nbinder\n). \nwrapper\n is used to convert internal representation\nof the dependency into a required type (ex. \nshared_ptr\nT\n). Whole process is repeated\nrecursively for all required parameters of \nT\n constructor.\n\n\nstruct direct; // T(...)\nstruct uniform; // T{...}\n\ntemplate\nclass T, class... TArgs\n is_braces_constructible; // type T is constructible using T{...}\ntemplate\nclass T, class... TArgs\n is_constructible; // Type T is constructible using T(...)\n\ntemplate\nclass T\n is_injectable; // Type T uses BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS\n\ntemplate\nclass TConfig, class... TBindings\n // For Example, TBindings = { di::bind\nInterface\n.to\nImplementation\n }\nstruct core::injector : TBindings... {\n  using config = TConfig;\n  using deps = TBindings...;\n\n  template\nclass T\n // For example, T = Interface\n  auto create() const noexcept {\n    TConfig::policies\nT\n()...; // verify policies\n    using Type = core::binder\nTBindings...\n().resolve\nT\n(*this); // Type = Implementation\n    return core::wrapper\nT\n{dependency.create(provider\nTInjector\n{*this}.get\nType\n())};\n  }\n};\n\ntemplate\nclass TInjector, class TConfig\n\nstruct provider {\n  template\nclass T\n auto get() const noexcept {\n    using pair\nTInitialization, TCtor...\n = decltype(ctor_traits\nTInjector, T\n());\n    return TConfig::provider().get(TInitialization{}, TCtor...);\n  }\n  const TInjector\n injector;\n};\n\ntemplate\nclass TInjector\n\nstruct any_type {\n  template\nclass T\n\n  operator T() const {\n    return injector.templte create\nT\n();\n  }\n  const TInjector\n injector;\n};\n\ntemplate\nclass TInjector, class T\n\nauto ctor_traits() {\n  if (is_injectable\nT\n() {\n    return pair\ndirect, typename T::boost_di_inject__\n{}; // BOOST_DI_INJECT(T, args...) -\n T(args...)\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i \n= 0; --i) {\n    if (is_constructible\nT, any_type\nTInjector\n...\n()) { // ... -\n i times\n      return pair\ndirect, any_type\nTInjector\n...\n{}; // T(any_type...)\n    }\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i \n= 0; --i) {\n    if (is_braces_constructible\nT, any_type\nTInjector\n...\n()) { // ... -\n i times\n      return pair\nuniform, any_type\nTInjector\n...\n{}; // T{any_type...}\n    }\n  }\n\n  return error(...);\n};\n\n\n\n\n \nNote\n\n\nAutomatic injection\n depends on template implicit conversion operator and therefore\nconversion constructors \ntemplate\nclass I\n T(I)\n are not supported and have to be injected using \nBOOST_DI_INJECT\n, \nBOOST_DI_INJECT_TRAITS\n, \ndi::inject\n or \ndi::ctor_traits\n.\n\n\n\n\n\nBindings\n\n\nBindings define dependencies configuration describing what types will be created\nand what values will be passed into them.\n\n\n\n--- \ndi::bind\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nAllows to bind interface to implementation and associate value with it.\n\n\nSemantics\n\n\nstruct override; // overrides given configuration\n\nnamespace detail {\n  template\nclass I, class... Is/*any_of*/\n requires boundable\nI, Is...\n\n  struct bind {\n    bind(bind\n) noexcept = default;\n\n    template \nclass T\n requires !is_array\nI\n \n boundable\nI, T\n\n    auto to() noexcept;\n\n    template \nclass... Ts\n requires is_array\nI\n \n boundable\nTs...\n\n    auto to() noexcept;\n\n    template\nclass T\n requires boundable\nI, T\n\n    auto to(T\n) noexcept;\n\n    template\nclass TScope\n requires scopable\nTScope\n\n    auto in(const TScope\n = di::deduce) noexcept;\n\n    template\nclass TName\n // no requirements\n    auto named(const TName\n = {}) noexcept;\n\n    auto operator[](const override\n) noexcept;\n  };\n} // detail\n\ntemplate\nclass... Ts\n requires boundable\nTs...\n\ndetail::bind\nTs...\n bind{};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nI\n, \nIs...\n\n\nboundable\nI, Is...>\n\n\n'Interface' types\n\n\n-\n\n\n\n\n\n\nto\nT\n\n\nboundable\nT>\n\n\nBinds \nI, Is...\n to \nT\n type\n\n\nboundable\n\n\n\n\n\n\nto\nTs...\n\n\nboundable\nTs...>\n\n\nBinds \nI, Is...\n to \nTs...\n type\n\n\nboundable\n\n\n\n\n\n\nto(T\n)\n\n\nboundable\nT>\n\n\nBinds \nI, Is...\n to \nT\n object\n\n\nboundable\n\n\n\n\n\n\nin(const TScope\n)\n\n\nscopable\nTScope>\n\n\nBinds \nI, Is...\n in TScope`\n\n\nboundable\n\n\n\n\n\n\nnamed(const TName\n)\n\n\n-\n\n\nBinds \nI, Is...\n using \nnamed\n annotation\n\n\nboundable\n\n\n\n\n\n\noperator[](const override\n)\n\n\n-\n\n\nOverrides given binding\n\n\nboundable\n\n\n\n\n\n\n\n\n \nNote\n\nCheck out also \ninstance\n scope to read more about binding to values: \ndi::bind\n.to(value)\n.\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMultiple Interfaces\n\n\n\n\n\n\n\n\ndi::bind\nInterface1, Interface2, ...\n.to\nImplementation\n()\n\n\nBinds \nInterface1, Interface2, ...\n to \nImplementation\n using one object\n\n\n\n\n\n\nMultiple Bindings\n (std::array, std::vector, std::set)\n\n\n\n\n\n\n\n\ndi::bind\nint[]\n.to({1, 2, ...})\n\n\nBinds \nint\n to values \n1, 2, ...\n\n\n\n\n\n\ndi::bind\nInterface*[]\n.to\nImplementation1, Implementation2, ...\n()\n\n\nBinds \nInterface\n to \nImplementation1, Implementation2, ...\n\n\n\n\n\n\nDynamic Bindings\n\n\n\n\n\n\n\n\ndi::bind\nInterface\n.to([](const auto\n injector)\n{ return injector.template create\nImplementation\n()})\n\n\nAllows to bind \nInterface\n depending on a run-time condition\n\n\n\n\n\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInjections\n\n\nConstructor Injection\n is the most powerful of available injections.\nIt guarantees initialized state of data members. [Boost].DI constructor injection is achieved without any additional work from the user.\n\n\n\n--- \nautomatic (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\n[Boost].DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with\n\nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n or di::ctor_traits] or \ndi::inject\n.\n\n\n \nNote\n\nAutomatic constructor parameters deduction is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nSemantics\n\n\nclass T {\npublic:\n  T(auto parameter1, auto parameter2, ..., auto parameterN);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nparameter1-parameterN\n\n\n-\n\n\nN\n constructor parameter\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\n[Boost].DI is not able to automatically distinguish between ambiguous constructors with the same (longest) number of parameters.\nUse \nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n or \ndi::ctor_traits\n or \ndi::inject\n to explicitly mark constructor to be injected.\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT is a macro definition used to explicitly say [Boost].DI which constructor should be used as well as to annotate types - see \nannotations\n for further reding.\nWhen class has more than one constructor [Boost].DI will by default choose the one with the longest parameter list.\nIn case of constructors ambiguity, [Boost].DI is not able to choose the best one.\nThen BOOST_DI_INJECT becomes handy to point which constructor should be used.\n\n\nSemantics\n\n\nstruct T {\n    BOOST_DI_INJECT(T, ...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\nClass/Struct name\n\n\n-\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\nBOOST_DI_INJECT constructor parameters is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT_TRAITS\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.\n\n\nSemantics\n\n\nstruct T {\n  BOOST_DI_INJECT_TRAITS(...) { }\n  T(...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\nBOOST_DI_INJECT_TRAITS constructor parameters is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nTest\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n--- \ndi::inject\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\ndi::inject\n informs [Boost].DI about constructor parameters.\nIt's useful for generated/generic classes as it doesn't have constructor parameters size limitations.\n\n\nSemantics\n\n\nstruct T {\n  using boost_di_inject__ = di::inject\n...\n;\n  T(...) {}\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\n\ndi::inject\n has no limitations if it comes to constructor parameters, however, \nnamed\n parameters are not allowed.\nMoreover, you can replace \ndi::inject\n with any variadic type list type to remove dependency to [Boost].DI.\nFor example, \ntemplate\nclass...\n struct type_list{};\n \nusing boost_di_inject__ = type_list\n...\n;\n\n\n\n\nTest\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n--- \ndi::ctor_traits\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\ndi::ctor_traits\n is a trait in which constructor parameters for type \nT\n might be specified.\nIt's useful for third party classes you don't have access to and which can't be created using \nautomatic\n injection.\n\n\nSemantics\n\n\nnamespace boost {\nnamespace di {\n  template \n\n  struct ctor_traits\nT\n {\n    BOOST_DI_INJECT_TRAITS(...); // or using type = di::inject\n...\n;\n  };\n}}\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\nAnnotations\n\n\nAnnotations are type properties specified in order to refer to a type by the name instead of the type it self.\nThey are useful when constructor has more than one parameter of the same type.\nFor example, \nT(int, int)\n.\n\n\n\n--- \n(named = name)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nNamed parameters are handy to distinguish different constructor parameters of the same type.\n\n\n  T(int value1, int value2);\n\n\n\n\nIn order to inject proper values into \nvalue1\n and \nvalue2\n they have to be differentiate somehow.\n[Boost].DI solution for this problem are annotations.\n\n\n \nNote\n\nAnnotations might be set only when constructor is marked using \nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n.\n\n\n\nSemantics\n\n\nauto Name = []{}; // just an object\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nName\n\n\n-\n\n\nObject representing named type\n\n\n-\n\n\n\n\n\n\n\n\nExample\n\n\nBOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);\n\n\n\n \nNote\n\nImplementation of constructor doesn't require annotations, only constructor definition requires them.\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nScopes\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given, \ndeduce\n scope will be assumed.\n\n\nSemantics\n\n\ntemplate \nclass TExpected, class TGiven\n\nstruct scope {\n  template \nclass T\n\n  using is_referable;\n\n  template \nclass T, class TName, class TProvider\n\n  static auto try_create(const TProvider\n);\n\n  template \nclass T, class TName, class TProvider\n\n  auto create(const TProvider\n);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::deduce (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nDefault scope which will be converted to one of the scopes depending on the type.\n\n\n\n\n\n\n\n\nType\n\n\nScope\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique\n (temporary) / \nsingleton\n\n\n\n\n\n\nT*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nstd::unique_ptr\n\n\nunique\n\n\n\n\n\n\nstd::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nboost::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nstd::weak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct deduce {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::deduce deduce;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::instance (di::bind\n.to(value))\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing values - passed externally. The life time of the object depends on the user.\n[Boost].DI is not maintaining the life time of these objects, however, values and strings will be copied and managed by the library.\n\n\n\n\n\n\n\n\nType\n\n\ninstance[in] (\nbind\n.to(in)\n)\n\n\ninstance[out] (\ninjector.create\nout\n()\n)\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT*\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct instance {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::singleton\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing shared value between all instances as well as threads.\nSingleton scope will be deduced in case of reference, \nstd::shared_ptr\n, \nboost::shared_ptr\n or \nstd::weak_ptr\n.\n\n\n \nNote\n\nSingleton scope will convert automatically between \nstd::shared_ptr\n and \nboost::shared_ptr\n if required.\n\n\n\n\n\n\n\n\n\nType\n\n\nsingleton\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\n\n\n\n\nT*\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n-\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n\u2714\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct singleton {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::singleton singleton;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::unique\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing unique/per request value. A new instance will be provided each time type will be requested.\n\n\n\n\n\n\n\n\nType\n\n\nunique\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\n\n\n\nT*\n\n\n\u2714 (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\n\u2714 (ownership transfer)\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct unique {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::unique unique;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\nModules\n\n\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nModules allow to split \nbindings\n configuration into smaller \ninjectors\n.\nModule might be installed by passing it into \nmake_injector\n.\n\n\nSemantics\n\n\nauto module = di::make_injector(...);\ndi::injector\nTs...\n module = di::make_injector(...);\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nauto module = di::make_injector(...)\n\n\nAll types are exposed from \nmodule\n\n\nmodule.create\nT\n()\n is allowed for any \nT\n\n\n\n\n\n\ndi::injector\nTs...\n module = di::make_injector(...)\n\n\nOnly \nTs...\n types are exposed from \nmodule\n\n\nmodule.create\nT\n()\n is allowed only for \nT\n \n= \nTs...\n\n\n\n\n\n\n\n\nTest\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n--- \nBOOST_DI_EXPOSE\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_EXPOSE is a macro definition allowing to expose \nnamed\n parameters via module/\ninjector\n.\n\n\nSemantics\n\n\ndi::injector\nBOOST_DI_EXPOSE((named = Name) T), ...\n;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nName\n\n\n-\n\n\nNamed object\n\n\n-\n\n\n\n\n\n\n...\n\n\n-\n\n\nMore types to be exposed\n\n\n-\n\n\n\n\n\n\n\n\nTest\n\n\n\n\n\n\nExample\n\n\n\n\n\n\nProviders\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProviders are responsible for creating objects using given \nConfiguration\n.\n\n\nSemantics\n\n\nnamespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\nstruct config : di::config {\n  template\nclass TInjector\n\n  static auto provider(const TInjector\n) noexcept { return providers::stack_over_heap{}; }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTInjector\n\n\n-\n\n\ninjector\n\n\n-\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\n \nNote\n\nProvider used by \ninjector\n might changed locally via \nmake_injector\n or globally via \nBOOST_DI_CFG\n.\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::providers::stack_over_heap (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates objects on the stack whenever possible, otherwise on the heap.\n\n\nSemantics\n\n\nnamespace providers {\n  class stack_over_heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nTMemory\n\n\n\n\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nconst T\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT*\n\n\nheap\n\n\n\n\n\n\nconst T*\n\n\nheap\n\n\n\n\n\n\nstd::unique_ptr\n\n\nheap\n\n\n\n\n\n\nstd::shared_ptr\n\n\nheap\n\n\n\n\n\n\nstd::weak_ptr\n\n\nheap\n\n\n\n\n\n\nboost::shared_ptr\n\n\nheap\n\n\n\n\n\n\nis_polymorphic\nT\n\n\nheap\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n--- \ndi::providers::heap\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBasic provider creates objects on the heap (always).\n\n\nSemantics\n\n\nnamespace providers {\n  class heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nPolicies\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via \nConfiguration\n.\n\n\n \nNote\n\nBy default [Boost].DI has NO policies enabled.\n\n\n\nSemantics\n\n\ntemplate \nclass... TPolicies\n requires callable\nTPolicies...\n\nauto make_policies(TPolicies...) noexcept;\n\nstruct config : di::config {\n  template\nclass TInjector\n\n  static auto policies(const TInjector\n) noexcept { return make_policies(...); }\n};                                                                        |\n                                                                          |\n// policy                                                                 /\ntemplate\nclass T\n   \n-----------------------------------------------------\nvoid operator()(const T\n);\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTInjector\n\n\n-\n\n\ninjector\n\n\n-\n\n\n\n\n\n\nmake_policies\nTPolicies...\n\n\ncallable\nTPolicies...>\n\n\nCreates policies\n\n\ncallable\n list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nT::type\n\n\nType to be created\n\n\nstd::shared_ptr\nint\n\n\n\n\n\n\nT::expected\n\n\nDecayed 'Interface' type\n\n\ninterface\n\n\n\n\n\n\nT::given\n\n\nDecayed 'Given' type\n\n\nimplementatoin\n\n\n\n\n\n\nT::name\n\n\nAnnotation name\n\n\nmy_name\n\n\n\n\n\n\nT::arity\n\n\nNumber of constructor arguments\n\n\nintegral_constant\nint, 3\n\n\n\n\n\n\nT::scope\n\n\nscope\n\n\nsingleton\n\n\n\n\n\n\nT::is_root\n\n\nIs the root object (a type \ncreate\n was called with)\n\n\ntrue_type\n/\nfalse_type\n\n\n\n\n\n\n\n\n \nNote\n\nIn order for injector to verify policies they have to be created using \nconfig\n and passed via \nTConfig\n in \nmake_injector\n\nor set it globally via \nBOOST_DI_CFG\n.\n\n\n\nTest\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::policies::constructible\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nConstructible policy limits constructor parameters to explicitly allowed.\n\n\n \nNote\n\nBy default constructible policy disables creation of any constructor parameters.\n\n\n\nSemantics\n\n\nnamespace policies {\n  struct _ { }; // placeholder\n\n  constexpr auto include_root = true;\n\n  template\nclass T\n\n  struct is_root; // true when is the root type (`create\nRooType\n()`)\n\n  template\nclass T\n\n  struct is_bound; // true when type is bound with 'di::bind\nT\n'\n\n  template \nclass T\n\n  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'\n\n  template\nbool IncludeRoot = false, class T\n\n  auto constructible(const T\n) noexcept;\n}\n\nnamespace operators {\n  template\nclass X\n\n  inline auto operator!(const X\n)\n\n  template\nclass X, class Y\n\n  inline auto operator\n(const X\n, const Y\n);\n\n  template\nclass X, class Y\n\n  inline auto operator||(const X\n, const Y\n);\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_root\nT\n\n\n-\n\n\nVerify whether type \nT\n is a root type\n\n\ntrue_type/false_type\n\n\n\n\n\n\nis_bound\nT\n\n\n-\n\n\nVerify whether type \nT\n is bound\n\n\ntrue_type/false_type\n\n\n\n\n\n\nis_injected\nT\n\n\n-\n\n\nVerify whether type \nT\n is injected via \nBOOST_DI_INJECT\n\n\ntrue_type/false_type\n\n\n\n\n\n\n\n\n \nNote\n\nIn order to allow logic operators using namespace \nboost::di::policies::operators\n has to be used.\n\n\n\nTest\n\n\n\n\n\n\n \nNote\n\nSTL type traits are supported and might be combined with [Boost].DI traits in order to limit constructor types\nFor example, \nstd::is_same\n_, int\n{} || std::is_constructible\n_, int, int\n{} || std::is_base_of\nint, _\n{}\n, etc...\n\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nConcepts\n\n\nConcepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.\n\n\n\n--- \ndi::concepts::boundable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBindings\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass TExpected, class TGiven\n\nconcept bool boundable() {\n  return is_complete\nTExpected\n()\n      \n is_complete\nTGiven\n()\n      \n (is_base_of\nTExpected, TGiven\n() || is_convertible\nTGiven, TExpected\n());\n}\n\ntemplate \nclass... Ts\n\nconcept bool boundable() {\n  return is_supported\nTs\n()...\n      \n is_movable\nTs\n()...\n      \n (is_base_of\ninjector, Ts\n()... || is_base_of\ndependency, Ts\n()...);\n}\n\n\n\nSemantics\n\n\nboundable\nT\n\nboundable\nTs...\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTs...\n\n\nBindings to be verified\n\n\ntrue_type if constraint is satisfied, \nError\n otherwise\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_disallowed_qualifiers\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has disallowed qualifiers\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_abstract\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is abstract\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0, 1 -\n no additional info, 2 -\n info about why type \nT\n is abstract\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_not_related_to\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is not related to type \nU\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_bound_more_than_once\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is bound more than once\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_neither_a_dependency_nor_an_injector\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is neither a dependency nor an injector\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::callable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicy\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}\n\n\n\nSemantics\n\n\ncallable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\npolicy\nTPolicy\n::requires_\ncall_operator\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\npolicy \nTPolicy\n requires a call operator\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::configurable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nConfiguration\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool configurable() {\n  return requires(T object) {\n    return providable\ndecltype(T::provider(...))\n \n callable\ndecltype(T::policies(...))\n();\n  }\n}\n\n\n\nSemantics\n\n\nconfigurable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nconfig\nTConfig\n::requires_\nprovider\nprovidable_type (...)\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nconfig \nT\n requires only providable and callable types\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::creatable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nRequirement for type \nT\n which is going to be created via \ninjector\n.create\nT\n()\n\n\nSynopsis\n\n\nnamespace type_traits {\n  template\nclass T\n\n  using ctor_traits; // returns list of constructor parameters\n}\n\ntemplate \nclass T, class... TArgs\n\nconcept bool creatable() {\n  return is_constructible\nT, TArgs...\n() \n\n         is_constructible\nTArgs, type_traits::ctor_traits\nTArgs\n...\n();\n}\n\n\n\nSemantics\n\n\ncreatable\nT, TArgs...\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nabstract_type\nT\n::is_not_bound\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nabstract type \nT\n is not bound\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'type is not bound, did you forget to add: 'di::bind\n.to\n()'?'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_ambiguous_number_of_constructor_parameters::given\nGiven\n::expected\nExpected\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has ambiguous number of constructor parameters where \nGiven\n were provided but \nExpected\n were expected\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_to_many_constructor_parameters::max\nMax\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has to many constructor parameter where maximum number is \nMax\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\nTScope\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind\n.in(scope)'?'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\ninstance\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ninstance is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'instance is not convertible to the requested type, verify binding: 'di::bind\n.to(value)'?'\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n \nNote\n\nSuggestions are not supported/displayed by MSVC-2015.\n\n\n\n\n\n\n--- \ndi::concepts::providable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProvider\n type requirement.\n\n\nSynopsis\n\n\nnamespace type_traits {\n  struct direct;\n  struct uniform;\n  struct stack;\n  struct heap;\n}\n\ntemplate \nclass T\n\nconcept bool providable() {\n  return requires(T object) {\n    { object.template get\n_\n(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n    { object.template is_creatable\n_\n(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n  }\n}\n\n\n\nSemantics\n\n\nprovidable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nprovider\nTProvider\n::requires_\nget\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nprovider \nTProvider\n requires \nget\n method\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- \ndi::concepts::scopable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope\n type requirement.\n\n\nSynopsis\n\n\nstruct _ {}; // any type\n\ntemplate \nclass T\n\nconcept bool scopable() {\n  return requires(T) {\n    typename scope\n_, _\n::is_referable;\n    { T::scope\n_, _\n{}.try_create() };\n    { T::scope\n_, _\n{}.create() };\n  }\n}\n\n\n\nSemantics\n\n\nscopable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nscope\nTScope\n::requires_\ncreate\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n requires \ncreate\n method\n\n\n\n\n\n\nExpression\n\n\n\n\n\n\n\n\n\n\n\n\nConfiguration\n\n\n\n--- \ndi::config\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nInjector\n configuration.\n\n\nSynopsis\n\n\nstruct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nprovider()\n\n\nprovidable\n\n\nCreates provider\n\n\nprovidable\n\n\n\n\n\n\npolicies()\n\n\ncallable\n\n\nCreates policies\n\n\ncallable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies\n\n\n\n\n\n\n\n\nSemantics\n\n\ndi::make_injector\nconfig\n(...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)\n\n\n\nTest\n\n\n\n\nExample", 
            "title": "User Guide"
        }, 
        {
            "location": "/user_guide/index.html#injector", 
            "text": "Injector is a core component providing types creation functionality using  bindings .  ---  di::make_injector  ---  Header  #include  boost/di.hpp   Description  Creates  injector  type.  Semantics  template class... TDeps  requires boundable TDeps... \nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector ) = default;\n  template  class... Ts  // no requirements\n  injector(core::injector Ts... ) noexcept;\n  explicit injector(const TDeps ...) noexcept;\n\n  template  class T \n  injector  operator=(T  other) noexcept;\n\n  template class T  requires creatable T \n  T create() const;\n};     Expression  Requirement  Description  Returns      TDeps...  boundable TDeps...>  Bindings  to be used as configuration  -    create T ()  creatable T>  Creates type  T  T        Type  T  Is allowed?  Note      T  \u2714  -    T*  \u2714  Ownership transfer!    const T*  \u2714  Ownership transfer!    T  \u2714  -    const T  \u2714  Reference with  singleton  / Temporary with  unique    T  \u2714  -    std::unique_ptr T  \u2714  -    std::shared_ptr T  \u2714  -    std::weak_ptr T  \u2714  -    boost_shared_ptr T  \u2714  -     template \n  class TConfig = di::config\n, class... TBindings  requires configurable TConfig    boundable TBindings... \nauto make_injector(TBindings...) noexcept;     Expression  Requirement  Description  Returns      TConfig  configurable TConfig>  Configuration  per  injector  -    make_injector(TBindings...)  boundable TBindings...>  Creates  injector  with given  Bindings  injector     Test   Example     Injection in a nutshell  (implementation detail)  The main interface of the injector is a  create  method.\nWhen  create  method is called for type  T  the magic happens.\nFirstly, policies are verified (for example, whether the type  T  is allowed to be created).\nThen, the constructor traits are deduced ( ctor_traits  ) for type  T  and dependencies of the constructor\nparameters are resolved ( binder ).  wrapper  is used to convert internal representation\nof the dependency into a required type (ex.  shared_ptr T ). Whole process is repeated\nrecursively for all required parameters of  T  constructor.  struct direct; // T(...)\nstruct uniform; // T{...}\n\ntemplate class T, class... TArgs  is_braces_constructible; // type T is constructible using T{...}\ntemplate class T, class... TArgs  is_constructible; // Type T is constructible using T(...)\n\ntemplate class T  is_injectable; // Type T uses BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS\n\ntemplate class TConfig, class... TBindings  // For Example, TBindings = { di::bind Interface .to Implementation  }\nstruct core::injector : TBindings... {\n  using config = TConfig;\n  using deps = TBindings...;\n\n  template class T  // For example, T = Interface\n  auto create() const noexcept {\n    TConfig::policies T ()...; // verify policies\n    using Type = core::binder TBindings... ().resolve T (*this); // Type = Implementation\n    return core::wrapper T {dependency.create(provider TInjector {*this}.get Type ())};\n  }\n};\n\ntemplate class TInjector, class TConfig \nstruct provider {\n  template class T  auto get() const noexcept {\n    using pair TInitialization, TCtor...  = decltype(ctor_traits TInjector, T ());\n    return TConfig::provider().get(TInitialization{}, TCtor...);\n  }\n  const TInjector  injector;\n};\n\ntemplate class TInjector \nstruct any_type {\n  template class T \n  operator T() const {\n    return injector.templte create T ();\n  }\n  const TInjector  injector;\n};\n\ntemplate class TInjector, class T \nauto ctor_traits() {\n  if (is_injectable T () {\n    return pair direct, typename T::boost_di_inject__ {}; // BOOST_DI_INJECT(T, args...) -  T(args...)\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i  = 0; --i) {\n    if (is_constructible T, any_type TInjector ... ()) { // ... -  i times\n      return pair direct, any_type TInjector ... {}; // T(any_type...)\n    }\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i  = 0; --i) {\n    if (is_braces_constructible T, any_type TInjector ... ()) { // ... -  i times\n      return pair uniform, any_type TInjector ... {}; // T{any_type...}\n    }\n  }\n\n  return error(...);\n};    Note  Automatic injection  depends on template implicit conversion operator and therefore\nconversion constructors  template class I  T(I)  are not supported and have to be injected using  BOOST_DI_INJECT ,  BOOST_DI_INJECT_TRAITS ,  di::inject  or  di::ctor_traits .", 
            "title": "Injector"
        }, 
        {
            "location": "/user_guide/index.html#bindings", 
            "text": "Bindings define dependencies configuration describing what types will be created\nand what values will be passed into them.  \n---  di::bind  ---  Header  #include  boost/di.hpp   Description  Allows to bind interface to implementation and associate value with it.  Semantics  struct override; // overrides given configuration\n\nnamespace detail {\n  template class I, class... Is/*any_of*/  requires boundable I, Is... \n  struct bind {\n    bind(bind ) noexcept = default;\n\n    template  class T  requires !is_array I    boundable I, T \n    auto to() noexcept;\n\n    template  class... Ts  requires is_array I    boundable Ts... \n    auto to() noexcept;\n\n    template class T  requires boundable I, T \n    auto to(T ) noexcept;\n\n    template class TScope  requires scopable TScope \n    auto in(const TScope  = di::deduce) noexcept;\n\n    template class TName  // no requirements\n    auto named(const TName  = {}) noexcept;\n\n    auto operator[](const override ) noexcept;\n  };\n} // detail\n\ntemplate class... Ts  requires boundable Ts... \ndetail::bind Ts...  bind{};     Expression  Requirement  Description  Returns      I ,  Is...  boundable I, Is...>  'Interface' types  -    to T  boundable T>  Binds  I, Is...  to  T  type  boundable    to Ts...  boundable Ts...>  Binds  I, Is...  to  Ts...  type  boundable    to(T )  boundable T>  Binds  I, Is...  to  T  object  boundable    in(const TScope )  scopable TScope>  Binds  I, Is...  in TScope`  boundable    named(const TName )  -  Binds  I, Is...  using  named  annotation  boundable    operator[](const override )  -  Overrides given binding  boundable       Note \nCheck out also  instance  scope to read more about binding to values:  di::bind .to(value) .     Expression  Description      Multiple Interfaces     di::bind Interface1, Interface2, ... .to Implementation ()  Binds  Interface1, Interface2, ...  to  Implementation  using one object    Multiple Bindings  (std::array, std::vector, std::set)     di::bind int[] .to({1, 2, ...})  Binds  int  to values  1, 2, ...    di::bind Interface*[] .to Implementation1, Implementation2, ... ()  Binds  Interface  to  Implementation1, Implementation2, ...    Dynamic Bindings     di::bind Interface .to([](const auto  injector) { return injector.template create Implementation ()})  Allows to bind  Interface  depending on a run-time condition     Test            Example", 
            "title": "Bindings"
        }, 
        {
            "location": "/user_guide/index.html#injections", 
            "text": "Constructor Injection  is the most powerful of available injections.\nIt guarantees initialized state of data members. [Boost].DI constructor injection is achieved without any additional work from the user.  \n---  automatic (default)  ---  Header  #include  boost/di.hpp   Description  [Boost].DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS  or di::ctor_traits] or  di::inject .    Note \nAutomatic constructor parameters deduction is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Semantics  class T {\npublic:\n  T(auto parameter1, auto parameter2, ..., auto parameterN);\n};     Expression  Requirement  Description  Returns      parameter1-parameterN  -  N  constructor parameter  -       Note \n[Boost].DI is not able to automatically distinguish between ambiguous constructors with the same (longest) number of parameters.\nUse  BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS  or  di::ctor_traits  or  di::inject  to explicitly mark constructor to be injected.  Test      Example       \n---  BOOST_DI_INJECT  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_INJECT is a macro definition used to explicitly say [Boost].DI which constructor should be used as well as to annotate types - see  annotations  for further reding.\nWhen class has more than one constructor [Boost].DI will by default choose the one with the longest parameter list.\nIn case of constructors ambiguity, [Boost].DI is not able to choose the best one.\nThen BOOST_DI_INJECT becomes handy to point which constructor should be used.  Semantics  struct T {\n    BOOST_DI_INJECT(T, ...) { }\n};     Expression  Requirement  Description  Returns      T  -  Class/Struct name  -    ...  -  T  constructor parameters  -       Note \nBOOST_DI_INJECT constructor parameters is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Test   Example     \n---  BOOST_DI_INJECT_TRAITS  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.  Semantics  struct T {\n  BOOST_DI_INJECT_TRAITS(...) { }\n  T(...) { }\n};     Expression  Requirement  Description  Returns      ...  -  T  constructor parameters  -       Note \nBOOST_DI_INJECT_TRAITS constructor parameters is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Test    Example    \n---  di::inject  ---  Header  #include  boost/di.hpp   Description  di::inject  informs [Boost].DI about constructor parameters.\nIt's useful for generated/generic classes as it doesn't have constructor parameters size limitations.  Semantics  struct T {\n  using boost_di_inject__ = di::inject ... ;\n  T(...) {}\n};     Expression  Requirement  Description  Returns      ...  -  T  constructor parameters  -       Note  di::inject  has no limitations if it comes to constructor parameters, however,  named  parameters are not allowed.\nMoreover, you can replace  di::inject  with any variadic type list type to remove dependency to [Boost].DI.\nFor example,  template class...  struct type_list{};   using boost_di_inject__ = type_list ... ;   Test    Example    \n---  di::ctor_traits  ---  Header  #include  boost/di.hpp   Description  di::ctor_traits  is a trait in which constructor parameters for type  T  might be specified.\nIt's useful for third party classes you don't have access to and which can't be created using  automatic  injection.  Semantics  namespace boost {\nnamespace di {\n  template  \n  struct ctor_traits T  {\n    BOOST_DI_INJECT_TRAITS(...); // or using type = di::inject ... ;\n  };\n}}  Test   Example", 
            "title": "Injections"
        }, 
        {
            "location": "/user_guide/index.html#annotations", 
            "text": "Annotations are type properties specified in order to refer to a type by the name instead of the type it self.\nThey are useful when constructor has more than one parameter of the same type.\nFor example,  T(int, int) .  \n---  (named = name)  ---  Header  #include  boost/di.hpp   Description  Named parameters are handy to distinguish different constructor parameters of the same type.    T(int value1, int value2);  In order to inject proper values into  value1  and  value2  they have to be differentiate somehow.\n[Boost].DI solution for this problem are annotations.    Note \nAnnotations might be set only when constructor is marked using  BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS .  Semantics  auto Name = []{}; // just an object\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);\n};     Expression  Requirement  Description  Returns      Name  -  Object representing named type  -     Example  BOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);    Note \nImplementation of constructor doesn't require annotations, only constructor definition requires them.  Test      Example", 
            "title": "Annotations"
        }, 
        {
            "location": "/user_guide/index.html#scopes", 
            "text": "Header  #include  boost/di.hpp   Description  Scopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given,  deduce  scope will be assumed.  Semantics  template  class TExpected, class TGiven \nstruct scope {\n  template  class T \n  using is_referable;\n\n  template  class T, class TName, class TProvider \n  static auto try_create(const TProvider );\n\n  template  class T, class TName, class TProvider \n  auto create(const TProvider );\n};     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T        Type/Scope  unique  singleton  instance      T  \u2714  -  \u2714    T  -  \u2714  \u2714    const T  \u2714 (temporary)  \u2714  \u2714    T* (transfer ownership)  \u2714  -  -    const T*  \u2714  -  -    T  \u2714  -  \u2714    std::unique_ptr  \u2714  -  -    std::shared_ptr  \u2714  \u2714  \u2714    boost::shared_ptr  \u2714  \u2714  - / \u2714 converted to    std::weak_ptr  -  \u2714  - / \u2714 converted to     Test   Example       \n---  di::deduce (default)  ---  Header  #include  boost/di.hpp   Description  Default scope which will be converted to one of the scopes depending on the type.     Type  Scope      T  unique    T  singleton    const T  unique  (temporary) /  singleton    T*  unique  (ownership transfer)    const T*  unique  (ownership transfer)    T  unique    std::unique_ptr  unique    std::shared_ptr  singleton    boost::shared_ptr  singleton    std::weak_ptr  singleton     Semantics  namespace scopes {\n  struct deduce {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::deduce deduce;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test   Example     \n---  di::instance (di::bind .to(value))  ---  Header  #include  boost/di.hpp   Description  Scope representing values - passed externally. The life time of the object depends on the user.\n[Boost].DI is not maintaining the life time of these objects, however, values and strings will be copied and managed by the library.     Type  instance[in] ( bind .to(in) )  instance[out] ( injector.create out () )      T  \u2714  \u2714    T  \u2714  \u2714    const T  \u2714  \u2714    T*  -  -    const T*  -  -    T  \u2714  \u2714    std::unique_ptr  -  -    std::shared_ptr  \u2714  \u2714    boost::shared_ptr  -  \u2714    std::weak_ptr  -  \u2714     Semantics  namespace scopes {\n  struct instance {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test   Example     \n---  di::singleton  ---  Header  #include  boost/di.hpp   Description  Scope representing shared value between all instances as well as threads.\nSingleton scope will be deduced in case of reference,  std::shared_ptr ,  boost::shared_ptr  or  std::weak_ptr .    Note \nSingleton scope will convert automatically between  std::shared_ptr  and  boost::shared_ptr  if required.     Type  singleton      T  -    T  \u2714    const T  \u2714    T*  -    const T*  -    T  -    std::unique_ptr  -    std::shared_ptr  \u2714    boost::shared_ptr  \u2714    std::weak_ptr  \u2714     Semantics  namespace scopes {\n  struct singleton {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::singleton singleton;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test   Example     \n---  di::unique  ---  Header  #include  boost/di.hpp   Description  Scope representing unique/per request value. A new instance will be provided each time type will be requested.     Type  unique      T  \u2714    T  -    const T  \u2714 (temporary)    T*  \u2714 (ownership transfer)    const T*  \u2714 (ownership transfer)    T  \u2714    std::unique_ptr  \u2714    std::shared_ptr  \u2714    boost::shared_ptr  \u2714    std::weak_ptr  -     Semantics  namespace scopes {\n  struct unique {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::unique unique;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test   Example", 
            "title": "Scopes"
        }, 
        {
            "location": "/user_guide/index.html#modules", 
            "text": "Header  #include  boost/di.hpp   Description  Modules allow to split  bindings  configuration into smaller  injectors .\nModule might be installed by passing it into  make_injector .  Semantics  auto module = di::make_injector(...);\ndi::injector Ts...  module = di::make_injector(...);     Expression  Description  Note      auto module = di::make_injector(...)  All types are exposed from  module  module.create T ()  is allowed for any  T    di::injector Ts...  module = di::make_injector(...)  Only  Ts...  types are exposed from  module  module.create T ()  is allowed only for  T   =  Ts...     Test     Example    \n---  BOOST_DI_EXPOSE  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_EXPOSE is a macro definition allowing to expose  named  parameters via module/ injector .  Semantics  di::injector BOOST_DI_EXPOSE((named = Name) T), ... ;     Expression  Requirement  Description  Returns      Name  -  Named object  -    ...  -  More types to be exposed  -     Test    Example", 
            "title": "Modules"
        }, 
        {
            "location": "/user_guide/index.html#providers", 
            "text": "Header  #include  boost/di.hpp   Description  Providers are responsible for creating objects using given  Configuration .  Semantics  namespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}\n\nstruct config : di::config {\n  template class TInjector \n  static auto provider(const TInjector ) noexcept { return providers::stack_over_heap{}; }\n};     Expression  Requirement  Description  Returns      TInjector  -  injector  -    is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T       Note \nProvider used by  injector  might changed locally via  make_injector  or globally via  BOOST_DI_CFG .  Test   Example     \n---  di::providers::stack_over_heap (default)  ---  Header  #include  boost/di.hpp   Description  Creates objects on the stack whenever possible, otherwise on the heap.  Semantics  namespace providers {\n  class stack_over_heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T        Type  TMemory      T  stack    T  stack    const T  stack    T  stack    T*  heap    const T*  heap    std::unique_ptr  heap    std::shared_ptr  heap    std::weak_ptr  heap    boost::shared_ptr  heap    is_polymorphic T  heap     Test   Example     \n---  di::providers::heap  ---  Header  #include  boost/di.hpp   Description  Basic provider creates objects on the heap (always).  Semantics  namespace providers {\n  class heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T     Test   Example", 
            "title": "Providers"
        }, 
        {
            "location": "/user_guide/index.html#policies", 
            "text": "Header  #include  boost/di.hpp   Description  Policies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via  Configuration .    Note \nBy default [Boost].DI has NO policies enabled.  Semantics  template  class... TPolicies  requires callable TPolicies... \nauto make_policies(TPolicies...) noexcept;\n\nstruct config : di::config {\n  template class TInjector \n  static auto policies(const TInjector ) noexcept { return make_policies(...); }\n};                                                                        |\n                                                                          |\n// policy                                                                 /\ntemplate class T     -----------------------------------------------------\nvoid operator()(const T );     Expression  Requirement  Description  Returns      TInjector  -  injector  -    make_policies TPolicies...  callable TPolicies...>  Creates policies  callable  list        T  Description  Example      T::type  Type to be created  std::shared_ptr int    T::expected  Decayed 'Interface' type  interface    T::given  Decayed 'Given' type  implementatoin    T::name  Annotation name  my_name    T::arity  Number of constructor arguments  integral_constant int, 3    T::scope  scope  singleton    T::is_root  Is the root object (a type  create  was called with)  true_type / false_type       Note \nIn order for injector to verify policies they have to be created using  config  and passed via  TConfig  in  make_injector \nor set it globally via  BOOST_DI_CFG .  Test    Example      \n---  di::policies::constructible  ---  Header  #include  boost/di.hpp   Description  Constructible policy limits constructor parameters to explicitly allowed.    Note \nBy default constructible policy disables creation of any constructor parameters.  Semantics  namespace policies {\n  struct _ { }; // placeholder\n\n  constexpr auto include_root = true;\n\n  template class T \n  struct is_root; // true when is the root type (`create RooType ()`)\n\n  template class T \n  struct is_bound; // true when type is bound with 'di::bind T '\n\n  template  class T \n  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'\n\n  template bool IncludeRoot = false, class T \n  auto constructible(const T ) noexcept;\n}\n\nnamespace operators {\n  template class X \n  inline auto operator!(const X )\n\n  template class X, class Y \n  inline auto operator (const X , const Y );\n\n  template class X, class Y \n  inline auto operator||(const X , const Y );\n}     Expression  Requirement  Description  Returns      is_root T  -  Verify whether type  T  is a root type  true_type/false_type    is_bound T  -  Verify whether type  T  is bound  true_type/false_type    is_injected T  -  Verify whether type  T  is injected via  BOOST_DI_INJECT  true_type/false_type       Note \nIn order to allow logic operators using namespace  boost::di::policies::operators  has to be used.  Test      Note \nSTL type traits are supported and might be combined with [Boost].DI traits in order to limit constructor types\nFor example,  std::is_same _, int {} || std::is_constructible _, int, int {} || std::is_base_of int, _ {} , etc...  Example", 
            "title": "Policies"
        }, 
        {
            "location": "/user_guide/index.html#concepts", 
            "text": "Concepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.  \n---  di::concepts::boundable  ---  Header  #include  boost/di.hpp   Description  Bindings  type requirement.  Synopsis  template  class TExpected, class TGiven \nconcept bool boundable() {\n  return is_complete TExpected ()\n        is_complete TGiven ()\n        (is_base_of TExpected, TGiven () || is_convertible TGiven, TExpected ());\n}\n\ntemplate  class... Ts \nconcept bool boundable() {\n  return is_supported Ts ()...\n        is_movable Ts ()...\n        (is_base_of injector, Ts ()... || is_base_of dependency, Ts ()...);\n}  Semantics  boundable T \nboundable Ts...      Expression  Description  Returns      Ts...  Bindings to be verified  true_type if constraint is satisfied,  Error  otherwise     Example     Error  type T ::has_disallowed_qualifiers      Description  type  T  has disallowed qualifiers    Expression         Error  type T ::is_abstract      Description  type  T  is abstract    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0, 1 -  no additional info, 2 -  info about why type  T  is abstract    Expression         Error  type T ::is_not_related_to      Description  type  T  is not related to type  U    Expression         Error  type T ::is_bound_more_than_once      Description  type  T  is bound more than once    Expression         Error  type T ::is_neither_a_dependency_nor_an_injector      Description  type  T  is neither a dependency nor an injector    Expression       \n---  di::concepts::callable  ---  Header  #include  boost/di.hpp   Description  Policy  type requirement.  Synopsis  template  class T \nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}  Semantics  callable T   Example     Error  policy TPolicy ::requires_ call_operator      Description  policy  TPolicy  requires a call operator    Expression       \n---  di::concepts::configurable  ---  Header  #include  boost/di.hpp   Description  Configuration  type requirement.  Synopsis  template  class T \nconcept bool configurable() {\n  return requires(T object) {\n    return providable decltype(T::provider(...))    callable decltype(T::policies(...)) ();\n  }\n}  Semantics  configurable T   Example     Error  config TConfig ::requires_ provider providable_type (...)      Description  config  T  requires only providable and callable types    Expression       \n---  di::concepts::creatable  ---  Header  #include  boost/di.hpp   Description  Requirement for type  T  which is going to be created via  injector .create T ()  Synopsis  namespace type_traits {\n  template class T \n  using ctor_traits; // returns list of constructor parameters\n}\n\ntemplate  class T, class... TArgs \nconcept bool creatable() {\n  return is_constructible T, TArgs... ()  \n         is_constructible TArgs, type_traits::ctor_traits TArgs ... ();\n}  Semantics  creatable T, TArgs...   Example     Error  abstract_type T ::is_not_bound      Description  abstract type  T  is not bound    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'type is not bound, did you forget to add: 'di::bind .to ()'?'    Expression     Expression         Error  type T ::has_ambiguous_number_of_constructor_parameters::given Given ::expected Expected      Description  type  T  has ambiguous number of constructor parameters where  Given  were provided but  Expected  were expected    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'    Expression         Error  type T ::has_to_many_constructor_parameters::max Max      Description  type  T  has to many constructor parameter where maximum number is  Max    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'    Expression         Error  scoped TScope ::is_not_convertible_to T      Description  scope  TScope  is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind .in(scope)'?'    Expression         Error  scoped instance ::is_not_convertible_to T      Description  instance is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'instance is not convertible to the requested type, verify binding: 'di::bind .to(value)'?'    Expression        Note \nSuggestions are not supported/displayed by MSVC-2015.   \n---  di::concepts::providable  ---  Header  #include  boost/di.hpp   Description  Provider  type requirement.  Synopsis  namespace type_traits {\n  struct direct;\n  struct uniform;\n  struct stack;\n  struct heap;\n}\n\ntemplate  class T \nconcept bool providable() {\n  return requires(T object) {\n    { object.template get _ (type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n    { object.template is_creatable _ (type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n  }\n}  Semantics  providable T   Example     Error  provider TProvider ::requires_ get      Description  provider  TProvider  requires  get  method    Expression       \n---  di::concepts::scopable  ---  Header  #include  boost/di.hpp   Description  Scope  type requirement.  Synopsis  struct _ {}; // any type\n\ntemplate  class T \nconcept bool scopable() {\n  return requires(T) {\n    typename scope _, _ ::is_referable;\n    { T::scope _, _ {}.try_create() };\n    { T::scope _, _ {}.create() };\n  }\n}  Semantics  scopable T   Example     Error  scope TScope ::requires_ create      Description  scope  TScope  requires  create  method    Expression", 
            "title": "Concepts"
        }, 
        {
            "location": "/user_guide/index.html#configuration", 
            "text": "---  di::config  ---  Header  #include  boost/di.hpp   Description  Injector  configuration.  Synopsis  struct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};     Expression  Requirement  Description  Returns      provider()  providable  Creates provider  providable    policies()  callable  Creates policies  callable        Expression  Description      BOOST_DI_CFG  Global configuration allows to customize provider and policies     Semantics  di::make_injector config (...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)  Test   Example", 
            "title": "Configuration"
        }, 
        {
            "location": "/examples/index.html", 
            "text": "Hello World\n\n\nBindings\n\n\nDynamic Bindings\n\n\nForward Bindings\n\n\nMultiple Bindings\n\n\nBinding Non-owning Pointer\n\n\nBinding Templates\n\n\nAutomatic Injection\n\n\nConstructor Signature\n\n\nConstructor Injection\n\n\nMultiple Interface\n\n\nAnnotations\n\n\nDeduce Scope\n\n\nCustom Scope\n\n\nEager Singletons\n\n\nModules\n\n\nModules (hpp/cpp)\n\n\nCustom Policy\n\n\nCustom Provider\n\n\nPool Provider\n\n\nConfiguration\n\n\n\n\n\n\nHello World\n\n\n\n\nBindings\n\n\n\n\nDynamic Bindings\n\n\n\n\nForward Bindings\n\n\n\n\nMultiple Bindings\n\n\n\n\nBinding Non-owning Pointer\n\n\n\n\nBinding Templates\n\n\n\n\nAutomatic Injection\n\n\n\n\nConstructor Signature\n\n\n\n\nConstructor Injection\n\n\n\n\nMultiple Interface\n\n\n\n\nAnnotations\n\n\n\n\nDeduce Scope\n\n\n\n\nCustom Scope\n\n\n\n\nEager Singletons\n\n\n\n\nModules\n\n\n\n\nModules (hpp/cpp)\n\n\n\n\nSee \nhttps://github.com/boost-experimental/di/tree/cpp14/example/modules\n\n\n\n\nCustom Policy\n\n\n\n\nCustom Provider\n\n\n\n\nPool Provider\n\n\n\n\nConfiguration", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/index.html#hello-world", 
            "text": "", 
            "title": "Hello World"
        }, 
        {
            "location": "/examples/index.html#bindings", 
            "text": "", 
            "title": "Bindings"
        }, 
        {
            "location": "/examples/index.html#dynamic-bindings", 
            "text": "", 
            "title": "Dynamic Bindings"
        }, 
        {
            "location": "/examples/index.html#forward-bindings", 
            "text": "", 
            "title": "Forward Bindings"
        }, 
        {
            "location": "/examples/index.html#multiple-bindings", 
            "text": "", 
            "title": "Multiple Bindings"
        }, 
        {
            "location": "/examples/index.html#binding-non-owning-pointer", 
            "text": "", 
            "title": "Binding Non-owning Pointer"
        }, 
        {
            "location": "/examples/index.html#binding-templates", 
            "text": "", 
            "title": "Binding Templates"
        }, 
        {
            "location": "/examples/index.html#automatic-injection", 
            "text": "", 
            "title": "Automatic Injection"
        }, 
        {
            "location": "/examples/index.html#constructor-signature", 
            "text": "", 
            "title": "Constructor Signature"
        }, 
        {
            "location": "/examples/index.html#constructor-injection", 
            "text": "", 
            "title": "Constructor Injection"
        }, 
        {
            "location": "/examples/index.html#multiple-interface", 
            "text": "", 
            "title": "Multiple Interface"
        }, 
        {
            "location": "/examples/index.html#annotations", 
            "text": "", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/index.html#deduce-scope", 
            "text": "", 
            "title": "Deduce Scope"
        }, 
        {
            "location": "/examples/index.html#custom-scope", 
            "text": "", 
            "title": "Custom Scope"
        }, 
        {
            "location": "/examples/index.html#eager-singletons", 
            "text": "", 
            "title": "Eager Singletons"
        }, 
        {
            "location": "/examples/index.html#modules", 
            "text": "", 
            "title": "Modules"
        }, 
        {
            "location": "/examples/index.html#modules-hppcpp", 
            "text": "See  https://github.com/boost-experimental/di/tree/cpp14/example/modules", 
            "title": "Modules (hpp/cpp)"
        }, 
        {
            "location": "/examples/index.html#custom-policy", 
            "text": "", 
            "title": "Custom Policy"
        }, 
        {
            "location": "/examples/index.html#custom-provider", 
            "text": "", 
            "title": "Custom Provider"
        }, 
        {
            "location": "/examples/index.html#pool-provider", 
            "text": "", 
            "title": "Pool Provider"
        }, 
        {
            "location": "/examples/index.html#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/extensions/index.html", 
            "text": "Constructor Bindings\n\n\nContextual Bindings\n\n\nAssisted Injection\n\n\nExtensible Injector\n\n\nConcepts\n\n\nFactory\n\n\nShared Factory\n\n\nGenerics / Typed Erasure Interfaces\n\n\nLazy\n\n\nNamed Parameters\n\n\nXML Injection\n\n\nSerialize\n\n\nTypes Dumper\n\n\nUML Dumper\n\n\nMocks Provider\n\n\nScoped Scope\n\n\nSession Scope\n\n\nShared Scope\n\n\n\n\n\n\nConstructor Bindings\n\n\n\n\nContextual Bindings\n\n\n\n\nAssisted Injection\n\n\n\n\nExtensible Injector\n\n\n\n\nConcepts\n\n\n\n\nFactory\n\n\n\n\nShared Factory\n\n\n\n\nGenerics / Typed Erasure Interfaces\n\n\n\n\nLazy\n\n\n\n\nNamed Parameters\n\n\n\n\nXML Injection\n\n\n\n\nSerialize\n\n\n\n\nTypes Dumper\n\n\n\n\nUML Dumper\n\n\n\n\n\n\nMocks Provider\n\n\n\n\nScoped Scope\n\n\n\n\nSession Scope\n\n\n\n\nShared Scope", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/index.html#constructor-bindings", 
            "text": "", 
            "title": "Constructor Bindings"
        }, 
        {
            "location": "/extensions/index.html#contextual-bindings", 
            "text": "", 
            "title": "Contextual Bindings"
        }, 
        {
            "location": "/extensions/index.html#assisted-injection", 
            "text": "", 
            "title": "Assisted Injection"
        }, 
        {
            "location": "/extensions/index.html#extensible-injector", 
            "text": "", 
            "title": "Extensible Injector"
        }, 
        {
            "location": "/extensions/index.html#concepts", 
            "text": "", 
            "title": "Concepts"
        }, 
        {
            "location": "/extensions/index.html#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/extensions/index.html#shared-factory", 
            "text": "", 
            "title": "Shared Factory"
        }, 
        {
            "location": "/extensions/index.html#generics-typed-erasure-interfaces", 
            "text": "", 
            "title": "Generics / Typed Erasure Interfaces"
        }, 
        {
            "location": "/extensions/index.html#lazy", 
            "text": "", 
            "title": "Lazy"
        }, 
        {
            "location": "/extensions/index.html#named-parameters", 
            "text": "", 
            "title": "Named Parameters"
        }, 
        {
            "location": "/extensions/index.html#xml-injection", 
            "text": "", 
            "title": "XML Injection"
        }, 
        {
            "location": "/extensions/index.html#serialize", 
            "text": "", 
            "title": "Serialize"
        }, 
        {
            "location": "/extensions/index.html#types-dumper", 
            "text": "", 
            "title": "Types Dumper"
        }, 
        {
            "location": "/extensions/index.html#uml-dumper", 
            "text": "", 
            "title": "UML Dumper"
        }, 
        {
            "location": "/extensions/index.html#mocks-provider", 
            "text": "", 
            "title": "Mocks Provider"
        }, 
        {
            "location": "/extensions/index.html#scoped-scope", 
            "text": "", 
            "title": "Scoped Scope"
        }, 
        {
            "location": "/extensions/index.html#session-scope", 
            "text": "", 
            "title": "Session Scope"
        }, 
        {
            "location": "/extensions/index.html#shared-scope", 
            "text": "", 
            "title": "Shared Scope"
        }, 
        {
            "location": "/FAQ/index.html", 
            "text": "Dependency Inversion vs Dependency Injection\n\nIn principle Dependency Inversion might be implemented using DI or Service Locator (SL).\nThe latter is more like a 'God' object. It has a lot of benefits but, probably, the same\namount of cons such as that SL requires that SL will be the only constructor parameter for any class which can be created using it.\nDI, on the other hand, is less intrusive and easier to follow than SL.\n\n\n\n\n\n\n\n\n\n\nWhy C++14 is required for [Boost].DI?\n\nAt first [Boost].DI was implemented using C++03 standard with a switch to C++11 when available/possible.\nHowever, this approach, although was/is working just fine, was/is really slow to compile and hard to maintain too.\nMoreover, interface for \nmodules\n wasn't perfect due to missing return type deduction for functions in C++11.\nTherefore, I made a decision to reimplement the core using C++14 features which sped up compilation times dramatically\nand make the interface cleaner and easier to maintain. Nevertheless, effort was made to support the newest versions of\npopular C++ compilers including GCC/Clang and MSVC. If you are interested in C++03 version of the library, please, take\na look into \ncpp03\n branch. Please, also notice that this\nbranch is not maintained anymore.\n\n\n\n\n\n\n\n\n\n\nHow the constructor deduction works without reflection support in C++?\n\nPlease check out \ninjection\n design and http://boost-experimental.github.io/di/cppnow-2016/#/7/11.\n\n\n\n\n\n\n\n\n\n\nCan I inject templates/concepts?\n\nYes, concepts/templates can be injected.\n:w\n\n\n\n\ntemplate \nclass T = class Greater\n\nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind\nclass Greater\n().to\nhello\n()\n  );\n\n  auto object = injector.create\nexample\n();\n  static_assert(std::is_same\nhello, decltype(object)::type\n{});\n}\n\n\n\n\n\n\n\n\n\n\nCan I use XML in order to set-up bindings configuration?\n\nYes, however, XML injection is not part of the [Boost].DI release.\nPlease, check out \nXML Extension\n.\n\n\n\n\n\n\n\n\n\n\nSince [Boost].DI has a compile time approach can I have dynamic bindings?\n\nYes, [Boost].DI supports dynamic bindings.\n\n\n\n\nauto use_gui_view = true/false;\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n    if (use_gui_view)\n      return injector.template create\ngui_view\n();\n    else\n      return injector.template create\ntext_view\n();\n  })\n, di::bind\n.to(42) // renderer device\n);\n\n\n\n\nCheck out full example of \nDynamic Bindings\n.", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/index.html#dependency-inversion-vs-dependency-injection", 
            "text": "In principle Dependency Inversion might be implemented using DI or Service Locator (SL).\nThe latter is more like a 'God' object. It has a lot of benefits but, probably, the same\namount of cons such as that SL requires that SL will be the only constructor parameter for any class which can be created using it.\nDI, on the other hand, is less intrusive and easier to follow than SL.", 
            "title": "Dependency Inversion vs Dependency Injection"
        }, 
        {
            "location": "/FAQ/index.html#why-c14-is-required-for-boostdi", 
            "text": "At first [Boost].DI was implemented using C++03 standard with a switch to C++11 when available/possible.\nHowever, this approach, although was/is working just fine, was/is really slow to compile and hard to maintain too.\nMoreover, interface for  modules  wasn't perfect due to missing return type deduction for functions in C++11.\nTherefore, I made a decision to reimplement the core using C++14 features which sped up compilation times dramatically\nand make the interface cleaner and easier to maintain. Nevertheless, effort was made to support the newest versions of\npopular C++ compilers including GCC/Clang and MSVC. If you are interested in C++03 version of the library, please, take\na look into  cpp03  branch. Please, also notice that this\nbranch is not maintained anymore.", 
            "title": "Why C++14 is required for [Boost].DI?"
        }, 
        {
            "location": "/FAQ/index.html#how-the-constructor-deduction-works-without-reflection-support-in-c", 
            "text": "Please check out  injection  design and http://boost-experimental.github.io/di/cppnow-2016/#/7/11.", 
            "title": "How the constructor deduction works without reflection support in C++?"
        }, 
        {
            "location": "/FAQ/index.html#can-i-inject-templatesconcepts", 
            "text": "Yes, concepts/templates can be injected.\n:w   template  class T = class Greater \nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind class Greater ().to hello ()\n  );\n\n  auto object = injector.create example ();\n  static_assert(std::is_same hello, decltype(object)::type {});\n}", 
            "title": "Can I inject templates/concepts?"
        }, 
        {
            "location": "/FAQ/index.html#can-i-use-xml-in-order-to-set-up-bindings-configuration", 
            "text": "Yes, however, XML injection is not part of the [Boost].DI release.\nPlease, check out  XML Extension .", 
            "title": "Can I use XML in order to set-up bindings configuration?"
        }, 
        {
            "location": "/FAQ/index.html#since-boostdi-has-a-compile-time-approach-can-i-have-dynamic-bindings", 
            "text": "Yes, [Boost].DI supports dynamic bindings.   auto use_gui_view = true/false;\n\nauto injector = di::make_injector(\n  di::bind iview .to([ ](const auto  injector) -  iview  {\n    if (use_gui_view)\n      return injector.template create gui_view ();\n    else\n      return injector.template create text_view ();\n  })\n, di::bind .to(42) // renderer device\n);  Check out full example of  Dynamic Bindings .", 
            "title": "Since [Boost].DI has a compile time approach can I have dynamic bindings?"
        }, 
        {
            "location": "/CHANGELOG/index.html", 
            "text": "1.0.2\n - 2018-01-04\n\n\n\n\nAdditions\n\n\nSupport for Clang-4.0\n\n\nSupport for GCC-7\n\n\nSupport for MSVC-2017\n\n\nFixed support for MSVC-2015 Update 3\n\n\n\n\nCore\n\n\nSupport for injecting\ntemplates/concepts\n\n\n\n\n\n\n\n\nExtensions\n\n\nExtensions are now available using header\nfiles\n\n\nExtensible Injector\n\n\nShared Factory\n\n\n\n\n\n\n\n\n\n\n\n\nBug Fixes\n\n\nImplementation class cannot be marked as \nfinal\n\n\nCreation with Factory doesn't allow to pass exceptions through\n\n\nBound policy doesn't work with multiple bindings\n\n\nProblems compiling with _GLIBCXX_DEBUG defined\n\n\nException in ctor not propagated\n\n\nUnable to compile with VS 2017 RC, VS 2015 works fine\n\n\nBroken under VS2015 Update 3\n\n\n\n\n\n\n\n\nContributions\n\n\nKanstantsin Chernik\n\n\n\n\n\n\n\n\n1.0.1\n - 2016-05-04\n\n\n\n\nBreaking Changes\n\n\nSimplified interface for policies\n\n\n\n\n\n\n\n\nAdditions\n\n\nSupport for Clang-3.9\n\n\nSupport for GCC-6\n\n\n\n\nExtensions\n\n\nContextual Bindings\n\n\nSerialize\n\n\n\n\n\n\n\n\n\n\n\n\nBug Fixes\n\n\nLink error if di.hpp is included in two cpp-files\n\n\nCreation of empty injector crashes on MSVC 2015, Update 1, x64, Debug\n\n\n\n\n\n\n\n\n1.0.0\n - 2016-02-22\n\n\n\n\nSupport for MSVC-2015+\n\n\nSupport for GCC-5+\n\n\nSupport for CMake 2.8+\n\n\nSupport for libc++, libstdc++\n\n\nSupport for Mac OS\n\n\n\n\n0.5.0\n - 2015-01-12\n\n\n\n\nC++14 version\n\n\nSupport for Clang3.4+\n\n\n\n\n0.1.0\n - 2014-08-15\n\n\n\n\nC++03/C++11 version\n\n\nSupport for Clang3.2+", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/index.html#102-2018-01-04", 
            "text": "Additions  Support for Clang-4.0  Support for GCC-7  Support for MSVC-2017  Fixed support for MSVC-2015 Update 3   Core  Support for injecting\ntemplates/concepts     Extensions  Extensions are now available using header\nfiles  Extensible Injector  Shared Factory       Bug Fixes  Implementation class cannot be marked as  final  Creation with Factory doesn't allow to pass exceptions through  Bound policy doesn't work with multiple bindings  Problems compiling with _GLIBCXX_DEBUG defined  Exception in ctor not propagated  Unable to compile with VS 2017 RC, VS 2015 works fine  Broken under VS2015 Update 3     Contributions  Kanstantsin Chernik", 
            "title": "1.0.2 - 2018-01-04"
        }, 
        {
            "location": "/CHANGELOG/index.html#101-2016-05-04", 
            "text": "Breaking Changes  Simplified interface for policies     Additions  Support for Clang-3.9  Support for GCC-6   Extensions  Contextual Bindings  Serialize       Bug Fixes  Link error if di.hpp is included in two cpp-files  Creation of empty injector crashes on MSVC 2015, Update 1, x64, Debug", 
            "title": "1.0.1 - 2016-05-04"
        }, 
        {
            "location": "/CHANGELOG/index.html#100-2016-02-22", 
            "text": "Support for MSVC-2015+  Support for GCC-5+  Support for CMake 2.8+  Support for libc++, libstdc++  Support for Mac OS", 
            "title": "1.0.0 - 2016-02-22"
        }, 
        {
            "location": "/CHANGELOG/index.html#050-2015-01-12", 
            "text": "C++14 version  Support for Clang3.4+", 
            "title": "0.5.0 - 2015-01-12"
        }, 
        {
            "location": "/CHANGELOG/index.html#010-2014-08-15", 
            "text": "C++03/C++11 version  Support for Clang3.2+", 
            "title": "0.1.0 - 2014-08-15"
        }
    ]
}