<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<meta name="author" content="Krzysztof Jusiak">
<link rel="canonical" href="http://boost-experimental.github.io/di/tutorial/index.html">
<title>Tutorial - Boost.DI</title>

<link href="../css/boostbook.css" rel="stylesheet">
<link href="../css/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div width="100%">
<a href="http://www.boost.org/"><img alt="Boost C++ Libraries" width="277" height="86" src="../images/boost.png"></a>
</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../overview/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../user_guide/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="#0-pre-refactor-towards-di">0. [Pre] Refactor towards DI</a></span></dt>
    

    
        <dt><span class="section"><a href="#1-basic-create-objects-tree">1. [Basic] Create objects tree</a></span></dt>
    

    
        <dt><span class="section"><a href="#2-basic-first-steps-with-bindings">2. [Basic] First steps with bindings</a></span></dt>
    

    
        <dt><span class="section"><a href="#3-basic-decide-the-life-times">3. [Basic] Decide the life times</a></span></dt>
    

    
        <dt><span class="section"><a href="#4-basic-annotations-to-the-rescue">4. [Basic] Annotations to the rescue</a></span></dt>
    

    
        <dt><span class="section"><a href="#5-basic-split-your-configuration">5. [Basic] Split your configuration</a></span></dt>
    

    
        <dt><span class="section"><a href="#6-advanced-dumplimit-your-types">6. [Advanced] Dump/Limit your types</a></span></dt>
    

    
        <dt><span class="section"><a href="#7-advanced-customize-it">7. [Advanced] Customize it</a></span></dt>
    

    
        <dt><span class="section"><a href="#8-advanced-extend-it">8. [Advanced] Extend it</a></span></dt>
    

</dl>
</div>



<div class="section">
<h3 id="0-pre-refactor-towards-di">0. [Pre] Refactor towards DI</h3>
<p>If you write a new application you can skip this step and go directly to <a href="#1-basic-create-objects-tree">step 1</a>.
However, if you have a lot code which is not using DI and you wonder what can it be refactored,
then you are in the right place.</p>
<p>Basically, there is a only one (big) step to get all benefits of Dependency Injection.
You have to separate creation logic from business logic, which means that your code
should be free of object creation inside other objects...</p>
<pre><code class="cpp">class controller {
public:
  controller() : model_(new model{}) {}
  ~controller() { delete model_; }
  void run();

private:
  model* model_;
};

int main() {
  controller controller_;
  controller_.run();
}
</code></pre>

<p>Instead, DI approach would look like that...</p>
<pre><code class="cpp">class controller {
public:
  explicit controller(model&amp; m) : model_(m) {}
  void run();

private:
  model&amp; model_;
};

int main() {
  model model_;
  controller controller_{model_};
  controller_.run();
}
</code></pre>

<p>So, what happened here? We just took the responsibility of creation <code>model</code> out from the <code>controller</code>. In other words,
we have split the creation logic and the business logic.</p>
<p>That's basically everything you have to remember in order to create applications using DI.
Nevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,
is NOT to pass an object into constructor if it won't be stored (<a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a>).</p>
<pre><code class="cpp">class app {
public:
  explicit app(model&amp; m) : controller_(m) {} // BAD
  explicit app(controller&amp; c) : controller_(c) {} // GOOD

private:
  controller controller_;
};
class controller {
public:
  explicit controller(model&amp;);
};

int main() {
  model model_;
  app app_{model_};
}
</code></pre>

<h3 id="1-basic-create-objects-tree">1. [Basic] Create objects tree</h3>
<p>Before we will get into creating objects tree, let's first create a 'dummy' example.
In order to do so, firstly, we have to include (one and only) <code>boost/di.hpp</code> header and
declare a convenient <code>di</code> namespace alias.</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;
namespace di = boost::di;
</code></pre>

<p>That is enough to try out <code>Boost.DI</code>!</p>
<p>To have a first complete and working example we just have to add <code>main</code> function as usual.</p>
<pre><code class="cpp">int main() {}
</code></pre>

<p>and compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).</p>
<pre><code>$CXX -std=c++14 example.cpp
</code></pre>

<p>Congrats, you are now ready to check out <code>Boost.DI</code> features!</p>
<hr />
<p>Let's move on to creating objects tree. Applications, usually, consists of a number of objects
which have to be instantiated. For example, let's consider a simplified Model View Controller code...</p>
<p><a href="../images/tutorial_create_objects_tree.png"><img alt="Create objects tree" src="../images/tutorial_create_objects_tree.png" /></a></p>
<p>The usual approach to create <code>app</code> would be following...</p>
<pre><code class="cpp">renderer renderer_;
view view_{&quot;&quot;, renderer_};
model model_;
controller controller_{model_, view_};
user user_;
app app_{controller_, user_};
</code></pre>

<p>Which is alright for a really small applications. However, it's really tedious to maintain.
Just imagine, that we have to change something here. For instance, <code>view</code> may need a new object <code>window</code>
or, even worse, we refactored the code and dependencies order has changed - yea <strong>ORDER</strong> of above is important!
<strong>ANY</strong> change in these classes constructors require developer input to maintain above boilerplate code!
Not fun, not fun at all :(</p>
<p>Right now imagine that your maintain effort will be minimized almost to none. How does it sound?
Well, that might be simply achieved with <code>Boost.DI</code>!</p>
<p>The same result might be achieved with one liner. Doesn't matter how big the hierarchy will be.
We just have to create <a href="../user_guide/index.html#di_make_injector">injector</a> using <a href="../user_guide/index.html#make_injector">make_injector</a> and create the <code>app</code>.</p>
<pre><code class="cpp">auto app_{make_injector().create&lt;app&gt;()};
</code></pre>

<p>Moreover, changes in the constructor of created objects will be handled automatically, so in our case
when we add a <code>window</code> to <code>view</code> or change <code>view&amp;</code> to <code>std::shared_ptr&lt;view&gt;</code> required effort will be
exactly '0'. <code>Boost.DI</code> will take care of everything for us!</p>
<table>
<thead>
<tr>
<th>Type <code>T</code></th>
<th>Is allowed?</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>T*</code></td>
<td>✔</td>
<td>Ownership transfer!</td>
</tr>
<tr>
<td><code>const T*</code></td>
<td>✔</td>
<td>Ownership transfer!</td>
</tr>
<tr>
<td><code>T&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>const T&amp;</code></td>
<td>✔</td>
<td>Reference with <a href="../user_guide/index.html#di_singleton">singleton</a> / Temporary with <a href="../user_guide/index.html#di_unique">unique</a></td>
</tr>
<tr>
<td><code>T&amp;&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::unique_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::weak_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>boost_shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Furthermore, there is no performance penalty for using <code>Boost.DI</code> (see <a href="../overview/index.html#performance">Performance</a>)!</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Boost.DI can <a href="../user_guide/index.html#di_automatic">inject</a> dependencies using direct initialization <code>T(...)</code> or uniform initialization <code>T{...}</code> for aggregate types.
</span></p>
<p>Check it out yourself!</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

struct renderer {
  int device;
};

class view {
 public:
  view(std::string /*title*/, const renderer&amp;) {}
};

class model {};

class controller {
 public:
  controller(model&amp;, view&amp;) {}
};

class user {};

class app {
 public:
  app(controller&amp;, user&amp;) {}
};

int main() {
  /**
   * renderer renderer_;
   * view view_{&quot;&quot;, renderer_};
   * model model_;
   * controller controller_{model_, view_};
   * user user_;
   * app app_{controller_, user_};
   */

  auto injector = di::make_injector();
  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp</a></li>
</ul>
<p>Check out also other examples. Please, notice that the diagram was also generated using <code>Boost.DI</code> but we will get into that a bit later.</p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/hello_world.cpp"> Hello World Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp"> Automatic Injection Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp"> UML Dumper Extension</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="2-basic-first-steps-with-bindings">2. [Basic] First steps with bindings</h3>
<p>But objects tree is not everything. A lot of classes uses interfaces or required a value to be passed.
<code>Boost.DI</code> solution for this are <a href="../user_guide/index.html#bindings">bindings</a>.</p>
<p>For purpose of this tutorial, let's change <code>view</code> class into interface <code>iview</code> in order to support <code>text_view</code> and <code>gui_view</code>.</p>
<pre><code class="cpp">class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};

class gui_view: public iview {
public:
  gui_view(std::string title, const renderer&amp;) {}
  void update() override {}
};

class text_view: public iview {
public:
  void update() override {}
};
</code></pre>

<p>Please, notice that <code>text_view</code> doesn't require any constructor parameters, whilst <code>gui_view</code> does.</p>
<p>So, what will happen right now, when we try to create an <code>app</code>?</p>
<pre><code class="cpp">auto app_{make_injector().create&lt;app&gt;()};
</code></pre>

<p>COMPILE error! (See also: <a href="../overview/index.html#error-messages">Error Messages</a>)</p>
<pre><code class="cpp">warning: 'create&lt;app&gt;' is deprecated: creatable constraint not satisfied
  injector.create&lt;app&gt;();
           ^
boost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type&lt;iview&gt;::is_not_bound::error'
  error(_ = &quot;type is not bound, did you forget to add: 'di::bind&lt;interface&gt;.to&lt;implementation&gt;()'?&quot;);
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
You can get more info about error by increasing <a href="../overview/index.html#configuration">BOOST_DI_CFG_DIAGNOSTICS_LEVEL</a> [0-2] value (default=1).
</span></p>
<p>Ah, okay, we haven't bound <code>iview</code> which means that <code>BOOST.DI</code> can't figure out whether we want <code>text_view</code> or <code>gui_view</code>?
Well, it's really simple to fix it, we just follow suggestion provided.</p>
<pre><code class="cpp">auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;()
);
</code></pre>

<p>Let's try again. Yay! It's compiling.</p>
<p>But what about values? <code>renderer</code> requires <code>device</code>, which, by default, was value initialized.</p>
<pre><code class="cpp">struct renderer {
  int device;
};
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
If you want change the default behaviour and be sure that all required dependencies are bound and not value initialized
take a look at <a href="../user_guide/index.html#di_constructible">constructible</a> policy.
</span></p>
<pre><code class="cpp">auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;()
, di::bind&lt;int&gt;.to(42) // renderer device | Boost.DI can also deduce 'int' type for you -&gt; 'di::bind&lt;&gt;.to(42)'
);
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Boost.DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved
correctly. No runtime exceptions or runtime asserts, EVER!
</span></p>
<p>Check it out yourself!</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;


class iview {
 public:
  virtual ~iview() noexcept = default;
  virtual void update() = 0;
};

class gui_view : public iview {
 public:
  gui_view(std::string /*title*/, const renderer&amp; r) { assert(42 == r.device); }
  void update() override {}
};

class text_view : public iview {
 public:
  void update() override {}
};


class controller {
 public:
  controller(model&amp;, iview&amp;) {}
};


int main() {
  auto injector = di::make_injector(
    di::bind&lt;iview&gt;().to&lt;gui_view&gt;()
  , di::bind&lt;int&gt;().to(42) // renderer device
  );

  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings.cpp</a></li>
</ul>
<p>Great, but my code is more dynamic than that! I mean that I want to choose <code>gui_view</code> or <code>text_view</code> at runtime.
<code>Boost.DI</code> can handle that too!</p>
<pre><code class="cpp">auto use_gui_view = ...;

auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
    if (use_gui_view)
      return injector.template create&lt;gui_view&amp;&gt;();
    else
      return injector.template create&lt;text_view&amp;&gt;();
  })
, di::bind&lt;&gt;.to(42) // renderer device
);
</code></pre>

<p>Notice, that <a href="../user_guide/index.html#di_make_injector">injector</a> was passed to lambda expression in order to create <code>gui_view</code> / <code>text_view</code>.
This way <code>Boost.DI</code> can inject appropriate dependencies into chosen types. See <a href="../user_guide/index.html#bindings">bindings</a> for more details.</p>
<p>Check it out yourself!</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;


class user {};

class app {
 public:
  app(controller&amp;, user&amp;) {}
};

int main() {
  auto use_gui_view = true;

  auto injector = di::make_injector(
    di::bind&lt;iview&gt;().to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;int&gt;().to(42) // renderer device
  );

  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_dynamic_bindings.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_dynamic_bindings.cpp</a></li>
</ul>
<p>Okay, so what about the input. We have <code>user</code>, however, in the real life, we will have more clients.
<code>Boost.DI</code> allows multiple bindings to the same type for <code>array/vector/set</code>. Let's do it then!</p>
<pre><code class="cpp">class iclient {
 public:
   virtual ~iclient() noexcept = default;
   virtual void process() = 0;
};

class user : public iclient {
 public:
   void process() override {};
};

class timer : public iclient {
 public:
   void process() override {};
};

class app {
 public:
  app(controller&amp;, std::vector&lt;std::unique_ptr&lt;iclient&gt;&gt;);
};
</code></pre>

<p>And our bindings...</p>
<pre><code class="cpp">di::bind&lt;iclient*[]&gt;.to&lt;user, client&gt;()
</code></pre>

<p>Check it out yourself!</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;


class user : public iclient {
 public:
  void process() override{};
};

class timer : public iclient {
 public:
  void process() override{};
};

class app {
 public:
  app(controller&amp;, std::vector&lt;std::unique_ptr&lt;iclient&gt;&gt; v) {
    assert(2 == v.size());
    assert(dynamic_cast&lt;user*&gt;(v[0].get()));
    assert(dynamic_cast&lt;timer*&gt;(v[1].get()));
  }
};

int main() {
  auto use_gui_view = true;

  auto injector = di::make_injector(
    di::bind&lt;iview&gt;().to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;int&gt;().to(42) // renderer device
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  );

  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_multiple_bindings.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_multiple_bindings.cpp</a></li>
</ul>
<p>The last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.
With <code>Boost.DI</code> you can easily do that with <a href="../user_guide/index.html#di_bind">override</a> specifier.</p>
<pre><code class="cpp">auto injector = di::make_injector(
  di::bind&lt;int&gt;.to(42) // renderer device
, di::bind&lt;int&gt;.to(123) [di::override] // override renderer device
);
</code></pre>

<p>Without the <code>di::override</code> following compilation error will occur...</p>
<pre><code class="cpp">boost/di.hpp:281:3: error: static_assert failed &quot;constraint not satisfied&quot;
boost/di.hpp:2683:80: type&lt;int&gt;::is_bound_more_than_once
  inline auto make_injector(TDeps... args) noexcept
</code></pre>

<p>And full example!</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;


int main() {
  auto use_gui_view = true;

  auto injector = di::make_injector(
    di::bind&lt;iview&gt;().to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  , di::bind&lt;int&gt;().to(42) // renderer device
  , di::bind&lt;int&gt;().to(123) [di::override] // override renderer device
  );

  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings_override.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings_override.cpp</a></li>
</ul>
<p>Check out also.</p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp"> Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp"> Forward Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp"> Dynamic Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp"> Multiple Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/bindings/constructor_bindings.cpp"> Constructor Bindings Extension</a></li>
</ul>
<p><br /><br /><br /><hr /></p>
<h3 id="3-basic-decide-the-life-times">3. [Basic] Decide the life times</h3>
<p>So far so good but where these objects are stored?
Well, <code>Boost.DI</code> supports <a href="../user_guide/index.html#scopes">scopes</a> which are response for maintaining the life time of created objects.
By default there are 4 scopes</p>
<ul>
<li><a href="../user_guide/index.html#di_deduce">deduce</a> scope (default)</li>
<li><a href="../user_guide/index.html#di_instance">instance</a> scope (bind&lt;&gt;.to(value) where value is maintained by the user)</li>
<li><a href="../user_guide/index.html#di_unique">unique</a> scope (one instance per request)</li>
<li><a href="../user_guide/index.html#di_singleton">singleton</a> scope (shared instance)</li>
</ul>
<p>By default <a href="../user_guide/index.html#di_deduce">deduce</a> scope is used which means that scope is deduced based on a constructor parameter.
For instance, reference, shared_ptr will be deduced as <a href="../user_guide/index.html#di_singleton">singleton</a> scope and pointer, unique_ptr will be deduced as <a href="../user_guide/index.html#di_unique">unique</a> scope.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td><a href="../user_guide/index.html#di_unique">unique</a></td>
</tr>
<tr>
<td>T&amp;</td>
<td><a href="../user_guide/index.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>const T&amp;</td>
<td><a href="../user_guide/index.html#di_unique">unique</a> (temporary) / <a href="../user_guide/index.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>T*</td>
<td><a href="../user_guide/index.html#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>const T*</td>
<td><a href="../user_guide/index.html#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td><a href="../user_guide/index.html#di_unique">unique</a></td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td><a href="../user_guide/index.html#di_unique">unique</a></td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td><a href="../user_guide/index.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td><a href="../user_guide/index.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td><a href="../user_guide/index.html#di_singleton">singleton</a></td>
</tr>
</tbody>
</table>
<p>Coming back to our example, we got quite a lot <code>singletons</code> there as we just needed one instance per application life time.
Although scope deduction is very useful, it's not always what we need and therefore <code>Boost.DI</code> allows changing the scope for given type.</p>
<pre><code class="cpp">auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;().in(di::singleton) // explicitly specify singleton scope
);
</code></pre>

<p>What if I want to change <code>gui_view</code> to be a different instance per each request. Let's change the scope to <a href="../user_guide/index.html#di_unique">unique</a> then.</p>
<pre><code class="cpp">auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;().in(di::unique)
);
</code></pre>

<p>It's NOT compiling!</p>
<pre><code class="cpp">warning: 'create&lt;app&gt;' is deprecated: creatable constraint not satisfied
  injector.create&lt;app&gt;();
           ^
boost/di.hpp:897:2: error: 'scoped&lt;scopes::unique, gui_view&gt;::is_not_convertible_to&lt;iview &amp;&gt;::error'
  error(_ = &quot;scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind&lt;T&gt;.in(scope)'?&quot;);
</code></pre>

<p>Ah, reference doesn't make much sense with <a href="../user_guide/index.html#di_unique">unique</a> scope because it would mean that it has to be stored somewhere.
It would be better to use <code>std::unique_ptr&lt;iview&gt;</code> instead.</p>
<table>
<thead>
<tr>
<th>Type/Scope</th>
<th><a href="../user_guide/index.html#di_unique">unique</a></th>
<th><a href="../user_guide/index.html#di_singleton">singleton</a></th>
<th><a href="../user_guide/index.html#di_instance">instance</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>T* (transfer ownership)</td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>const T*</td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
<td>- / ✔ converted to</td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td>-</td>
<td>✔</td>
<td>- / ✔ converted to</td>
</tr>
</tbody>
</table>
<p>Hmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to
use <code>std::shared_ptr</code> instead.</p>
<pre><code class="cpp">class app {
 public:
  app(controller&amp;, std::vector&lt;std::shared_ptr&lt;iclient&gt;&gt;);
};
</code></pre>

<p>But, it would be better if <code>timer</code> was always created per request, although it's a <code>shared_ptr</code>.
To do so, we just need add scope when binding it, like this...</p>
<pre><code class="cpp">auto injector = di::make_injector(
  di::bind&lt;timer&gt;.in(di::unique) // different per request
);
</code></pre>

<p>Check out full example here.</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;


int main() {
  auto use_gui_view = true;

  auto injector = di::make_injector(
    di::bind&lt;iview&gt;().to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;().in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  , di::bind&lt;int&gt;().to(42) // renderer device
  , di::bind&lt;int&gt;().to(123) [di::override] // override renderer device
  );

  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_decide_the_life_times.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_decide_the_life_times.cpp</a></li>
</ul>
<p>See also.</p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp"> Deduce Scope Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp"> Scopes Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp"> Eager Singletons Example</a></li>
</ul>
<p><br /><br /><hr /></p>
<h3 id="4-basic-annotations-to-the-rescue">4. [Basic] Annotations to the rescue</h3>
<p>Above example are fine and dandy, nonetheless, they don't cover one important thing.
How <code>Boost.DI</code> knows which constructor to choose and what if they are ambiguous?</p>
<p>Well, algorithm is very simple. The longest (most parameters), unique constructor will be chosen.
Otherwise, <code>Boost.DI</code> will give up with compile time error. However, which constructor should
be chosen is configurable by <a href="../user_guide/index.html#BOOST_DI_INJECT">BOOST_DI_INJECT</a>.</p>
<p>To illustrate this, let modify <code>model</code> constructor.</p>
<pre><code class="cpp">class model {
 public:
   model(int size, double precision) { }
   model(int rows, int cols) { }
};
</code></pre>

<p>Right now, as expected, we get a compile time error!</p>
<pre><code class="cpp">warning: 'create&lt;app&gt;' is deprecated: creatable constraint not satisfied
  injector.create&lt;app&gt;();
           ^
boost/di.hpp:942:4: error: 'type&lt;model&gt;::has_ambiguous_number_of_constructor_parameters::error'
  error(_ = &quot;verify BOOST_DI_INJECT_TRAITS or di::ctor_traits&quot;);
</code></pre>

<p>Let's fixed it using <a href="../user_guide/index.html#BOOST_DI_INJECT">BOOST_DI_INJECT</a> then!</p>
<pre><code class="cpp">class model {
 public:
   model(int size, double precision) { }
   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected
};
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
We can also write <code>model(int rows, int cols, ...)</code> to get the same result.
</span></p>
<p>Okay, right now it compiles but, wait a minute, <code>123</code> (renderer device) was injected for both <code>rows</code> and <code>cols</code>!
Well, it wasn't even closed to what we would like to, but we can fix it easily using <a href="../user_guide/index.html#di_named">named</a> annotations.</p>
<p>Firstly, we have to create names. That's easy as names are just unique objects.</p>
<pre><code class="cpp">auto Rows = []{};
auto Cols = []{};
</code></pre>

<p>Secondly, we have to tell <code>model</code> constructor about it.</p>
<pre><code class="cpp">class model {
 public:
   model(int size, double precision) { }
   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected
};

model::model(int rows, int cols) {}
</code></pre>

<p>Please, notice that we have separated <code>model</code> constructor definition and declaration to show that definition doesn't
require named annotations.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
If you happen to use clang/gcc compiler you can use string literals instead of creating objects,
for example <code>(named = "Rows"_s)</code>.
</span></p>
<p>Finally, we have to bind our values.</p>
<pre><code class="cpp">auto injector = di::make_injector(
  di::bind&lt;int&gt;.named(Rows).to(6)
, di::bind&lt;int&gt;.named(Cols).to(8)
);
</code></pre>

<p>That's all.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
The same result might be accomplished with having different types for rows and cols.
</span></p>
<p>Full example here.</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

auto Rows = [] {};
auto Cols = [] {};


class model {
 public:
  model(int /*size*/, double /*precision*/) {}
  BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols);
};

model::model(int rows, int cols) {
  assert(6 == rows);
  assert(8 == cols);
}


int main() {
  auto use_gui_view = true;

  auto injector = di::make_injector(
    di::bind&lt;iview&gt;().to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;().in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  , di::bind&lt;int&gt;().to(42) // renderer device
  , di::bind&lt;int&gt;().to(123) [di::override] // override renderer device
  , di::bind&lt;int&gt;().named(Rows).to(6)
  , di::bind&lt;int&gt;().named(Cols).to(8)
  );

  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_annotations_to_the_rescue.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_annotations_to_the_rescue.cpp</a></li>
</ul>
<p>Check out also.</p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp"> Constructor Injection Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp"> Constructor Signature Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp"> Annotations Example</a></li>
</ul>
<p><br /><br /><hr /></p>
<h3 id="5-basic-split-your-configuration">5. [Basic] Split your configuration</h3>
<p>But my project has hundreds of interfaces and I would like to split my bindings into separate components.
There is nothing simpler than that with <code>Boost.DI</code> as <a href="../user_guide/index.html#di_make_injector">injector</a> might be extended by other <a href="../user_guide/index.html#di_make_injector">injector</a>.</p>
<p>Let's split our configuration then and keep our <code>model</code> bindings separately from <code>app</code> bindings.</p>
<pre><code class="cpp">auto model_module = [] {
  return di::make_injector(
    di::bind&lt;int&gt;.named(Rows).to(6)
  , di::bind&lt;int&gt;.named(Cols).to(8)
  );
};

auto app_module = [](const bool&amp; use_gui_view) {
  return di::make_injector(
    di::bind&lt;iview&gt;.to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;.in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  );
};
</code></pre>

<p>And glue them into one injector the same way...</p>
<pre><code class="cpp">  auto injector = di::make_injector(
    model_module()
  , app_module(use_gui_view)
  );
</code></pre>

<p>Check it out yourself!</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;


auto model_module = [] {
  return di::make_injector(
    di::bind&lt;int&gt;().named(Rows).to(6)
  , di::bind&lt;int&gt;().named(Cols).to(8)
  );
};

auto app_module = [](const bool&amp; use_gui_view) {
  return di::make_injector(
    di::bind&lt;iview&gt;().to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;().in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  , di::bind&lt;int&gt;().to(42) // renderer device
  , di::bind&lt;int&gt;().to(123) [di::override] // override renderer device
  );
};

int main() {
  auto use_gui_view = true;

  auto injector = di::make_injector(
    model_module()
  , app_module(use_gui_view)
  );

  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration.cpp</a></li>
</ul>
<p>But I would like to have a module in <code>cpp</code> file, how can I do that?
Such design might be achieved with <code>Boost.DI</code> using <a href="../user_guide/index.html#di_make_injector">injector</a> and exposing given types.
Let's refactor it then.</p>
<pre><code class="cpp">di::injector&lt;model&amp;&gt; model_module() {
  return di::make_injector(
    di::bind&lt;int&gt;.named(Rows).to(6)
  , di::bind&lt;int&gt;.named(Cols).to(8)
  );
}

di::injector&lt;app&gt; app_module(const bool&amp; use_gui_view) {
  return di::make_injector(
    di::bind&lt;iview&gt;.to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;.in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;.to&lt;user, timer&gt;() // bind many clients
  , model_module()
  );
}
</code></pre>

<p>Right now you can easily separate definition and declaration between <code>hpp</code> and <code>cpp</code> files.</p>
<p>Check it out here!</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

auto Rows = [] {};
auto Cols = [] {};


di::injector&lt;model&amp;&gt; model_module() {
  return di::make_injector(
    di::bind&lt;int&gt;().named(Rows).to(6)
  , di::bind&lt;int&gt;().named(Cols).to(8)
  );
}

di::injector&lt;app&gt; app_module(const bool&amp; use_gui_view) {
  return di::make_injector(
    di::bind&lt;iview&gt;().to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;().in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  , di::bind&lt;int&gt;().to(42) // renderer device
  , di::bind&lt;int&gt;().to(123) [di::override] // override renderer device
  , model_module()
  );
}

int main() {
  auto use_gui_view = true;
  auto injector = app_module(use_gui_view);
  injector.create&lt;app&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration_expose.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration_expose.cpp</a></li>
</ul>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
You can also expose named parameters using <code>di::injector&lt;BOOST_DI_EXPOSE((named = Rows) int)&gt;</code>.
Different variations of the same type have to be exposed explicitly using <code>di::injector&lt;model&amp;, std::unique_ptr&lt;model&gt;&gt;</code>.
Expose uses type erasure and therefore it has small performance overhead!
</span></p>
<p>More examples.</p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp"> Modules Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_annotated_type.cpp"> Exposed Annotated Type Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_complex_types.cpp"> Exposed Complex Types Example</a></li>
</ul>
<p><br /><br /></p>
<p>Congrats! You have finished the basic part of the tutorial.
Hopefully, you have noticed potential of DI and <code>Boost.DI</code> but if are still not convinced check out the <a href="#6-advanced-dumplimit-your-types">Advanced</a> part.</p>
<h3 id="6-advanced-dumplimit-your-types">6. [Advanced] Dump/Limit your types</h3>
<p>It's often a case that we would like to generate object diagram of our application in order to see code dependencies
more clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,
if the responsibility for creation  objects will be given to <code>Boost.DI</code> we get such functionality for free.
The only thing we have to do is to implement how to dump our objects.</p>
<p>Let's dump our dependencies using <a href="http://plantuml.com">Plant UML</a> format.</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;


/**
 * http://plantuml.sourceforge.net/objects.html
 * ./uml_dumper | java -jar plantuml.jar -p &gt; uml_dumper.png
 */
class uml_dumper : public di::config {
 public:
  uml_dumper() { std::cout &lt;&lt; &quot;@startuml uml_dumper.png&quot; &lt;&lt; std::endl; }
  ~uml_dumper() { std::cout &lt;&lt; &quot;@enduml&quot; &lt;&lt; std::endl; }

  static auto policies(...) noexcept {
    /*&lt;&lt;define `uml dumper` directly in policies configuration&gt;&gt;*/
    return di::make_policies([&amp;](auto type, auto dependency, BOOST_DI_UNUSED auto... ctor) {
      using T = decltype(type);
      using name = typename T::name;
      using given = typename decltype(dependency)::given;

      auto root = v[i - 1];
      if (root != &amp;typeid(nullptr)) {
        std::cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; root-&gt;name() &lt;&lt; &quot;\&quot; .. \&quot;&quot; &lt;&lt; typeid(given).name()
                  &lt;&lt; ((*(name*)(0))() ? std::string(&quot; [&quot;) + (*(name*)(0))() + std::string(&quot;]&quot;) : &quot;&quot;) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
      }

      auto ctor_size = sizeof...(ctor);
      while (ctor_size--) {
        v.insert((v.begin() + i), &amp;typeid(given));
      }
      ++i;
    });
  }
};

int main() {
  /*&lt;&lt;define injector&gt;&gt;*/
  auto injector = di::make_injector&lt;uml_dumper&gt;(
    di::bind&lt;i0&gt;().to&lt;c0&gt;()
  , di::bind&lt;int&gt;().named(int_1).to(42)
  , di::bind&lt;int&gt;().named(int_2).to(42)
  );

  /*&lt;&lt;iterate through created objects with `types_dumper`&gt;&gt;*/
  injector.create&lt;c3&gt;();

  /*&lt;&lt;output [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]]&gt;&gt;*/
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp</a>
<a href="../images/uml_dumper.png"><img alt="UML Dumper" src="../images/uml_dumper.png" /></a></li>
</ul>
<p>See also.  <br /><br />
<em> <a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp"> Custom Policy Example</a>
</em> <a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/types_dumper.cpp"> Types Dumper Extension</a></p>
<p><br /></p>
<p>On the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow
smart pointers and disallow raw pointers too. We may want to have a <code>view</code> only with const parameters being passed, etc.
<code>Boost.DI</code> allows you to do so by using <a href="../user_guide/index.html#di_constructible">constructible</a> policy or writing a custom <a href="../user_guide/index.html#policies">policy</a>.</p>
<pre><code class="cpp">class all_must_be_bound_unless_int;
#define BOOST_DI_CFG all_must_be_bound_unless_int
#include &lt;boost/di.hpp&gt;


class all_must_be_bound_unless_int : public di::config {
 public:
  static auto policies(...) noexcept {
    using namespace di::policies;
    using namespace di::policies::operators;
    return di::make_policies(constructible(std::is_same&lt;di::_, int&gt;{} || is_bound&lt;di::_&gt;{}));
  }
};

int main() {
  assert(0 == di::make_injector().create&lt;int&gt;());
  // di::make_injector().create&lt;double&gt;(); // compile error
  assert(42.0 == make_injector(di::bind&lt;double&gt;().to(42.0)).create&lt;double&gt;());
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp</a></li>
</ul>
<p>See also.</p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_local.cpp"> Constructible Example</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="7-advanced-customize-it">7. [Advanced] Customize it</h3>
<p><code>Boost.DI</code> was design having extensibility in mind. You can easily customize</p>
<ul>
<li><a href="../user_guide/index.html#scopes">scopes</a> - to have custom life time of an object</li>
<li><a href="../user_guide/index.html#providers">providers</a> - to have custom way of creating objects, for example by using preallocated memory</li>
<li>
<p><a href="../user_guide/index.html#policies">policies</a> - to have custom way of dumping types at run-time or limiting them at compile-time</p>
</li>
<li>
<p><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp"> Custom Policy Example</a></p>
</li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp"> Custom Provider Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp"> Pool Provider Example</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="8-advanced-extend-it">8. [Advanced] Extend it</h3>
<p>As mentioned before, <code>Boost.DI</code> is quite easy to extend and therefore a lot of extensions exists already.
Please check them out and write your own!</p>
<ul>
<li><a href="../extensions/index.html#constructor-bindings">Constructor Bindings</a></li>
<li><a href="../extensions/index.html#assisted-injection">Assisted Injection</a></li>
<li><a href="../extensions/index.html#concepts">Concepts</a></li>
<li><a href="../extensions/index.html#lazy">Lazy</a></li>
<li><a href="../extensions/index.html#named-parameters">Named Parameters</a></li>
<li><a href="../extensions/index.html#xml-injection">XML Injection</a></li>
<li><a href="../extensions/index.html#types-dumper">Types Dumper</a></li>
<li><a href="../extensions/index.html#uml-dumper">UML Dumper</a></li>
<li><a href="../extensions/index.html#mocks-provider">Mocks Provider</a></li>
<li><a href="../extensions/index.html#scoped-scope">Scoped Scope</a></li>
<li><a href="../extensions/index.html#session-scope">Session Scope</a></li>
<li><a href="../extensions/index.html#shared-scope">Shared Scope</a></li>
</ul>
</div>

<script src="../js/highlight.pack.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>

<div class="copyright-footer">Copyright &copy; 2016
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>

</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../overview/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../user_guide/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
    <option value="https://boost-experimental.github.io/di">Theme: Boost Experimental</option>
    <option value="https://boost-experimental.github.io/di/boost" selected>Theme: Boost Classic</option>
</select>
</body>
</html>