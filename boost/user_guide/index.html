<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<meta name="author" content="Krzysztof Jusiak">
<link rel="canonical" href="http://boost-experimental.github.io/di/user_guide/index.html">
<title>User Guide - Boost.DI</title>

<link href="../css/boostbook.css" rel="stylesheet">
<link href="../css/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div width="100%">
<a href="http://www.boost.org/"><img alt="Boost C++ Libraries" width="277" height="86" src="../images/boost.png"></a>
</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../try_it/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../examples/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="#injector">Injector</a></span></dt>
    

    
        <dt><span class="section"><a href="#bindings">Bindings</a></span></dt>
    

    
        <dt><span class="section"><a href="#injections">Injections</a></span></dt>
    

    
        <dt><span class="section"><a href="#annotations">Annotations</a></span></dt>
    

    
        <dt><span class="section"><a href="#scopes">Scopes</a></span></dt>
    

    
        <dt><span class="section"><a href="#modules">Modules</a></span></dt>
    

    
        <dt><span class="section"><a href="#providers">Providers</a></span></dt>
    

    
        <dt><span class="section"><a href="#policies">Policies</a></span></dt>
    

    
        <dt><span class="section"><a href="#concepts">Concepts</a></span></dt>
    

    
        <dt><span class="section"><a href="#configuration">Configuration</a></span></dt>
    

</dl>
</div>



<div class="section">
<ul>
<li><a href="#injector">Injector</a><ul>
<li><a href="#di_make_injector">di::make_injector</a></li>
</ul>
</li>
<li><a href="#bindings">Bindings</a><ul>
<li><a href="#di_bind">di::bind</a></li>
</ul>
</li>
<li><a href="#injections">Injections</a><ul>
<li><a href="#di_automatic">automatic (default)</a></li>
<li><a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a></li>
<li><a href="#BOOST_DI_INJECT_TRAITS">BOOST_DI_INJECT_TRAITS</a></li>
<li><a href="#di_inject">di::inject</a></li>
<li><a href="#di_ctor_traits">di::ctor_traits</a></li>
</ul>
</li>
<li><a href="#annotations">Annotations</a><ul>
<li><a href="#di_named">(named = name)</a></li>
</ul>
</li>
<li><a href="#scopes">Scopes</a><ul>
<li><a href="#di_deduce">di::deduce (default)</a></li>
<li><a href="#di_instance">di::instance (di::bind&lt;&gt;.to(value))</a></li>
<li><a href="#di_singleton">di::singleton</a></li>
<li><a href="#di_unique">di::unique</a></li>
</ul>
</li>
<li><a href="#modules">Modules</a><ul>
<li><a href="#BOOST_DI_EXPOSE">BOOST_DI_EXPOSE</a></li>
</ul>
</li>
<li><a href="#providers">Providers</a><ul>
<li><a href="#di_stack_over_heap">di::providers::stack_over_heap (default)</a></li>
<li><a href="#di_heap">di::providers::heap</a></li>
</ul>
</li>
<li><a href="#policies">Policies</a><ul>
<li><a href="#di_constructible">di::policies::constructible</a></li>
</ul>
</li>
<li><a href="#concepts">Concepts</a><ul>
<li><a href="#di_boundable">di::concepts::boundable</a></li>
<li><a href="#di_callable">di::concepts::callable</a></li>
<li><a href="#di_configurable">di::concepts::configurable</a></li>
<li><a href="#di_creatable">di::concepts::creatable</a></li>
<li><a href="#di_providable">di::concepts::providable</a></li>
<li><a href="#di_scopable">di::concepts::scopable</a></li>
</ul>
</li>
<li><a href="#configuration">Configuration</a><ul>
<li><a href="#di_config">di::config</a></li>
</ul>
</li>
</ul>
<hr />
<p>Let's assume all examples below include <code>boost/di.hpp</code> header and define a convenient <code>di</code>
namespace alias as well as some basic interfaces and types.</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;
namespace di = boost::di;

struct i1 { virtual ~i1() = default; virtual void dummy1() = 0; };
struct i2 { virtual ~i2() = default; virtual void dummy2() = 0; };
struct impl1 : i1 { void dummy1() override { } };
struct impl2 : i2 { void dummy2() override { } };
struct impl : i1, i2 { void dummy1() override { } void dummy2() override { } };
</code></pre>

<h3 id="injector">Injector</h3>
<p><a id="di_make_injector"></a></p>
<p>Injector is a core component providing types creation functionality using <a href="#bindings">bindings</a>.</p>
<p>--- <strong><em>di::make_injector</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates <a href="#di_make_injector">injector</a> type.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>template&lt;class... TDeps&gt; requires boundable&lt;TDeps...&gt;
class injector {
public:
  using deps; // list of dependencies
  using config; // configuration

  injector(injector&amp;&amp;) = default;
  template &lt;class... Ts&gt; // no requirements
  injector(core::injector&lt;Ts...&gt;&amp;&amp;) noexcept;
  explicit injector(const TDeps&amp;...) noexcept;

  template&lt;class T&gt; requires creatable&lt;T&gt;
  T create() const;
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TDeps...</code></td>
<td><a href="#di_boundable">boundable</a>&lt;TDeps...></td>
<td><a href="#bindings">Bindings</a> to be used as configuration</td>
<td>-</td>
</tr>
<tr>
<td><code>create&lt;T&gt;()</code></td>
<td><a href="#di_creatable">creatable</a>&lt;T></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type <code>T</code></th>
<th>Is allowed?</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>T*</code></td>
<td>✔</td>
<td>Ownership transfer!</td>
</tr>
<tr>
<td><code>const T*</code></td>
<td>✔</td>
<td>Ownership transfer!</td>
</tr>
<tr>
<td><code>T&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>const T&amp;</code></td>
<td>✔</td>
<td>Reference with <a href="#di_singleton">singleton</a> / Temporary with <a href="#di_unique">unique</a></td>
</tr>
<tr>
<td><code>T&amp;&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::unique_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::weak_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>boost_shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
</tbody>
</table>
<pre><code>template&lt;
  class TConfig = di::config
, class... TBindings
&gt; requires configurable&lt;TConfig&gt; &amp;&amp; boundable&lt;TBindings...&gt;
auto make_injector(const TBindings&amp;...) noexcept;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TConfig</code></td>
<td><a href="#di_configurable">configurable</a>&lt;TConfig></td>
<td><a href="#di_config">Configuration</a> per <a href="#di_make_injector">injector</a></td>
<td>-</td>
</tr>
<tr>
<td><code>make_injector(const TBindings&amp;...)</code></td>
<td><a href="#di_boundable">boundable</a>&lt;TBindings...></td>
<td>Creates <a href="#di_make_injector">injector</a> with given <a href="#bindings">Bindings</a></td>
<td><a href="#di_make_injector">injector</a></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
int main() {
  auto injector = di::make_injector();

  assert(0 == injector.create&lt;int&gt;());
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/hello_world.cpp"> Hello World Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp"> Create Objects Tree Example</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="bindings">Bindings</h3>
<p>Bindings define dependencies configuration describing what types will be created
and what values will be passed into them.</p>
<p><a id="di_bind"></a>
--- <strong><em>di::bind</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Allows to bind interface to implementation and associate value with it.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct override; // overrides given configuration

namespace detail {
  template&lt;class I, class... Is/*any_of*/&gt; requires boundable&lt;I, Is...&gt;
  struct bind {
    bind(bind&amp;&amp;) noexcept = default;

    template &lt;class T&gt; requires !is_array&lt;I&gt; &amp;&amp; boundable&lt;I, T&gt;
    auto to() noexcept;

    template &lt;class... Ts&gt; requires is_array&lt;I&gt; &amp;&amp; boundable&lt;Ts...&gt;
    auto to() noexcept;

    template&lt;class T&gt; requires boundable&lt;I, T&gt;
    auto to(T&amp;&amp;) noexcept;

    template&lt;class TScope&gt; requires scopable&lt;TScope&gt;
    auto in(const TScope&amp; = di::deduce) noexcept;

    template&lt;class TName&gt; // no requirements
    auto named(const TName&amp; = {}) noexcept;

    auto operator[](const override&amp;) noexcept;
  };
} // detail

template&lt;class... Ts&gt; requires boundable&lt;Ts...&gt;
detail::bind&lt;Ts...&gt; bind{};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>I</code>, <code>Is...</code></td>
<td><a href="#di_boundable">boundable</a>&lt;I, Is...></td>
<td>'Interface' types</td>
<td>-</td>
</tr>
<tr>
<td><code>to&lt;T&gt;</code></td>
<td><a href="#di_boundable">boundable</a>&lt;T></td>
<td>Binds <code>I, Is...</code> to <code>T</code> type</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>to&lt;Ts...&gt;</code></td>
<td><a href="#di_boundable">boundable</a>&lt;Ts...></td>
<td>Binds <code>I, Is...</code> to <code>Ts...</code> type</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>to(T&amp;&amp;)</code></td>
<td><a href="#di_boundable">boundable</a>&lt;T></td>
<td>Binds <code>I, Is...</code> to <code>T</code> object</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>in(const TScope&amp;)</code></td>
<td><a href="#di_scopable">scopable</a>&lt;TScope></td>
<td>Binds <code>I, Is...</code> in TScope`</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>named(const TName&amp;)</code></td>
<td>-</td>
<td>Binds <code>I, Is...</code> using <a href="#di_named">named</a> annotation</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
<tr>
<td><code>operator[](const override&amp;)</code></td>
<td>-</td>
<td>Overrides given binding</td>
<td><a href="#di_boundable">boundable</a></td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Check out also <a href="#di_instance">instance</a> scope to read more about binding to values: <code>di::bind&lt;&gt;.to(value)</code>.
</span></p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Multiple Interfaces</strong></td>
<td></td>
</tr>
<tr>
<td><code>di::bind&lt;Interface1, Interface2, ...&gt;.to&lt;Implementation&gt;()</code></td>
<td>Binds <code>Interface1, Interface2, ...</code> to <code>Implementation</code> using one object</td>
</tr>
<tr>
<td><strong>Multiple Bindings</strong> (std::array, std::vector, std::set)</td>
<td></td>
</tr>
<tr>
<td><code>di::bind&lt;int[]&gt;.to({1, 2, ...})</code></td>
<td>Binds <code>int</code> to values <code>1, 2, ...</code></td>
</tr>
<tr>
<td><code>di::bind&lt;Interface*[]&gt;.to&lt;Implementation1, Implementation2, ...&gt;()</code></td>
<td>Binds <code>Interface</code> to <code>Implementation1, Implementation2, ...</code></td>
</tr>
<tr>
<td><strong>Dynamic Bindings</strong></td>
<td></td>
</tr>
<tr>
<td><code>di::bind&lt;Interface&gt;.to([](const auto&amp; injector)</code><br /><code>{ return injector.template create&lt;Implementation&gt;()})</code></td>
<td>Allows to bind <code>Interface</code> depending on a run-time condition</td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;()
  );

  auto object = injector.create&lt;std::unique_ptr&lt;i1&gt;&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(object.get()));
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  );

  assert(42 == injector.create&lt;int&gt;());
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;&gt;().to(42)
  );

  assert(42 == injector.create&lt;int&gt;());
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to&lt;std::integral_constant&lt;int, 42&gt;&gt;()
  );

  assert(42 == injector.create&lt;int&gt;());
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;i1, i2&gt;().to&lt;impl&gt;()
  );

  auto object1 = injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;();
  auto object2 = injector.create&lt;std::shared_ptr&lt;i2&gt;&gt;();
  assert(dynamic_cast&lt;impl*&gt;(object1.get()));
  assert(dynamic_cast&lt;impl*&gt;(object2.get()));
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;i1&gt;().to([&amp;](const auto&amp; injector) -&gt; i1&amp; {
      if (true)
        return injector.template create&lt;impl1&amp;&gt;();
      else
        return injector.template create&lt;impl&amp;&gt;();
    })
  );

  auto&amp;&amp; object = injector.create&lt;i1&amp;&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(&amp;object));
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;i1*[]&gt;().to&lt;impl, impl1&gt;()
  );

  auto v = injector.create&lt;std::vector&lt;std::unique_ptr&lt;i1&gt;&gt;&gt;();
  assert(2 == v.size());
  assert(dynamic_cast&lt;impl*&gt;(v[0].get()));
  assert(dynamic_cast&lt;impl1*&gt;(v[1].get()));
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;int[]&gt;().to({1, 2, 3}) // or int*[]
  );

  auto v = injector.create&lt;std::vector&lt;int&gt;&gt;();
  assert(3 == v.size());
  assert(1 == v[0]);
  assert(2 == v[1]);
  assert(3 == v[2]);
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;int&gt;().to(123) [di::override]
  );

  assert(123 == injector.create&lt;int&gt;());
}
</code></pre>

<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
#if defined(__cpp_variable_templates)
      di::bind&lt;i1&gt;.to&lt;impl1&gt;()
#else
      di::bind&lt;i1&gt;().to&lt;impl1&gt;()  // no variable templates
#endif
          );

  auto object = injector.create&lt;std::unique_ptr&lt;i1&gt;&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(object.get()));
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp"> Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp"> Forward Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp"> Dynamic Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp"> Multiple Bindings Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/bindings/constructor_bindings.cpp"> Constructor Bindings Extension</a></li>
</ul>
<p><br /><br /><br /><hr /></p>
<h3 id="injections">Injections</h3>
<p><em>Constructor Injection</em> is the most powerful of available injections.
It guarantees initialized state of data members. Boost.DI constructor injection is achieved without any additional work from the user.</p>
<p><a id="di_automatic"></a>
--- <strong><em>automatic (default)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Boost.DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.
If the default behavior should be changed constructor has to be explicitly marked with
<a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a> or <a href="#BOOST_DI_INJECT_TRAITS">BOOST_DI_INJECT_TRAITS</a> or di::ctor_traits] or <a href="#di_inject">di::inject</a>.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Automatic constructor parameters deduction is limited to <a href="../overview/index.html#configuration">BOOST_DI_CFG_CTOR_LIMIT_SIZE</a>, which by default is set to 10.
</span></p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>class T {
public:
  T(auto parameter1, auto parameter2, ..., auto parameterN);
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>parameter1-parameterN</code></td>
<td>-</td>
<td><code>N</code> constructor parameter</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Boost.DI is not able to automatically distinguish between ambiguous constructors with the same (longest) number of parameters.
Use <a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a> or <a href="#BOOST_DI_INJECT_TRAITS">BOOST_DI_INJECT_TRAITS</a> or <a href="#di_ctor_traits">di::ctor_traits</a> or <a href="#di_inject">di::inject</a> to explicitly mark constructor to be injected.
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct T {
  T(int a, double d) : a(a), d(d) {}

  int a = 0;
  double d = 0.0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<pre><code class="cpp">
struct T {
  int a;     // = 0;
  double d;  // = 0.0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<pre><code class="cpp">
struct T {
  T();
  T(int a) : a(a) {}
  T(int a, double d) : a(a), d(d) {}  // longest will be chosen

  int a = 0;
  double d = 0.0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<pre><code class="cpp">
struct T {
  T(double d, int a) : a(a), d(d) {}
  T(int a, double d, ...) : a(a), d(d) {}

  int a = 0;
  double d = 0.0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp"> Automatic Injection Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp"> Constructor Signature Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/lazy.cpp"> Lazy Extension</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/xml_injection.cpp"> XML Injection Extension</a></li>
</ul>
<p><br /><br /><br /><hr /></p>
<p><a id="BOOST_DI_INJECT"></a>
--- <strong><em>BOOST_DI_INJECT</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>BOOST_DI_INJECT is a macro definition used to explicitly say Boost.DI which constructor should be used as well as to annotate types - see <a href="#annotations">annotations</a> for further reding.
When class has more than one constructor Boost.DI will by default choose the one with the longest parameter list.
In case of constructors ambiguity, Boost.DI is not able to choose the best one.
Then BOOST_DI_INJECT becomes handy to point which constructor should be used.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct T {
    BOOST_DI_INJECT(T, ...) { }
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>-</td>
<td>Class/Struct name</td>
<td>-</td>
</tr>
<tr>
<td><code>...</code></td>
<td>-</td>
<td><code>T</code> constructor parameters</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
BOOST_DI_INJECT constructor parameters is limited to <a href="../overview/index.html#configuration">BOOST_DI_CFG_CTOR_LIMIT_SIZE</a>, which by default is set to 10.
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct T {
  T(double d, int a) : a(a), d(d) {}
  BOOST_DI_INJECT(T, int a, double d) : a(a), d(d) {}

  int a = 0;
  double d = 0.0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp"> Constructor Injection Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/concepts.cpp"> Concepts Extension</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="BOOST_DI_INJECT_TRAITS"></a>
--- <strong><em>BOOST_DI_INJECT_TRAITS</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>BOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct T {
  BOOST_DI_INJECT_TRAITS(...) { }
  T(...) { }
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>...</code></td>
<td>-</td>
<td><code>T</code> constructor parameters</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
BOOST_DI_INJECT_TRAITS constructor parameters is limited to <a href="../overview/index.html#configuration">BOOST_DI_CFG_CTOR_LIMIT_SIZE</a>, which by default is set to 10.
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct T {
  BOOST_DI_INJECT_TRAITS(int, double);
  T(double d, int a) : a(a), d(d) {}
  T(int a, double d) : a(a), d(d) {}

  int a = 0;
  double d = 0.0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<pre><code class="cpp">
class example {
 public:
  BOOST_DI_INJECT_TRAITS(int);
  explicit example(int i, double d = 42.0) : i(i), d(d) {}

  int i = 0;
  double d = 0.0;
};

int main() {
  auto injector = di::make_injector();
  auto object = injector.create&lt;example&gt;();
  assert(0 == object.i);
  assert(42.0 == object.d);
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp"> Constructor Injection Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="di_inject"></a>
--- <strong><em>di::inject</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><code>di::inject</code> informs Boost.DI about constructor parameters.
It's useful for generated/generic classes as it doesn't have constructor parameters size limitations.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>struct T {
  using boost_di_inject__ = di::inject&lt;...&gt;;
  T(...) {}
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>...</code></td>
<td>-</td>
<td><code>T</code> constructor parameters</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
<code>di::inject</code> has no limitations if it comes to constructor parameters, however, <a href="#di_named">named</a> parameters are not allowed.
Moreover, you can replace <code>di::inject</code> with any variadic type list type to remove dependency to Boost.DI.
For example, <code>template&lt;class...&gt; struct type_list{};</code> <code>using boost_di_inject__ = type_list&lt;...&gt;;</code>
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct T {
  T(double d, int a) : a(a), d(d) {}
  T(int a, double d) : a(a), d(d) {}
  using boost_di_inject__ = di::inject&lt;int, double&gt;;

  int a = 0;
  double d = 0.0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<pre><code class="cpp">
struct T {
  using boost_di_inject__ = di::inject&lt;
    int, int, int, int, int, int, int, int, int, int
  , int, int, int, int, int, int, int, int, int, int
  , int, int, int, int, int, int, int, int, int, int&gt;;

  T(int, int, int, int, int, int, int, int, int, int
  , int, int, int, int, int, int, int, int, int, int
  , int, int, int, int, int, int, int, int, int, int) { }
};

int main() {
  auto injector = di::make_injector();
  injector.create&lt;T&gt;();  // compile clean
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp"> Constructor Injection Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="di_ctor_traits"></a>
--- <strong><em>di::ctor_traits</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><code>di::ctor_traits</code> is a trait in which constructor parameters for type <code>T</code> might be specified.
It's useful for third party classes you don't have access to and which can't be created using <a href="#di_automatic">automatic</a> injection.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace boost {
namespace di {
  template &lt;&gt;
  struct ctor_traits&lt;T&gt; {
    BOOST_DI_INJECT_TRAITS(...); // or using type = di::inject&lt;...&gt;;
  };
}}
</code></pre>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct T {
  T(double d, int a) : a(a), d(d) {}
  T(int a, double d) : a(a), d(d) {}

  int a = 0;
  double d = 0.0;
};

namespace boost {
namespace di {
template &lt;&gt;
struct ctor_traits&lt;T&gt; {
  BOOST_DI_INJECT_TRAITS(int, double);
};
}
}  // boost::di

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(42)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87.0 == object.d);
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp"> Constructor Injection Example</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="annotations">Annotations</h3>
<p>Annotations are type properties specified in order to refer to a type by the name instead of the type it self.
They are useful when constructor has more than one parameter of the same type.
For example, <code>T(int, int)</code>.</p>
<p><a id="di_named"></a>
--- <strong><em>(named = name)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Named parameters are handy to distinguish different constructor parameters of the same type.</p>
<pre><code class="cpp">  T(int value1, int value2);
</code></pre>

<p>In order to inject proper values into <code>value1</code> and <code>value2</code> they have to be differentiate somehow.
Boost.DI solution for this problem are annotations.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Annotations might be set only when constructor is marked using <a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a> or <a href="#BOOST_DI_INJECT_TRAITS">BOOST_DI_INJECT_TRAITS</a>.
</span></p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>auto Name = []{}; // just an object

struct T {
  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Name</code></td>
<td>-</td>
<td>Object representing named type</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Example</em></strong></p>
<pre><code>BOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);
</code></pre>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Implementation of constructor doesn't require annotations, only constructor definition requires them.
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
auto int1 = [] {};
auto int2 = [] {};

struct T {
  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b) : a(a), b(b) {}
  int a = 0;
  int b = 0;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().named(int1).to(42)
  , di::bind&lt;int&gt;().named(int2).to(87)
  );
  {
    auto object = injector.create&lt;T&gt;();
    assert(42 == object.a);
    assert(87 == object.b);
  }
  {
    auto object = T(42, 87);
    assert(42 == object.a);
    assert(87 == object.b);
  }
}
</code></pre>

<pre><code class="cpp">
auto int1 = [] {};
auto int2 = [] {};

struct T {
  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b);
  int a = 0;
  int b = 0;
};

T::T(int a, int b) : a(a), b(b) {}

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().named(int1).to(42)
  , di::bind&lt;int&gt;().named(int2).to(87)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87 == object.b);
}
</code></pre>

<pre><code class="cpp">
auto int1 = [] {};
auto int2 = [] {};

struct T {
  T(int a, int b) : a(a), b(b) {}
  int a = 0;
  int b = 0;
};

namespace boost {
namespace di {
template &lt;&gt;
struct ctor_traits&lt;T&gt; {
  BOOST_DI_INJECT_TRAITS((named = int1) int, (named = int2) int);
};
}
}  // boost::di

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().named(int1).to(42)
  , di::bind&lt;int&gt;().named(int2).to(87)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.a);
  assert(87 == object.b);
}
</code></pre>

<pre><code class="cpp">
auto n1 = [] {};
auto n2 = [] {};

struct T {
  BOOST_DI_INJECT(T, (named = n1) int i1
                   , (named = n1) int i2
                   , (named = n2) int i3
                   , int i4
                   , (named = n1)std::string s)
    : i1(i1), i2(i2), i3(i3), i4(i4), s(s) {}
  int i1 = 0;
  int i2 = 0;
  int i3 = 0;
  int i4 = 0;
  std::string s;
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().named(n1).to(42)
  , di::bind&lt;int&gt;().named(n2).to(87)
  , di::bind&lt;std::string&gt;().named(n1).to(&quot;str&quot;)
  );
  auto object = injector.create&lt;T&gt;();
  assert(42 == object.i1);
  assert(42 == object.i2);
  assert(87 == object.i3);
  assert(0 == object.i4);
  assert(&quot;str&quot; == object.s);
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp"> Annotations Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/named_parameters.cpp"> Named Parameters Extension</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/assisted_injection.cpp"> Assisted Injection Extension</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="scopes">Scopes</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scopes are responsible for creating and maintaining life time of dependencies.
If no scope will be given, <a href="#di_deduce">deduce</a> scope will be assumed.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>template &lt;class TExpected, class TGiven&gt;
struct scope {
  template &lt;class T&gt;
  using is_referable;

  template &lt;class T, class TName, class TProvider&gt;
  static auto try_create(const TProvider&amp;);

  template &lt;class T, class TName, class TProvider&gt;
  auto create(const TProvider&amp;);
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type <code>T</code> might be created</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type/Scope</th>
<th><a href="#di_unique">unique</a></th>
<th><a href="#di_singleton">singleton</a></th>
<th><a href="#di_instance">instance</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>T* (transfer ownership)</td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>const T*</td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
<td>- / ✔ converted to</td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td>-</td>
<td>✔</td>
<td>- / ✔ converted to</td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct custom_scope {
  template &lt;class TExpected, class&gt;
  struct scope {
    template &lt;class&gt;
    using is_referable = std::false_type;

    template &lt;class T, class, class TProvider&gt;
    static auto try_create(const TProvider&amp; provider) -&gt; decltype(std::shared_ptr&lt;TExpected&gt;{provider.get()});

    template &lt;class T, class, class TProvider&gt;
    auto create(const TProvider&amp; provider) {
      return std::shared_ptr&lt;TExpected&gt;{provider.get()};
    }
  };
};

int main() {
  auto injector = di::make_injector(
    di::bind&lt;i1&gt;().in(custom_scope{}).to&lt;impl1&gt;()
  );
  assert(injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;() != injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;());
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_scope.cpp"> Custom Scope Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/scoped_scope.cpp"> Scoped Scope Extension</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/session_scope.cpp"> Session Scope Extension</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/shared_scope.cpp"> Shared Scope Extension</a></li>
</ul>
<p><br /><br /><br /><hr /></p>
<p><a id="di_deduce"></a>
--- <strong><em>di::deduce (default)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Default scope which will be converted to one of the scopes depending on the type.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td><a href="#di_unique">unique</a></td>
</tr>
<tr>
<td>T&amp;</td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
<tr>
<td>const T&amp;</td>
<td><a href="#di_unique">unique</a> (temporary) / <a href="#di_singleton">singleton</a></td>
</tr>
<tr>
<td>T*</td>
<td><a href="#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>const T*</td>
<td><a href="#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td><a href="#di_unique">unique</a></td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td><a href="#di_unique">unique</a></td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct deduce {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}

scopes::deduce deduce;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type <code>T</code> might be created</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct T {
  T(const std::shared_ptr&lt;i1&gt;&amp; sp, std::unique_ptr&lt;i2&gt; up, int&amp; i, double d) : sp(sp), up(std::move(up)), i(i), d(d) {}

  std::shared_ptr&lt;i1&gt; sp; /*singleton*/
  std::unique_ptr&lt;i2&gt; up; /*unique*/
  int&amp; i;                 /*instance*/
  double d;               /*unique*/
};

int main() {
  auto i = 42;
  auto injector = di::make_injector(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;()
  , di::bind&lt;i2&gt;().to&lt;impl2&gt;()
  , di::bind&lt;int&gt;().to(i)
  , di::bind&lt;double&gt;().to(87.0)
  );
  auto object1 = injector.create&lt;std::unique_ptr&lt;T&gt;&gt;();
  auto object2 = injector.create&lt;std::unique_ptr&lt;T&gt;&gt;();
  assert(object1-&gt;sp == object2-&gt;sp);
  assert(object1-&gt;up != object2-&gt;up);
  assert(42 == object1-&gt;i);
  assert(&amp;i == &amp;object1-&gt;i);
  assert(42 == object2-&gt;i);
  assert(&amp;i == &amp;object2-&gt;i);
  assert(87.0 == object1-&gt;d);
  assert(87.0 == object2-&gt;d);
  i = 12;
  assert(i == object2-&gt;i);
  assert(&amp;i == &amp;object2-&gt;i);
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp"> Deduce Scope Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp"> Scopes Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="di_instance"></a>
--- <strong><em>di::instance (di::bind&lt;&gt;.to(value))</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scope representing values - passed externally. The life time of the object depends on the user.
Boost.DI is not maintaining the life time of these objects, however, values and strings will be copied and managed by the library.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>instance[in] (<code>bind&lt;&gt;.to(in)</code>)</th>
<th>instance[out] (<code>injector.create&lt;out&gt;()</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>T*</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>const T*</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td>-</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct instance {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type <code>T</code> might be created</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
int main() {
  auto l = 42l;
  auto b = false;
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().to(0)
  , di::bind&lt;int&gt;().to(42)[di::override]
  , di::bind&lt;i1&gt;().to(std::make_shared&lt;impl&gt;())
  , di::bind&lt;long&gt;().to(l)
  , di::bind&lt;short&gt;().to([] { return 87; })
  , di::bind&lt;i2&gt;().to([&amp;](const auto&amp; injector) -&gt; std::shared_ptr&lt;i2&gt; {
      return b ? injector.template create&lt;std::shared_ptr&lt;impl2&gt;&gt;() : nullptr; })
  );

  assert(42 == injector.create&lt;int&gt;());
  assert(injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;() == injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;());
  assert(l == injector.create&lt;long&amp;&gt;());
  assert(&amp;l == &amp;injector.create&lt;long&amp;&gt;());
  assert(87 == injector.create&lt;short&gt;());
  {
    auto object = injector.create&lt;std::shared_ptr&lt;i2&gt;&gt;();
    assert(nullptr == object);
  }
  {
    b = true;
    auto object = injector.create&lt;std::shared_ptr&lt;i2&gt;&gt;();
    assert(dynamic_cast&lt;impl2*&gt;(object.get()));
  }
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp"> Scopes Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp"> Bindings Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="di_singleton"></a>
--- <strong><em>di::singleton</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scope representing shared value between all instances as well as threads.
Singleton scope will be deduced in case of reference, <code>std::shared_ptr</code>, <code>boost::shared_ptr</code> or <code>std::weak_ptr</code>.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Singleton scope will convert automatically between <code>std::shared_ptr</code> and <code>boost::shared_ptr</code> if required.
</span></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>singleton</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>-</td>
</tr>
<tr>
<td>T&amp;</td>
<td>✔</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔</td>
</tr>
<tr>
<td>T*</td>
<td>-</td>
</tr>
<tr>
<td>const T*</td>
<td>-</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>-</td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td>-</td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td>✔</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct singleton {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}

scopes::singleton singleton;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type <code>T</code> might be created</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;i1&gt;().in(di::singleton).to&lt;impl1&gt;()
  );

  assert(injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;() == injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;());
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp"> Scopes Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp"> Eager Singletons Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="di_unique"></a>
--- <strong><em>di::unique</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Scope representing unique/per request value. A new instance will be provided each time type will be requested.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>unique</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
</tr>
<tr>
<td>T*</td>
<td>✔ (ownership transfer)</td>
</tr>
<tr>
<td>const T*</td>
<td>✔ (ownership transfer)</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td>✔</td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace scopes {
  struct unique {
    template &lt;class TExpected, class TGiven&gt;
    struct scope {
      template &lt;class T&gt;
      using is_referable;

      template &lt;class T, class TName, class TProvider&gt;
      static auto try_create(const TProvider&amp;);

      template &lt;class T, class TName, class TProvider&gt;
      auto create(const TProvider&amp;);
    };
  };
}

scopes::unique unique;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TExpected</code></td>
<td>-</td>
<td>'Interface' type</td>
<td>-</td>
</tr>
<tr>
<td><code>TGiven</code></td>
<td>-</td>
<td>'Implementation' type</td>
<td>-</td>
</tr>
<tr>
<td><code>is_referable&lt;T&gt;</code></td>
<td>-</td>
<td>Verifies whether scope value might be converted to a reference</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>try_create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Verifies whether type <code>T</code> might be created</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>create&lt;T, TName, TProvider&gt;</code></td>
<td><a href="#di_providable">providable</a>&lt;TProvider></td>
<td>Creates type <code>T</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
int main() {
  auto injector = di::make_injector(
    di::bind&lt;i1&gt;().in(di::unique).to&lt;impl1&gt;()
  );

  assert(injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;() != injector.create&lt;std::shared_ptr&lt;i1&gt;&gt;());
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp"> Scopes Example</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="modules">Modules</h3>
<p><a id="di_module"></a></p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Modules allow to split <a href="#bindings">bindings</a> configuration into smaller <a href="#injector">injectors</a>.
Module might be installed by passing it into <a href="#di_make_injector">make_injector</a>.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>auto module = di::make_injector(...);
di::injector&lt;Ts...&gt; module = di::make_injector(...);
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>auto module = di::make_injector(...)</code></td>
<td>All types are exposed from <code>module</code></td>
<td><code>module.create&lt;T&gt;()</code> is allowed for any <code>T</code></td>
</tr>
<tr>
<td><code>di::injector&lt;Ts...&gt; module = di::make_injector(...)</code></td>
<td>Only <code>Ts...</code> types are exposed from <code>module</code></td>
<td><code>module.create&lt;T&gt;()</code> is allowed only for <code>T</code> &lt;= <code>Ts...</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
struct T {
  T(std::unique_ptr&lt;i1&gt; i1, std::unique_ptr&lt;i2&gt; i2, int i) : i1_(std::move(i1)), i2_(std::move(i2)), i(i) {}

  std::unique_ptr&lt;i1&gt; i1_;
  std::unique_ptr&lt;i2&gt; i2_;
  int i = 0;
};

auto module1 = [] {
  return di::make_injector(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;()
  , di::bind&lt;int&gt;().to(42)
  );
};

auto module2 = [] {
  return di::make_injector(
    di::bind&lt;i2&gt;().to&lt;impl2&gt;()
  );
};

int main() {
  auto injector = di::make_injector(module1(), module2());
  auto object = injector.create&lt;std::unique_ptr&lt;T&gt;&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(object-&gt;i1_.get()));
  assert(dynamic_cast&lt;impl2*&gt;(object-&gt;i2_.get()));
  assert(42 == object-&gt;i);
  auto up1 = injector.create&lt;std::unique_ptr&lt;i1&gt;&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(up1.get()));
  auto up2 = injector.create&lt;std::unique_ptr&lt;i2&gt;&gt;();
  assert(dynamic_cast&lt;impl2*&gt;(up2.get()));
}
</code></pre>

<pre><code class="cpp">
struct T {
  T(std::shared_ptr&lt;i1&gt; i1, std::shared_ptr&lt;i2&gt; i2, int i) : i1_(i1), i2_(i2), i(i) {}

  std::shared_ptr&lt;i1&gt; i1_;
  std::shared_ptr&lt;i2&gt; i2_;
  int i;
};

di::injector&lt;T&gt; module(const int&amp; i) noexcept {
  return di::make_injector(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;()
  , di::bind&lt;i2&gt;().to&lt;impl2&gt;()
  , di::bind&lt;int&gt;().to(i)
  );
}

int main() {
  auto injector = di::make_injector(module(42));
  auto object = injector.create&lt;T&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(object.i1_.get()));
  assert(dynamic_cast&lt;impl2*&gt;(object.i2_.get()));
  assert(42 == object.i);
  // injector.create&lt;std::unique_ptr&lt;i1&gt;&gt;(); // compile error
  // injector.create&lt;std::unique_ptr&lt;i2&gt;&gt;(); // compile error
}
</code></pre>

<pre><code class="cpp">
auto module = []() -&gt; di::injector&lt;std::unique_ptr&lt;i1&gt;, std::unique_ptr&lt;i2&gt;&gt; {
  return di::make_injector(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;()
  , di::bind&lt;i2&gt;().to&lt;impl2&gt;()
  );
};

int main() {
  auto injector = di::make_injector(module());
  auto up1 = injector.create&lt;std::unique_ptr&lt;i1&gt;&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(up1.get()));
  auto up2 = injector.create&lt;std::unique_ptr&lt;i2&gt;&gt;();
  assert(dynamic_cast&lt;impl2*&gt;(up2.get()));
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp"> Modules Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="BOOST_DI_EXPOSE"></a>
--- <strong><em>BOOST_DI_EXPOSE</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>BOOST_DI_EXPOSE is a macro definition allowing to expose <a href="#di_named">named</a> parameters via module/<a href="#di_make_injector">injector</a>.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>di::injector&lt;BOOST_DI_EXPOSE((named = Name) T), ...&gt;;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Name</code></td>
<td>-</td>
<td>Named object</td>
<td>-</td>
</tr>
<tr>
<td><code>...</code></td>
<td>-</td>
<td>More types to be exposed</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
auto my_name = [] {};

struct T {
  BOOST_DI_INJECT(T, (named = my_name)std::unique_ptr&lt;i1&gt; up) : up(std::move(up)) {}
  std::unique_ptr&lt;i1&gt; up;
};

auto module = []() -&gt; di::injector&lt;BOOST_DI_EXPOSE((named = my_name)std::unique_ptr&lt;i1&gt;)&gt; {
  return di::make_injector(
    di::bind&lt;i1&gt;().named(my_name).to&lt;impl1&gt;()
  );
};

int main() {
  auto injector = di::make_injector(module());
  auto object = injector.create&lt;std::unique_ptr&lt;T&gt;&gt;();
  assert(dynamic_cast&lt;impl1*&gt;(object-&gt;up.get()));
}
</code></pre>

<pre><code class="cpp">
struct T {
  T(std::shared_ptr&lt;i1&gt; i1, std::shared_ptr&lt;i2&gt; i2, int i) : i1_(i1), i2_(i2), i(i) {}

  std::shared_ptr&lt;i1&gt; i1_;
  std::shared_ptr&lt;i2&gt; i2_;
  int i;
};

BOOST_DI_UNUSED auto name = [] {};

di::injector&lt;T, std::unique_ptr&lt;T&gt;, BOOST_DI_EXPOSE((named = name)T)&gt; module(const int&amp; i) noexcept {
  return di::make_injector(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;()
  , di::bind&lt;i2&gt;().to&lt;impl2&gt;()
  , di::bind&lt;int&gt;().to(i)
  );
}

int main() {
  auto injector = di::make_injector(module(42));
  {
    auto object = injector.create&lt;T&gt;();
    assert(dynamic_cast&lt;impl1*&gt;(object.i1_.get()));
    assert(dynamic_cast&lt;impl2*&gt;(object.i2_.get()));
    assert(42 == object.i);
  }
  {
    auto object = injector.create&lt;std::unique_ptr&lt;T&gt;&gt;();
    assert(dynamic_cast&lt;impl1*&gt;(object-&gt;i1_.get()));
    assert(dynamic_cast&lt;impl2*&gt;(object-&gt;i2_.get()));
    assert(42 == object-&gt;i);
  }
  {
    struct example {
      BOOST_DI_INJECT(example, (named = name)T object) : object(object) {}
      T object;
    };

    auto object = injector.create&lt;example&gt;().object;
    assert(dynamic_cast&lt;impl1*&gt;(object.i1_.get()));
    assert(dynamic_cast&lt;impl2*&gt;(object.i2_.get()));
    assert(42 == object.i);
  }
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp"> Modules Example</a></li>
</ul>
<p><br /><hr /></p>
<h3 id="providers">Providers</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Providers are responsible for creating objects using given <a href="#di_config">Configuration</a>.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace type_traits {
  struct direct; // T(...)
  struct uniform; // T{...}
  struct heap; // new T
  struct stack; // T
}

namespace providers {
  class provider {
    public:
      template &lt;class T, class... TArgs&gt;
      struct is_creatable;

      template &lt;
        class T
      , class TInit // type_traits::direct/type_traits::uniform
      , class TMemory // type_traits::heap/type_traits::stack
      , class... TArgs
      &gt; auto get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const;
  };
}

struct config : di::config {
  template&lt;class TInjector&gt;
  static auto provider(const TInjector&amp;) noexcept { return providers::stack_over_heap{}; }
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TInjector</code></td>
<td>-</td>
<td><a href="#di_make_injector">injector</a></td>
<td>-</td>
</tr>
<tr>
<td><code>is_creatable&lt;T, TArgs...&gt;</code></td>
<td><a href="#di_creatable">creatable</a>&lt;TArgs...></td>
<td>Verify whether <code>T</code> is creatable with <code>TArgs...</code></td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;...)</code></td>
<td><code>TInit</code> -&gt; direct/uniform, <code>TMemory</code> -&gt; heap/stack</td>
<td>Creates type <code>T</code> with <code>TArgs...</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Provider used by <a href="#di_make_injector">injector</a> might changed locally via <a href="#di_make_injector">make_injector</a> or globally via <a href="#di_config">BOOST_DI_CFG</a>.
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
class heap_no_throw {
 public:
  template &lt;class...&gt;
  struct is_creatable {
    static constexpr auto value = true;
  };

  template &lt;class T         // implementation
          , class TInit     // direct()/uniform{}
          , class TMemory   // heap/stack
          , class... TArgs&gt;
  auto get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const noexcept {
    return new (std::nothrow) T{std::forward&lt;TArgs&gt;(args)...};
  }
};

class my_provider : public di::config {
 public:
  static auto provider(...) noexcept { return heap_no_throw{}; }
};

int main() {
  auto injector = di::make_injector&lt;my_provider&gt;();
  assert(0 == injector.create&lt;int&gt;());
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp"> Custom Provider Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp"> Pool Provider Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="di_stack_over_heap"></a>
--- <strong><em>di::providers::stack_over_heap (default)</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates objects on the stack whenever possible, otherwise on the heap.</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace providers {
  class stack_over_heap {
    public:
      template &lt;class T, class... TArgs&gt;
      struct is_creatable;

      template &lt;
        class T
      , class TInit // type_traits::direct/type_traits::uniform
      , class TMemory // type_traits::heap/type_traits::stack
      , class... TArgs
      &gt; auto get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const;
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_creatable&lt;T, TArgs...&gt;</code></td>
<td><a href="#di_creatable">creatable</a>&lt;TArgs...></td>
<td>Verify whether <code>T</code> is creatable with <code>TArgs...</code></td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;...)</code></td>
<td><code>TInit</code> -&gt; direct/uniform, <code>TMemory</code> -&gt; heap/stack</td>
<td>Creates type <code>T</code> with <code>TArgs...</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>TMemory</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>stack</td>
</tr>
<tr>
<td>T&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>stack</td>
</tr>
<tr>
<td>T*</td>
<td>heap</td>
</tr>
<tr>
<td>const T*</td>
<td>heap</td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td>heap</td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td>heap</td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td>heap</td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td>heap</td>
</tr>
<tr>
<td><code>is_polymorphic&lt;T&gt;</code></td>
<td>heap</td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
class my_provider : public di::config {
 public:
  // this is default in di::config
  static auto provider(...) noexcept { return di::providers::stack_over_heap{}; }
};

int main() {
  auto injector = di::make_injector&lt;my_provider&gt;();
  injector.create&lt;int&gt;();                           // stack
  std::unique_ptr&lt;int&gt; i{injector.create&lt;int*&gt;()};  // heap
  (void)i;
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp"> Custom Provider Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp"> Pool Provider Example</a></li>
</ul>
<p><br /><hr /></p>
<p><a id="di_heap"></a>
--- <strong><em>di::providers::heap</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Basic provider creates objects on the heap (always).</p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace providers {
  class heap {
    public:
      template &lt;class T, class... TArgs&gt;
      struct is_creatable;

      template &lt;
        class T
      , class TInit // type_traits::direct/type_traits::uniform
      , class TMemory // type_traits::heap/type_traits::stack
      , class... TArgs
      &gt; auto get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;... args) const;
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_creatable&lt;T, TArgs...&gt;</code></td>
<td><a href="#di_creatable">creatable</a>&lt;TArgs...></td>
<td>Verify whether <code>T</code> is creatable with <code>TArgs...</code></td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>get(const TInit&amp;, const TMemory&amp;, TArgs&amp;&amp;...)</code></td>
<td><code>TInit</code> -&gt; direct/uniform, <code>TMemory</code> -&gt; heap/stack</td>
<td>Creates type <code>T</code> with <code>TArgs...</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
class my_provider : public di::config {
 public:
  static auto provider(...) noexcept { return di::providers::heap{}; }
};

int main() {
  auto injector = di::make_injector&lt;my_provider&gt;();
  injector.create&lt;int&gt;();                           // heap
  std::unique_ptr&lt;int&gt; i{injector.create&lt;int*&gt;()};  // heap
  (void)i;
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp"> Custom Provider Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp"> Pool Provider Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/providers/mocks_provider.cpp"> Mocks Provider Extension</a></li>
</ul>
<p><br /><br /><br /><hr /></p>
<h3 id="policies">Policies</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Policies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.
Policies are set up via <a href="#di_config">Configuration</a>.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
By default Boost.DI has no policies enabled.
</span></p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>template &lt;class... TPolicies&gt; requires callable&lt;TPolicies...&gt;
auto make_policies(TPolicies...) noexcept;

struct config : di::config {
  template&lt;class TInjector&gt;
  static auto policies(const TInjector&amp;) noexcept { return make_policies(...); }
};                                                                        |
                                                                          |
// policy                                                                 /
template&lt;class T, class TDependency, class.. TCtor&gt;        &lt;--------------
void operator()(const T&amp;, const TDependency&amp;, const TCtor&amp;...);
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TInjector</code></td>
<td>-</td>
<td><a href="#di_make_injector">injector</a></td>
<td>-</td>
</tr>
<tr>
<td><code>make_policies&lt;TPolicies...&gt;</code></td>
<td><a href="#di_callable">callable</a>&lt;TPolicies...></td>
<td>Creates policies</td>
<td><a href="#di_callable">callable</a> list</td>
</tr>
<tr>
<td><code>TCtor...</code></td>
<td>-</td>
<td>Constructor parameters</td>
<td>-</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><code>T</code></th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T::type</code></td>
<td>Type to be created</td>
<td><code>std::shared_ptr&lt;int&gt;</code></td>
</tr>
<tr>
<td><code>T::name</code></td>
<td>Annotation given</td>
<td><code>my_name</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><code>TDependency</code></th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TDependency::expected</code></td>
<td>Decayed 'Interface' type</td>
<td><code>interface</code></td>
</tr>
<tr>
<td><code>TDependency::given</code></td>
<td>Decayed 'Given' type</td>
<td><code>implementatoin</code></td>
</tr>
<tr>
<td><code>TDependency::name</code></td>
<td>Annotation expected</td>
<td><code>my_name</code></td>
</tr>
<tr>
<td><code>TDependency::scope</code></td>
<td><a href="#scopes">scope</a></td>
<td><a href="#di_singleton">singleton</a></td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
In order for injector to verify policies they have to be created using <a href="#di_config">config</a> and passed via <code>TConfig</code> in <a href="#di_make_injector">make_injector</a>
or set it globally via <a href="#di_config">BOOST_DI_CFG</a>.
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">
class print_types_policy : public di::config {
 public:
  static auto policies(...) noexcept {
    return di::make_policies([](auto type) {
      using arg = typename decltype(type)::type;
      std::cout &lt;&lt; typeid(arg).name() &lt;&lt; std::endl;
    });
  }
};

int main() {
  auto injector = di::make_injector&lt;print_types_policy&gt;();
  injector.create&lt;int&gt;();  // output: int
}
</code></pre>

<pre><code class="cpp">
class print_types_info_policy : public di::config {
 public:
  static auto policies(...) noexcept {
    return di::make_policies([](auto type, auto dep, BOOST_DI_UNUSED auto... ctor) {
      using T = decltype(type);
      using arg = typename T::type;
      using arg_name = typename T::name;
      using D = decltype(dep);
      using scope = typename D::scope;
      using expected = typename D::expected;
      using given = typename D::given;
      using name = typename D::name;
      auto ctor_s = sizeof...(ctor);

      std::cout &lt;&lt; ctor_s &lt;&lt; std::endl
                &lt;&lt; typeid(arg).name() &lt;&lt; std::endl
                &lt;&lt; typeid(arg_name).name() &lt;&lt; std::endl
                &lt;&lt; typeid(scope).name() &lt;&lt; std::endl
                &lt;&lt; typeid(expected).name() &lt;&lt; std::endl
                &lt;&lt; typeid(given).name() &lt;&lt; std::endl
                &lt;&lt; typeid(name).name() &lt;&lt; std::endl;
    });
  }
};

int main() {
  auto injector = di::make_injector&lt;print_types_info_policy&gt;(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;()
  );
  injector.create&lt;std::unique_ptr&lt;i1&gt;&gt;();
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp"> Custom Policy Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/types_dumper.cpp"> Types Dumper Extension</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp"> UML Dumper Extension</a></li>
</ul>
<p><br /><br /><br /><hr /></p>
<p><a id="di_constructible"></a>
--- <strong><em>di::policies::constructible</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Constructible policy limits constructor parameters to explicitly allowed.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
By default constructible policy disables creation of any constructor parameters.
</span></p>
<p><strong><em>Semantics</em></strong></p>
<pre><code>namespace policies {
  struct _ { }; // placeholder

  template&lt;class T&gt;
  struct is_bound; // true when type is bound with 'di::bind&lt;T&gt;'

  template &lt;class T&gt;
  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'

  template&lt;class T&gt;
  auto constructible(const T&amp;) noexcept;
}

namespace operators {
  template&lt;class X&gt;
  inline auto operator!(const X&amp;)

  template&lt;class X, class Y&gt;
  inline auto operator&amp;&amp;(const X&amp;, const Y&amp;);

  template&lt;class X, class Y&gt;
  inline auto operator||(const X&amp;, const Y&amp;);
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is_bound&lt;T&gt;</code></td>
<td>-</td>
<td>Verify whether type <code>T</code> is bound</td>
<td>true_type/false_type</td>
</tr>
<tr>
<td><code>is_injected&lt;T&gt;</code></td>
<td>-</td>
<td>Verify whether type <code>T</code> is injected via <a href="#BOOST_DI_INJECT">BOOST_DI_INJECT</a></td>
<td>true_type/false_type</td>
</tr>
</tbody>
</table>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
In order to allow logic operators using namespace <code>boost::di::policies::operators</code> has to be used.
</span></p>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;


class injected_and_bound : public di::config {
 public:
  static auto policies(...) noexcept {
    using namespace di::policies;
    using namespace di::policies::operators;
    return di::make_policies(
      constructible(is_injected&lt;di::_&gt;{} &amp;&amp; is_bound&lt;di::_&gt;{})
    );
  }
};

struct T {
  BOOST_DI_INJECT(T, int, double) {}
};

int main() {
  auto injector = di::make_injector&lt;injected_and_bound&gt;(
    di::bind&lt;&gt;().to(42)
  , di::bind&lt;&gt;().to(87.0)
  );

  injector.create&lt;T&gt;();
}
</code></pre>

<pre><code class="cpp">class all_must_be_bound_unless_int;
#define BOOST_DI_CFG all_must_be_bound_unless_int
#include &lt;boost/di.hpp&gt;


class all_must_be_bound_unless_int : public di::config {
 public:
  static auto policies(...) noexcept {
    using namespace di::policies;
    using namespace di::policies::operators;
    return di::make_policies(constructible(std::is_same&lt;di::_, int&gt;{} || is_bound&lt;di::_&gt;{}));
  }
};

int main() {
  assert(0 == di::make_injector().create&lt;int&gt;());
  // di::make_injector().create&lt;double&gt;(); // compile error
  assert(42.0 == make_injector(di::bind&lt;double&gt;().to(42.0)).create&lt;double&gt;());
}
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
STL type traits are supported and might be combined with Boost.DI traits in order to limit constructor types
For example, <code>std::is_same&lt;_, int&gt;{} || std::is_constructible&lt;_, int, int&gt;{} || std::is_base_of&lt;int, _&gt;{}</code>, etc...
</span></p>
<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp"> Custom Policy Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/types_dumper.cpp"> Types Dumper Extension</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp"> UML Dumper Extension</a></li>
</ul>
<p><br /><br /><br /><hr /></p>
<h3 id="concepts">Concepts</h3>
<p>Concepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.
If type doesn't satisfy the concept short and descriptive error message is provided.</p>
<p><a id="di_boundable"></a>
--- <strong><em>di::concepts::boundable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><a href="#bindings">Bindings</a> type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class TExpected, class TGiven&gt;
concept bool boundable() {
  return is_complete&lt;TExpected&gt;()
      &amp;&amp; is_complete&lt;TGiven&gt;()
      &amp;&amp; (is_base_of&lt;TExpected, TGiven&gt;() || is_convertible&lt;TGiven, TExpected&gt;());
}

template &lt;class... Ts&gt;
concept bool boundable() {
  return is_supported&lt;Ts&gt;()...
      &amp;&amp; is_movable&lt;Ts&gt;()...
      &amp;&amp; (is_base_of&lt;injector, Ts&gt;()... || is_base_of&lt;dependency, Ts&gt;()...);
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>boundable&lt;T&gt;
boundable&lt;Ts...&gt;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ts...</code></td>
<td>Bindings to be verified</td>
<td>true_type if constraint is satisfied, <code>Error</code> otherwise</td>
</tr>
</tbody>
</table>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::has_disallowed_qualifiers</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> has disallowed qualifiers</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  di::make_injector(
    di::bind&lt;int*&gt;().to(42) /** type&lt;int*&gt;::has_disallowed_qualifiers **/
  );
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_has_disallowed_qualifiers.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_has_disallowed_qualifiers.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_abstract</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is abstract</td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0, 1 -&gt; no additional info, 2 -&gt; info about why type <code>T</code> is abstract</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 2
#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

struct i {
  virtual ~i() noexcept = default;
  virtual void dummy() = 0;
};

struct impl : i {};

int main() {
  di::make_injector(
    di::bind&lt;i&gt;().to&lt;impl&gt;() /** type&lt;impl&gt;::is_abstract **/
    /** unimplemented pure virtual method 'dummy' in 'impl' **/
  );
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_not_related_to</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is not related to type <code>U</code></td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  di::make_injector(
    di::bind&lt;int&gt;().to&lt;double&gt;() /** type&lt;double&gt;::is_not_related_to&lt;int&gt; **/
  );
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_not_related_to.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_not_related_to.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_bound_more_than_once</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is bound more than once</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  di::make_injector(
    di::bind&lt;int&gt;.to(42) /** type&lt;int&gt;::is_bound_more_than_once **/
  , di::bind&lt;int&gt;.to(87) // [di::override]
  );
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::is_neither_a_dependency_nor_an_injector</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> is neither a dependency nor an injector</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() { struct dummy { };
  di::make_injector(
    dummy{} /** type&lt;dummy&gt;::is_neither_a_dependency_nor_an_injector **/
  );
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_neither_a_dependency_nor_an_injector.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_neither_a_dependency_nor_an_injector.cpp</a></li>
</ul>
<hr />
<p><a id="di_callable"></a>
--- <strong><em>di::concepts::callable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><a href="#policies">Policy</a> type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool callable() {
  return requires(T object) {
    { object(...) };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>callable&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>policy&lt;TPolicy&gt;::requires_&lt;call_operator&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>policy <code>TPolicy</code> requires a call operator</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  struct test_config : di::config {
    struct dummy {};
    static auto policies(...) { return di::make_policies(dummy{}); }
  };

  di::make_injector&lt;test_config&gt;();
  /** policy&lt;test_config::dummy&gt;::requires_&lt;call_operator&gt; **/
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/callable_requires_call_operator.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/callable_requires_call_operator.cpp</a></li>
</ul>
<hr />
<p><a id="di_configurable"></a>
--- <strong><em>di::concepts::configurable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><a href="#di_config">Configuration</a> type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool configurable() {
  return requires(T object) {
    return providable&lt;decltype(T::provider(...))&gt; &amp;&amp; callable&lt;decltype(T::policies(...))&gt;();
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>configurable&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>config&lt;TConfig&gt;::requires_&lt;provider&lt;providable_type (...)&gt;&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>config <code>T</code> requires only providable and callable types</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  struct test_config /*: di::config*/ {
    static auto policies(...) { return di::make_policies(); }
  };

  di::make_injector&lt;test_config&gt;();
  /** config&lt;test_config&gt;::requires_&lt;provider&lt;providable_type (...)&gt;&gt; **/
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/configurable_requires_callable_and_providable.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/configurable_requires_callable_and_providable.cpp</a></li>
</ul>
<hr />
<p><a id="di_creatable"></a>
--- <strong><em>di::concepts::creatable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirement for type <code>T</code> which is going to be created via <a href="#di_make_injector">injector</a><code>.create&lt;T&gt;()</code></p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>namespace type_traits {
  template&lt;class T&gt;
  using ctor_traits; // returns list of constructor parameters
}

template &lt;class T, class... TArgs&gt;
concept bool creatable() {
  return is_constructible&lt;T, TArgs...&gt;() &amp;&amp;
         is_constructible&lt;TArgs, type_traits::ctor_traits&lt;TArgs&gt;...&gt;();
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>creatable&lt;T, TArgs...&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>abstract_type&lt;T&gt;::is_not_bound</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>abstract type <code>T</code> is not bound</td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'type is not bound, did you forget to add: 'di::bind<interface>.to<implementation>()'?'</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1
#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

struct interface {
  virtual ~interface() noexcept = default;
  virtual void dummy() = 0;
};

struct example {
  explicit example(std::unique_ptr&lt;interface&gt;) {}
};

int main() {
  di::make_injector().create&lt;example&gt;(); /** creatable constraint not satisfied **/
  /** abstract_type&lt;interface&gt;::is_not_bound
   *  type is not bound, did you forget to add: 
   *   'di::bind&lt;interface&gt;.to&lt;implementation&gt;()'?
   */
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp</a></li>
</ul>
<pre><code class="cpp">#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1
#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

struct interface {
  virtual ~interface() noexcept = default;
  virtual void dummy() = 0;
};

struct example {
  explicit example(std::unique_ptr&lt;interface&gt;) {}
};

int main() {
  di::injector&lt;example&gt; injector = di::make_injector(); /** creatable constraint not satisfied **/
  /** abstract_type&lt;interface&gt;::is_not_bound
   *  type is not bound, did you forget to add: 'di::bind&lt;interface&gt;.to&lt;implementation&gt;()'?
   */
  (void)injector;
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::has_ambiguous_number_of_constructor_parameters::given&lt;Given&gt;::expected&lt;Expected&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> has ambiguous number of constructor parameters where <code>Given</code> were provided but <code>Expected</code> were expected</td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  struct T {
    BOOST_DI_INJECT_TRAITS(int, int);  // 2 parameters
    T(int, int, int, int) {}           // 4 parameters
  };

  auto injector = di::make_injector();
  injector.create&lt;T&gt;(); /** creatable constraint not satisfied **/
  /** type&lt;T&gt;::has_ambiguous_number_of_constructor_parameters::given&lt;2&gt;::expected&lt;4&gt;
   * verify BOOST_DI_INJECT_TRAITS or di::ctor_traits
   */
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_ambiguous_number_of_constructor_parameters.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_ambiguous_number_of_constructor_parameters.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>type&lt;T&gt;::has_to_many_constructor_parameters::max&lt;Max&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>type <code>T</code> has to many constructor parameter where maximum number is <code>Max</code></td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#define BOOST_DI_CFG_CTOR_LIMIT_SIZE 2  // specify max number of constructor parameters
#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  struct T {
    T(int, int, int) {}  // 3 parameters
  };

  auto injector = di::make_injector();
  injector.create&lt;T&gt;(); /** creatable constraint not satisfied **/
  /** type&lt;T&gt;::has_to_many_constructor_parameters::max&lt;2&gt;
   *  increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters
   */
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_to_many_constructor_parameters.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_to_many_constructor_parameters.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>scoped&lt;TScope&gt;::is_not_convertible_to&lt;T&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>scope <code>TScope</code> is not convertible to type <code>T</code></td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind<T>.in(scope)'?'</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  struct T {
    T(int*) {}
  };
  auto injector = di::make_injector(
    di::bind&lt;int&gt;().in(di::singleton)
  );

  injector.create&lt;T&gt;(); /** creatable constraint not satisfied **/
  /** scoped&lt;singleton&gt;::is_not_convertible_to&lt;int *&gt;
   *  scoped object is not convertible to the requested type,
   *    did you mistake the scope: 'di::bind&lt;T&gt;.in(scope)'?
   */
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_scoped_is_not_convertible_to.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_scoped_is_not_convertible_to.cpp</a></li>
</ul>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>scoped&lt;instance&gt;::is_not_convertible_to&lt;T&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>instance is not convertible to type <code>T</code></td>
</tr>
<tr>
<td><code>BOOST_DI_CFG_DIAGNOSTICS_LEVEL</code></td>
<td>0 -&gt; 'constraint not satisfied', 1 -&gt; (0) + abstract type is not bound, 2 -&gt; (1) + creation tree</td>
</tr>
<tr>
<td>Suggestion</td>
<td>'instance is not convertible to the requested type, verify binding: 'di::bind<T>.to(value)'?'</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  struct T {
    T(int&amp;) {}
  };
  auto injector = di::make_injector(
    di::bind&lt;&gt;().to(42)
  );

  injector.create&lt;T&gt;(); /** creatable constraint not satisfied **/
  /** scoped&lt;instance&gt;::is_not_convertible_to&lt;int &amp;&gt;
   *  instance is not convertible to the requested type,
   *    verify binding: 'di::bind&lt;T&gt;.to(value)'?
   */
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_instance_is_not_convertible_to.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_instance_is_not_convertible_to.cpp</a></li>
</ul>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Suggestions are not supported/displayed by MSVC-2015.
</span></p>
<hr />
<p><a id="di_providable"></a>
--- <strong><em>di::concepts::providable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><a href="#providers">Provider</a> type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>namespace type_traits {
  struct direct;
  struct uniform;
  struct stack;
  struct heap;
}

template &lt;class T&gt;
concept bool providable() {
  return requires(T object) {
    { object.template get&lt;_&gt;(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };
    { object.template is_creatable&lt;_&gt;(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>providable&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>provider&lt;TProvider&gt;::requires_&lt;get&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>provider <code>TProvider</code> requires <code>get</code> method</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() {
  struct test_config : di::config {
    struct dummy {};
    static auto provider(...) { return dummy{}; }
  };
  di::make_injector&lt;test_config&gt;(); /** provider&lt;test_config::dummy&gt;::requires_&lt;get&gt; **/
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/providable_requires_get.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/providable_requires_get.cpp</a></li>
</ul>
<hr />
<p><a id="di_scopable"></a>
--- <strong><em>di::concepts::scopable</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><a href="#scopes">Scope</a> type requirement.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>struct _ {}; // any type

template &lt;class T&gt;
concept bool scopable() {
  return requires(T) {
    typename scope&lt;_, _&gt;::is_referable;
    { T::scope&lt;_, _&gt;{}.try_create() };
    { T::scope&lt;_, _&gt;{}.create() };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>scopable&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<table>
<thead>
<tr>
<th>Error</th>
<th><code>scope&lt;TScope&gt;::requires_&lt;create&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Description</td>
<td>scope <code>TScope</code> requires <code>create</code> method</td>
</tr>
</tbody>
</table>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;

namespace di = boost::di;

int main() { struct dummy { };
  di::make_injector(
    di::bind&lt;int&gt;().in(dummy{})); /** scope&lt;dummy&gt;::requires_&lt;create&gt; **/
  );
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/scopable_requires_create.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/scopable_requires_create.cpp</a></li>
</ul>
<hr />
<h3 id="configuration">Configuration</h3>
<p><a id="di_config"></a>
--- <strong><em>di::config</em></strong> ---</p>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/di.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p><a href="#di_make_injector">Injector</a> configuration.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>struct config {
  static auto provider(...) noexcept;
  static auto policies(...) noexcept;
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>provider()</code></td>
<td><a href="#di_providable">providable</a></td>
<td>Creates provider</td>
<td><a href="#di_providable">providable</a></td>
</tr>
<tr>
<td><code>policies()</code></td>
<td><a href="#di_callable">callable</a></td>
<td>Creates policies</td>
<td><a href="#di_callable">callable</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BOOST_DI_CFG</code></td>
<td>Global configuration allows to customize provider and policies</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>di::make_injector&lt;config&gt;(...)
// or
#define BOOST_DI_CFG config // change default
di::make_injector(...)
</code></pre>
<p><strong><em>Test</em></strong></p>
<pre><code class="cpp">class all_must_be_bound_unless_int;
#define BOOST_DI_CFG all_must_be_bound_unless_int
#include &lt;boost/di.hpp&gt;


class all_must_be_bound_unless_int : public di::config {
 public:
  static auto policies(...) noexcept {
    using namespace di::policies;
    using namespace di::policies::operators;
    return di::make_policies(constructible(std::is_same&lt;di::_, int&gt;{} || is_bound&lt;di::_&gt;{}));
  }
};

int main() {
  assert(0 == di::make_injector().create&lt;int&gt;());
  // di::make_injector().create&lt;double&gt;(); // compile error
  assert(42.0 == make_injector(di::bind&lt;double&gt;().to(42.0)).create&lt;double&gt;());
}
</code></pre>

<p><strong><em>Example</em></strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/configuration.cpp"> Configuration Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp"> Custom Policy Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp"> Custom Provider Example</a></li>
</ul>
<p><br /><hr /></p>
</div>

<script src="../js/highlight.pack.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>

<div class="copyright-footer">Copyright &copy; 2016
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>

</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../try_it/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../examples/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
    <option value="https://boost-experimental.github.io/di">Theme: Boost Experimental</option>
    <option value="https://boost-experimental.github.io/di/boost" selected>Theme: Boost Classic</option>
</select>
</body>
</html>