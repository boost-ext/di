{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction\n\n\n\n\n\n\n\n\nExperimental Boost.DI\n\n\n\n\n\n\n\n\n\n\n\n\nYour C++14 header only Dependency Injection library with no dependencies (\nTry it online!\n)\n\n\nGitHub\n\n\n\n\n\n\n\n\n\n\n Latest Release: \nv1.0.1\n (May 4, 2016)\n\n\n \nDownload\n \n \n \nChangelog\n \n \n \nTutorial\n \n \n \nExamples\n\n\n\n\n\nWhat is Dependency Injection?\n\n\n\n\n\"Don't call us, we'll call you\", Hollywood principle\n\n\n\n\nDependency Injection\n (DI)\n involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.\n\n\n\nIn short, DI is all about construction!\n\n\n\n\n\"Let's make some coffee!\"\n\n\n\n\n\n\n\n\n                      No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(shared_ptr\niheater\n heater\n                              heater-\non();                   |              , unique_ptr\nipump\n pump)\n                              pump-\npump();                   |         : heater(heater), pump(move(pump))\n                              clog \n \ncoffee\n! \n endl;      |     { }\n                              heater-\noff();                  |\n                          }                                   |     void brew() {\n                                                              |         heater-\non();\n                      private:                                |         pump-\npump();\n                          shared_ptr\niheater\n heater =        |         clog \n \ncoffee!\n \n endl;\n                              make_shared\nelectric_heater\n(); |         heater-\noff();\n                                                              |     }\n                          unique_ptr\nipump\n pump =            |\n                              make_unique\nheat_pump\n(heater); | private:\n                      };                                      |     shared_ptr\niheater\n heater;\n                                                              |     unique_ptr\nipump\n pump;\n                                                              | };\n\n\n\n\nDo I use a Dependency Injection already?\n\n\n\n\nIf you are using constructors in your code then you are probably using some form of Dependency Injection too!\n\n\n\n\nclass Button {\n public:\n  Button(const std::string\n name, Position position); // Dependency Injection!\n};\n\n\n\n\nDo I use Dependency Injection correctly?\n\n\nCommon mistakes when using Dependency Injection are:\n\n\n\n\nPassing a dependency to create another dependency inside your object\n\n\n\n\nclass Model {\n public:\n   Model(int width, int height) \n     : board(std::make_unique\nBoard\n(width, height)) // Bad\n   { } \n\n   explicit Model(std::unique_ptr\nIBoard\n board) // Better\n     : board(std::move(board))\n   { } \n\n   ...\n\n private:\n  std::unique_ptr\nIBoard\n board;\n};\n\n\n\n\n\n\nCarrying dependencies\n\n\n\n\nclass Model : public Service { // Bad\n public:\n   explicit Model(std::unique_ptr\nIBoard\n board) // Bad\n     : Service(std::move(board))\n   { } \n\n   void update() {\n     Service::do_something_with_board(); // Bad\n   }\n};\n\nclass Model { // Better\n public:\n   explicit Model(std::unique_ptr\nService\n service) // Better\n     : service(std::move(service))\n   { } \n\n   void update() {\n     service.do_something_with_board(); // Better\n   }\n\n private:\n   std::unique_ptr\nService\n service;\n};\n\n\n\n\nDo I need a Dependency Injection?\n\n\n\n\nDI provides loosely coupled code (separation of business logic and object creation)\n\n\nDI provides easier to maintain code (different objects might be easily injected)\n\n\nDI provides easier to test code (fakes objects might be injected)\n\n\n\n\nDo I need a DI Framework/Library?\n\n\nDepending on a project and its scale you may put up with or without a DI library, however, in any project\na DI framework may \nfree you\n from maintaining a following (boilerplate) code...\n\n\nlogger logger_;\nrenderer renderer_;\nview view_{renderer_, logger_};\nmodel model_{logger_};\ncontroller controller_{model_, view_, logger_};\nuser user_{loger_};\napp app_{controller_, user_};\n\n\n\n\nNotice that \nORDER\n in which above dependencies are created is \nIMPORTANT\n as well as that\n\nANY\n change in \nANY\n of the objects constructor will \nREQUIRE\n a change in this code!\n\n\n\n\n Motivation Example\n\n\n\n\n\n\nRight now, imagine a project with hundreds or thousands of those dependencies and a critical issue\nwhich has to be fixed ASAP. Unfortunately, in order to fix the bug properly a new non-trivial dependency has to be\nintroduced.\n\n\nNow, imagine that a 'smart' dev figured out that it will be much easier to extend the functionally\nof already passed object and snick a workaround/'solution' this way. Such approach will possibly break a \nsingle responsibility principle\n\nof the changed object but no worries though, it might be refactored later on (meaning: most likely, the workaround will stay unchanged forever and that there are no tests).\n\n\nIf that sounds familiar\n, take a look into DI library as it helps to solve developer dilemma by taking care\nof creating all required dependencies whereas dev may focus on fixing and testing the issue.\n\n\n\n\nDI library\n, not only let you forget about maintaining dependencies creation (See \nCreate Objects Tree\n),\nbut also can help you with...\n\n\n\n\nTesting (See \nMocks Provider\n)\n\n\nSerializing (See \nSerialize\n)\n\n\nUnderstand code dependencies (See \nUML Dumper\n)\n\n\nRestrict what types and how they should be created (See \nConstructible Policy\n)\n\n\n\n\nReal Life examples?\n\n\n\n\nMatch-3 Game\n\n\nSimple web game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection / Range-V3 / Emscripten\n\n\nPlay it online!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutomatic Mocks Injector\n\n\nAutomatically create and inject required mocks to tested classes via constructors\n\n\n\n\n\n\n\n\n\n\n\n\nExperimental Boost.SML\n\n\nC++14 header only Meta State Machine library with no dependencies\n\n\n\n\n\n\n\n\nWhy Boost.DI?\n\n\n\n\nBoost.DI has none or minimal run-time overhead (See \nPerformance\n)\n\n\nBoost.DI compiles fast / \nFaster than Java-\nDagger2\n!\n (See \nBenchmarks\n)\n\n\nBoost.DI gives short diagnostic messages (See \nError messages\n)\n\n\nBoost.DI is non-intrusive (See \nInjections\n)\n\n\nBoost.DI reduces boilerplate code (See \nCreate Objects Tree\n)\n\n\nBoost.DI reduces testing effort (See \nMocks Provider\n)\n\n\nBoost.DI gives better control of what and how is created (See \nConstructible Policy\n)\n\n\nBoost.DI gives better understanding about objects hierarchy (See \nUML Dumper\n)\n\n\n\n\n+---------------------------------------------------+\n|$CXX -std=c++14 -fno-exceptions -O2 example.cpp    |\n|#Compiles in 0.4s!                                 |\n+-----------------------------+---------------------+\n                              |\n                              \\\n                                  #include \nboost/di.hpp\n +-----------+\n +-----------------------------+                                      |\n |                             |  namespace di = boost::di;     +-----+--------------------------------+\n |                             +-+                              |One header (3k lines, no dependencies)|\n |  +-----------------------+    +struct uniform {              +--------------------------------------+\n |  |Automatic conversion   |       bool \nb;\n |  |between std::shared_ptr+------+boost::shared_ptr\ninterface\n sp;\n |  |and boost::shared_ptr  |     };\n |  +-----------------------+\n |                             +-+class direct {\n |                          +--+   public:                                 +---------------------------+\n |                          |       direct(const uniform \nuniform          |ASM x86-64 == `make_unique`|\n |               +----------+            , std::shared_ptr\ninterface\n sp)  +---------------------------+\n |               |                    : uniform_(uniform)                  |push   %rax                |\n |               |                  , sp_(sp)                              |mov    $0x8,%edi           |\n |               |                  {}                                     |callq  0x4007b0 \n_Znwm@plt\n|\n |               |                                                         |movq   $0x400a10,(%rax)    |\n | +-------------+----------+       const uniform \nuniform_;               |mov    $0x8,%esi           |\n | |Inject  dependencies    |       std::shared_ptr\ninterface\n sp_;        |mov    %rax,%rdi           |\n | |using T{...} or T(...)  |     };                                       |callq  0x400960 \n_ZdlPvm\n  |\n +-+without REFLECTION or   |                                +-------------+mov    $0x1,%eax           |\n   |any changes/registration+-----+class example {           |             |pop    %rdx                |\n   |in the code!            |      public:                   +             |retq                       |\n   +------------------------+       example(std::unique_ptr\ndirect\n d      +-------------------------+-+\n                                   +--------+ , interface \nref                                       |\n                                   |          , int i)+-------------------------------------------+  +-+\n                                   |  : i_(i) {                                                   |    |\n                                   |  assert(false == d-\nuniform_.b);                             |    |\n                     +-------------+  assert(d-\nsp_.get() == d-\nuniform_.sp.get());               |    |\n                     |                assert(\nref == d-\nsp_.get());     +                         |    |\n    +----------------+---------+    }                         +         |                         |    |\n    |Deduce scope based on     |                              |         |                         |    |\n    |constructor parameter type|    auto run() const {        +---------+ +--------------------+  |    |\n    |T -\n unique               |      return i_ == 42;                  +-+The same shared_ptr,|  |    |\n    |T\n -\n singleton           |    }                                     |reference provided  |  |    |\n    |shared_ptr -\n singleton   |                                          +--------------------+  |    |\n    |unique_ptr |\n unique      |   private:                                                       |    |\n    +--------------------------+    int i_ = 0;                                                +--+    |\n                                  };                                                           |       |\n                                                                                               |       |\n                                  int main() {                          +----------------------+--+    |\n                                    auto runtime_value = false;         |ASM x86-64 == 'return 42'|    |\n                                                                        +-------------------------+    |\n                    +-------------+ auto module = [\n] {                 |mov $0x2a,%eax           |    |\n            +-------+-----------+     return di::make_injector(         |retq                     |    |\n            |Split configuration|       di::bind\n().to(runtime_value)  +----+--------------------+    |\n            |into modules       |     );                                     |                         |\n            +-------+-----------+   };                                       |                         |\n                    |         +----------------------------------------------+                         |\n                    |         |     auto injector = di::make_injector(                                 |\n                    |         |       di::bind\ninterface\n().to\nimplementation\n()+----------------------+\n                    |         +---+ , di::bind\n().to(42)\n                    +--------------+, module()                                     +---------------------+\n                                    );                                  +----------+Compile time creation|\n                                                                        +          |guarantee!           |\n                                    auto object = injector.create\nexample\n();      +---------------------+\n                                    assert(object.run());  +\n                                  }                        |\n                                                           |  +----------------------------------------+\n                                                           +--+Short compile time error messages!      |\n                                                              |For example:                            |\n                                                              |`abstract_type\ninterface\n::is_not_bound`|\n                                                              +----------------------------------------+\n\n\n\n\n\n\n UML Dumper Extension\n\n\n XML Injection Extension\n\n\n Constructible Example\n\n\n\n\n\n\nBoost.DI design goals\n\n\n\n\nBe as fast as possible (See \nPerformance\n)\n\n\nCompile as fast as possible (See \nBenchmarks\n)\n\n\nGive short and intuitive error messages (See \nError messages\n)\n\n\nGuarantee object creation at compile-time (See \nCreate Objects Tree\n)\n\n\nBe as non-intrusive as possible (See \nInjections\n)\n\n\nBe easy to extend (See \nExtensions\n)\n\n\n\n\nAcknowledgements\n\n\n\n\nThanks to Bartosz Kalinczuk for code review and tips how to improve \nBoost.DI\n\n\nThanks to Sohail Somani for support and tips how to improve \nBoost.DI\n\n\nThanks to Rob Stewart and Robert Ramey for documentation feedback and tips how to improve it", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "Experimental Boost.DI       Your C++14 header only Dependency Injection library with no dependencies ( Try it online! )  GitHub", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#what-is-dependency-injection", 
            "text": "\"Don't call us, we'll call you\", Hollywood principle   Dependency Injection  (DI)  involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.  \nIn short, DI is all about construction!   \"Let's make some coffee!\"                           No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(shared_ptr iheater  heater\n                              heater- on();                   |              , unique_ptr ipump  pump)\n                              pump- pump();                   |         : heater(heater), pump(move(pump))\n                              clog    coffee !   endl;      |     { }\n                              heater- off();                  |\n                          }                                   |     void brew() {\n                                                              |         heater- on();\n                      private:                                |         pump- pump();\n                          shared_ptr iheater  heater =        |         clog    coffee!    endl;\n                              make_shared electric_heater (); |         heater- off();\n                                                              |     }\n                          unique_ptr ipump  pump =            |\n                              make_unique heat_pump (heater); | private:\n                      };                                      |     shared_ptr iheater  heater;\n                                                              |     unique_ptr ipump  pump;\n                                                              | };", 
            "title": "What is Dependency Injection?"
        }, 
        {
            "location": "/index.html#do-i-use-a-dependency-injection-already", 
            "text": "If you are using constructors in your code then you are probably using some form of Dependency Injection too!   class Button {\n public:\n  Button(const std::string  name, Position position); // Dependency Injection!\n};", 
            "title": "Do I use a Dependency Injection already?"
        }, 
        {
            "location": "/index.html#do-i-use-dependency-injection-correctly", 
            "text": "Common mistakes when using Dependency Injection are:   Passing a dependency to create another dependency inside your object   class Model {\n public:\n   Model(int width, int height) \n     : board(std::make_unique Board (width, height)) // Bad\n   { } \n\n   explicit Model(std::unique_ptr IBoard  board) // Better\n     : board(std::move(board))\n   { } \n\n   ...\n\n private:\n  std::unique_ptr IBoard  board;\n};   Carrying dependencies   class Model : public Service { // Bad\n public:\n   explicit Model(std::unique_ptr IBoard  board) // Bad\n     : Service(std::move(board))\n   { } \n\n   void update() {\n     Service::do_something_with_board(); // Bad\n   }\n};\n\nclass Model { // Better\n public:\n   explicit Model(std::unique_ptr Service  service) // Better\n     : service(std::move(service))\n   { } \n\n   void update() {\n     service.do_something_with_board(); // Better\n   }\n\n private:\n   std::unique_ptr Service  service;\n};", 
            "title": "Do I use Dependency Injection correctly?"
        }, 
        {
            "location": "/index.html#do-i-need-a-dependency-injection", 
            "text": "DI provides loosely coupled code (separation of business logic and object creation)  DI provides easier to maintain code (different objects might be easily injected)  DI provides easier to test code (fakes objects might be injected)", 
            "title": "Do I need a Dependency Injection?"
        }, 
        {
            "location": "/index.html#do-i-need-a-di-frameworklibrary", 
            "text": "Depending on a project and its scale you may put up with or without a DI library, however, in any project\na DI framework may  free you  from maintaining a following (boilerplate) code...  logger logger_;\nrenderer renderer_;\nview view_{renderer_, logger_};\nmodel model_{logger_};\ncontroller controller_{model_, view_, logger_};\nuser user_{loger_};\napp app_{controller_, user_};  Notice that  ORDER  in which above dependencies are created is  IMPORTANT  as well as that ANY  change in  ANY  of the objects constructor will  REQUIRE  a change in this code!    Motivation Example    Right now, imagine a project with hundreds or thousands of those dependencies and a critical issue\nwhich has to be fixed ASAP. Unfortunately, in order to fix the bug properly a new non-trivial dependency has to be\nintroduced.  Now, imagine that a 'smart' dev figured out that it will be much easier to extend the functionally\nof already passed object and snick a workaround/'solution' this way. Such approach will possibly break a  single responsibility principle \nof the changed object but no worries though, it might be refactored later on (meaning: most likely, the workaround will stay unchanged forever and that there are no tests).  If that sounds familiar , take a look into DI library as it helps to solve developer dilemma by taking care\nof creating all required dependencies whereas dev may focus on fixing and testing the issue.   DI library , not only let you forget about maintaining dependencies creation (See  Create Objects Tree ),\nbut also can help you with...   Testing (See  Mocks Provider )  Serializing (See  Serialize )  Understand code dependencies (See  UML Dumper )  Restrict what types and how they should be created (See  Constructible Policy )", 
            "title": "Do I need a DI Framework/Library?"
        }, 
        {
            "location": "/index.html#real-life-examples", 
            "text": "Match-3 Game  Simple web game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection / Range-V3 / Emscripten  Play it online!         Automatic Mocks Injector  Automatically create and inject required mocks to tested classes via constructors       Experimental Boost.SML  C++14 header only Meta State Machine library with no dependencies", 
            "title": "Real Life examples?"
        }, 
        {
            "location": "/index.html#why-boostdi", 
            "text": "Boost.DI has none or minimal run-time overhead (See  Performance )  Boost.DI compiles fast /  Faster than Java- Dagger2 !  (See  Benchmarks )  Boost.DI gives short diagnostic messages (See  Error messages )  Boost.DI is non-intrusive (See  Injections )  Boost.DI reduces boilerplate code (See  Create Objects Tree )  Boost.DI reduces testing effort (See  Mocks Provider )  Boost.DI gives better control of what and how is created (See  Constructible Policy )  Boost.DI gives better understanding about objects hierarchy (See  UML Dumper )   +---------------------------------------------------+\n|$CXX -std=c++14 -fno-exceptions -O2 example.cpp    |\n|#Compiles in 0.4s!                                 |\n+-----------------------------+---------------------+\n                              |\n                              \\\n                                  #include  boost/di.hpp  +-----------+\n +-----------------------------+                                      |\n |                             |  namespace di = boost::di;     +-----+--------------------------------+\n |                             +-+                              |One header (3k lines, no dependencies)|\n |  +-----------------------+    +struct uniform {              +--------------------------------------+\n |  |Automatic conversion   |       bool  b;\n |  |between std::shared_ptr+------+boost::shared_ptr interface  sp;\n |  |and boost::shared_ptr  |     };\n |  +-----------------------+\n |                             +-+class direct {\n |                          +--+   public:                                 +---------------------------+\n |                          |       direct(const uniform  uniform          |ASM x86-64 == `make_unique`|\n |               +----------+            , std::shared_ptr interface  sp)  +---------------------------+\n |               |                    : uniform_(uniform)                  |push   %rax                |\n |               |                  , sp_(sp)                              |mov    $0x8,%edi           |\n |               |                  {}                                     |callq  0x4007b0  _Znwm@plt |\n |               |                                                         |movq   $0x400a10,(%rax)    |\n | +-------------+----------+       const uniform  uniform_;               |mov    $0x8,%esi           |\n | |Inject  dependencies    |       std::shared_ptr interface  sp_;        |mov    %rax,%rdi           |\n | |using T{...} or T(...)  |     };                                       |callq  0x400960  _ZdlPvm   |\n +-+without REFLECTION or   |                                +-------------+mov    $0x1,%eax           |\n   |any changes/registration+-----+class example {           |             |pop    %rdx                |\n   |in the code!            |      public:                   +             |retq                       |\n   +------------------------+       example(std::unique_ptr direct  d      +-------------------------+-+\n                                   +--------+ , interface  ref                                       |\n                                   |          , int i)+-------------------------------------------+  +-+\n                                   |  : i_(i) {                                                   |    |\n                                   |  assert(false == d- uniform_.b);                             |    |\n                     +-------------+  assert(d- sp_.get() == d- uniform_.sp.get());               |    |\n                     |                assert( ref == d- sp_.get());     +                         |    |\n    +----------------+---------+    }                         +         |                         |    |\n    |Deduce scope based on     |                              |         |                         |    |\n    |constructor parameter type|    auto run() const {        +---------+ +--------------------+  |    |\n    |T -  unique               |      return i_ == 42;                  +-+The same shared_ptr,|  |    |\n    |T  -  singleton           |    }                                     |reference provided  |  |    |\n    |shared_ptr -  singleton   |                                          +--------------------+  |    |\n    |unique_ptr |  unique      |   private:                                                       |    |\n    +--------------------------+    int i_ = 0;                                                +--+    |\n                                  };                                                           |       |\n                                                                                               |       |\n                                  int main() {                          +----------------------+--+    |\n                                    auto runtime_value = false;         |ASM x86-64 == 'return 42'|    |\n                                                                        +-------------------------+    |\n                    +-------------+ auto module = [ ] {                 |mov $0x2a,%eax           |    |\n            +-------+-----------+     return di::make_injector(         |retq                     |    |\n            |Split configuration|       di::bind ().to(runtime_value)  +----+--------------------+    |\n            |into modules       |     );                                     |                         |\n            +-------+-----------+   };                                       |                         |\n                    |         +----------------------------------------------+                         |\n                    |         |     auto injector = di::make_injector(                                 |\n                    |         |       di::bind interface ().to implementation ()+----------------------+\n                    |         +---+ , di::bind ().to(42)\n                    +--------------+, module()                                     +---------------------+\n                                    );                                  +----------+Compile time creation|\n                                                                        +          |guarantee!           |\n                                    auto object = injector.create example ();      +---------------------+\n                                    assert(object.run());  +\n                                  }                        |\n                                                           |  +----------------------------------------+\n                                                           +--+Short compile time error messages!      |\n                                                              |For example:                            |\n                                                              |`abstract_type interface ::is_not_bound`|\n                                                              +----------------------------------------+    UML Dumper Extension   XML Injection Extension   Constructible Example", 
            "title": "Why Boost.DI?"
        }, 
        {
            "location": "/index.html#boostdi-design-goals", 
            "text": "Be as fast as possible (See  Performance )  Compile as fast as possible (See  Benchmarks )  Give short and intuitive error messages (See  Error messages )  Guarantee object creation at compile-time (See  Create Objects Tree )  Be as non-intrusive as possible (See  Injections )  Be easy to extend (See  Extensions )", 
            "title": "Boost.DI design goals"
        }, 
        {
            "location": "/index.html#acknowledgements", 
            "text": "Thanks to Bartosz Kalinczuk for code review and tips how to improve  Boost.DI  Thanks to Sohail Somani for support and tips how to improve  Boost.DI  Thanks to Rob Stewart and Robert Ramey for documentation feedback and tips how to improve it", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/materials/index.html", 
            "text": "Dependency Injection\n\n\n\n\nhttps://www.youtube.com/embed/IKD2-MAkXyQ\n\n\n\n\n\n\nThe Clean Code Talks - Don't Look For Things!\n\n\n\n\nhttps://www.youtube.com/embed/RlfLCWKxHJ0\n\n\n\n\n\n\nC++Now 2016: \nC++14 Dependency Injection Library (Boost.DI)\n\n\n\n\nhttps://www.youtube.com/embed/comZthFv3PM\n\n\nSlides\n\n\n\n\n\n\nA New Type of dependency injection\n\n\n\n\nhttp://www.youtube.com/embed/oK_XtfXPkqw\n\n\n\n\n\n\nThe Future of Dependency Injection with Dagger 2\n\n\n\n\nhttps://www.youtube.com/embed/plK0zyRLIP8", 
            "title": "Materials/Videos"
        }, 
        {
            "location": "/overview/index.html", 
            "text": "Quick Start\n\n\n\n\nGet \nboost/di.hpp\n header\n\n\n\n\nwget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp\n\n\n\n\n\n\nInclude the header and define \ndi\n namespace alias\n\n\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\n\n\nCompile with C++14 support\n\n\n\n\n$CXX -std=c++14 ...\n\n\n\n\n\n\nTo run tests\n\n\n\n\ngit clone https://github.com/boost-experimental/di \n cd di \n make\n\n\n\n\nDependencies\n\n\n\n\nNo external dependencies are required (neither STL nor Boost)\n\n\n\n\nSupported/Tested compilers\n\n\n\n\nClang-3.4+\n\n\nGCC-5.2+\n\n\nMSVC-2015+\n\n\n\n\nConfiguration\n\n\n\n\n\n\n\n\nMacro\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_VERSION\n\n\nCurrent version of Boost.DI (ex. 1'0'0)\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies (See \nConfig\n)\n\n\n\n\n\n\nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n\n\nLimits number of allowed constructor parameters [0-10, default=10] (See \nInjections\n)\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\nGives more information with error messages (See \nError messages\n)\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_BEGIN\n\n\nnamespace boost { namespace di { inline namespace v_1_0_0 {\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_END\n\n\n}}}\n\n\n\n\n\n\n\n\nException Safety\n\n\n\n\nBoost.DI is not using exceptions internally and therefore might be compiled with \n-fno-exceptions\n.\n\n\nCheck \nUser Guide\n to verify which API's are marked \nnoexcept\n.\n\n\n\n\nThread Safety\n\n\n\n\nBoost.DI is thread safe.\n\n\n\n\nDesign\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBindings\n\n\nDSL to create dependencies representation which will be used by core to resolve types\n\n\n\n\n\n\nScopes\n\n\nResponsible for maintain objects life time\n\n\n\n\n\n\nProviders\n\n\nResponsible for providing object instance\n\n\n\n\n\n\nPolicies\n\n\nCompile-time limitations for types / Run-time types vistor\n\n\n\n\n\n\nConfig\n\n\nConfiguration for \nPolicies\n and \nProviders\n\n\n\n\n\n\nCore\n\n\nResponsible for resolving requested types (implementation detail)\n\n\n\n\n\n\nWrappers\n\n\nResponsible for conversion to required type (implementation detail)\n\n\n\n\n\n\n\n\n\n* In a nutshell\n\n\nstruct direct; // T(...)\nstruct uniform; // T{...}\n\ntemplate\nclass T, class... TArgs\n is_braces_constructible; // type T is constructible using T{...}\ntemplate\nclass T, class... TArgs\n is_constructible; // Type T is constructible using T(...)\n\ntemplate\nclass T\n is_injectable; // Type T uses BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS\n\ntemplate\nclass TConfig, class... TBindings\n // For Example, TBindings = { di::bind\nInterface\n.to\nImplementation\n }\nstruct core::injector : TBindings... {\n  using config = TConfig;\n  using deps = TBindings...;\n\n  template\nclass T\n // For example, T = Interface\n  auto create() const noexcept {\n    TConfig::policies\nT\n()...; // verify policies\n    using Type = core::binder\nTBindings...\n().resolve\nT\n(*this); // Type = Implementation\n    return core::wrapper\nT\n{dependency.create(provider\nTInjector\n{*this}.get\nType\n())};\n  }\n};\n\ntemplate\nclass TInjector, class TConfig\n\nsturct provider {\n  template\nclass T\n auto get() const noexcept {\n    using pair\nTInitialization, TCtor...\n = decltype(ctor_traits\nTInjector, T\n());\n    return TConfig::provider().get(TInitialization{}, TCtor...);\n  }\n  const TInjector\n injector;\n};\n\ntemplate\nclass TInjector\n\nstruct any_type {\n  template\nclass T\n\n  operator T() const {\n    return injector.templte create\nT\n();\n  }\n  const TInjector\n injector;\n};\n\ntemplate\nclass TInjector, class T\n\nauto ctor_traits() {\n  if (is_injectable\nT\n() {\n    return pair\ndirect, typename T::boost_di_inject__\n{}; // BOOST_DI_INJECT(T, args...) -\n T(args...)\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i \n= 0; --i) {\n    if (is_constructible\nT, any_type\nTInjector\n...\n()) { // ... -\n i times\n      return pair\ndirect, any_type\nTInjector\n...\n{}; // T(any_type...)\n    }\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i \n= 0; --i) {\n    if (is_braces_constructible\nT, any_type\nTInjector\n...\n()) { // ... -\n i times\n      return pair\nuniform, any_type\nTInjector\n...\n{}; // T{any_type...}\n    }\n  }\n\n  return error(...);\n};\n\n\n\n\n \nNote\n\n\nAutomatic injection\n depends on template implicit conversion operator and therefore\nconversion constructors \ntemplate\nclass I\n T(I)\n are not supported and have to be injected using \nBOOST_DI_INJECT\n, \nBOOST_DI_INJECT_TRAITS\n, \ndi::inject\n or \ndi::ctor_traits\n.\n\n\n\nPerformance\n\n\n\n\nRun-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions / \ngdb -batch -ex 'file ./a.out' -ex 'disassemble main'\n\n\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector();\n  return injector.create\nint\n();\n}\n\n/**\n * ASM x86-64 (same as `return 0`)\n *\n * xor %eax,%eax\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  );\n\n  return injector.create\nint\n();\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto my_int = [] {};\n\nstruct c {\n  BOOST_DI_INJECT(c, (named = my_int) int i) : i(i) {}\n  int i = 0;\n};\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(my_int).to(42)\n  );\n\n  return injector.create\nc\n().i;\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n\n  return injector.create\nstd::unique_ptr\ninterface\n();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique\nimplementation\n()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4009f0 \n_Znwm@plt\n\n * movq   $0x400e78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nstd::unique_ptr\ninterface\n();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique\nimplementation\n()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4008e0 \n_Znwm@plt\n\n * movq   $0x400c78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto module = []() -\n di::injector\nstd::unique_ptr\ninterface\n {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nstd::unique_ptr\ninterface\n();\n}\n\n/**\n * ASM x86-64 (additional cost for type erasure)\n *\n * push   %r14\n * push   %rbx\n * push   %rax\n * mov    %rdi,%r14\n * mov    $0x18,%edi\n * callq  0x4008e0 \n_Znwm@plt\n\n * mov    %rax,%rbx\n * movq   $0x400bb0,(%rbx)\n * movq   $0x400bd0,0x8(%rbx)\n * mov    $0x8,%edi\n * callq  0x4008e0 \n_Znwm@plt\n\n * movq   $0x400cd8,(%rax)\n * mov    %rax,(%r14)\n * mov    %rbx,%rdi\n * callq  *0x8(%rbx)\n * mov    %rbx,%rdi\n * callq  0x400880 \n_ZdlPv@plt\n\n * mov    %r14,%rax\n * add    $0x8,%rsp\n * pop    %rbx\n * pop    %r14\n * retq\n */\n\n\n\n\n\n\n\nCompile-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoost.DI header\n\n\nTime [s]\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\n0.050s\n\n\n\n\n\n\n\n\nLegend:\n    ctor    = raw constructor: T(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(T, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector\nT\n configure();\n\n\n\n\n\n\n* 4248897537 instances created\n* 132 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 1862039751439806464 instances created\n* 200 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules\n\n\n\n\nError messages\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_abstract\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is abstract\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0, 1 -\n no additional info, 2 -\n info about why type \nT\n is abstract\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 2\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct i {\n  virtual ~i() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct impl : i {};\n\nint main() {\n  di::make_injector(\n    di::bind\ni\n().to\nimpl\n() /** type\nimpl\n::is_abstract **/\n    /** unimplemented pure virtual method 'dummy' in 'impl' **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_bound_more_than_once\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is bound more than once\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind\nint\n.to(42) /** type\nint\n::is_bound_more_than_once **/\n  , di::bind\nint\n.to(87) // [di::override]\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\nabstract_type\nT\n::is_not_bound\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nconfig \nT\n requires only providable and callable types\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'type is not bound, did you forget to add: 'di::bind\n.to\n()'?'\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr\ninterface\n) {}\n};\n\nint main() {\n  di::make_injector().create\nexample\n(); /** creatable constraint not satisfied **/\n  /** abstract_type\ninterface\n::is_not_bound\n   *  type is not bound, did you forget to add: \n   *   'di::bind\ninterface\n.to\nimplementation\n()'?\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr\ninterface\n) {}\n};\n\nint main() {\n  di::injector\nexample\n injector = di::make_injector(); /** creatable constraint not satisfied **/\n  /** abstract_type\ninterface\n::is_not_bound\n   *  type is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n   */\n  (void)injector;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/index.html#quick-start", 
            "text": "Get  boost/di.hpp  header   wget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp   Include the header and define  di  namespace alias   #include  boost/di.hpp \nnamespace di = boost::di;   Compile with C++14 support   $CXX -std=c++14 ...   To run tests   git clone https://github.com/boost-experimental/di   cd di   make", 
            "title": "Quick Start"
        }, 
        {
            "location": "/overview/index.html#dependencies", 
            "text": "No external dependencies are required (neither STL nor Boost)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/overview/index.html#supportedtested-compilers", 
            "text": "Clang-3.4+  GCC-5.2+  MSVC-2015+", 
            "title": "Supported/Tested compilers"
        }, 
        {
            "location": "/overview/index.html#configuration", 
            "text": "Macro  Description      BOOST_DI_VERSION  Current version of Boost.DI (ex. 1'0'0)    BOOST_DI_CFG  Global configuration allows to customize provider and policies (See  Config )    BOOST_DI_CFG_CTOR_LIMIT_SIZE  Limits number of allowed constructor parameters [0-10, default=10] (See  Injections )    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  Gives more information with error messages (See  Error messages )    BOOST_DI_NAMESPACE_BEGIN  namespace boost { namespace di { inline namespace v_1_0_0 {    BOOST_DI_NAMESPACE_END  }}}", 
            "title": "Configuration"
        }, 
        {
            "location": "/overview/index.html#exception-safety", 
            "text": "Boost.DI is not using exceptions internally and therefore might be compiled with  -fno-exceptions .  Check  User Guide  to verify which API's are marked  noexcept .", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/overview/index.html#thread-safety", 
            "text": "Boost.DI is thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/overview/index.html#design", 
            "text": "Component  Description      Bindings  DSL to create dependencies representation which will be used by core to resolve types    Scopes  Responsible for maintain objects life time    Providers  Responsible for providing object instance    Policies  Compile-time limitations for types / Run-time types vistor    Config  Configuration for  Policies  and  Providers    Core  Responsible for resolving requested types (implementation detail)    Wrappers  Responsible for conversion to required type (implementation detail)     \n* In a nutshell  struct direct; // T(...)\nstruct uniform; // T{...}\n\ntemplate class T, class... TArgs  is_braces_constructible; // type T is constructible using T{...}\ntemplate class T, class... TArgs  is_constructible; // Type T is constructible using T(...)\n\ntemplate class T  is_injectable; // Type T uses BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS\n\ntemplate class TConfig, class... TBindings  // For Example, TBindings = { di::bind Interface .to Implementation  }\nstruct core::injector : TBindings... {\n  using config = TConfig;\n  using deps = TBindings...;\n\n  template class T  // For example, T = Interface\n  auto create() const noexcept {\n    TConfig::policies T ()...; // verify policies\n    using Type = core::binder TBindings... ().resolve T (*this); // Type = Implementation\n    return core::wrapper T {dependency.create(provider TInjector {*this}.get Type ())};\n  }\n};\n\ntemplate class TInjector, class TConfig \nsturct provider {\n  template class T  auto get() const noexcept {\n    using pair TInitialization, TCtor...  = decltype(ctor_traits TInjector, T ());\n    return TConfig::provider().get(TInitialization{}, TCtor...);\n  }\n  const TInjector  injector;\n};\n\ntemplate class TInjector \nstruct any_type {\n  template class T \n  operator T() const {\n    return injector.templte create T ();\n  }\n  const TInjector  injector;\n};\n\ntemplate class TInjector, class T \nauto ctor_traits() {\n  if (is_injectable T () {\n    return pair direct, typename T::boost_di_inject__ {}; // BOOST_DI_INJECT(T, args...) -  T(args...)\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i  = 0; --i) {\n    if (is_constructible T, any_type TInjector ... ()) { // ... -  i times\n      return pair direct, any_type TInjector ... {}; // T(any_type...)\n    }\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i  = 0; --i) {\n    if (is_braces_constructible T, any_type TInjector ... ()) { // ... -  i times\n      return pair uniform, any_type TInjector ... {}; // T{any_type...}\n    }\n  }\n\n  return error(...);\n};    Note  Automatic injection  depends on template implicit conversion operator and therefore\nconversion constructors  template class I  T(I)  are not supported and have to be injected using  BOOST_DI_INJECT ,  BOOST_DI_INJECT_TRAITS ,  di::inject  or  di::ctor_traits .", 
            "title": "Design"
        }, 
        {
            "location": "/overview/index.html#performance", 
            "text": "Run-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions /  gdb -batch -ex 'file ./a.out' -ex 'disassemble main'       #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector();\n  return injector.create int ();\n}\n\n/**\n * ASM x86-64 (same as `return 0`)\n *\n * xor %eax,%eax\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  );\n\n  return injector.create int ();\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto my_int = [] {};\n\nstruct c {\n  BOOST_DI_INJECT(c, (named = my_int) int i) : i(i) {}\n  int i = 0;\n};\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind int ().named(my_int).to(42)\n  );\n\n  return injector.create c ().i;\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind interface ().to implementation ()\n  );\n\n  return injector.create std::unique_ptr interface ();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique implementation ()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4009f0  _Znwm@plt \n * movq   $0x400e78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind interface ().to implementation ()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create std::unique_ptr interface ();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique implementation ()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4008e0  _Znwm@plt \n * movq   $0x400c78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto module = []() -  di::injector std::unique_ptr interface  {\n  return di::make_injector(\n    di::bind interface ().to implementation ()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create std::unique_ptr interface ();\n}\n\n/**\n * ASM x86-64 (additional cost for type erasure)\n *\n * push   %r14\n * push   %rbx\n * push   %rax\n * mov    %rdi,%r14\n * mov    $0x18,%edi\n * callq  0x4008e0  _Znwm@plt \n * mov    %rax,%rbx\n * movq   $0x400bb0,(%rbx)\n * movq   $0x400bd0,0x8(%rbx)\n * mov    $0x8,%edi\n * callq  0x4008e0  _Znwm@plt \n * movq   $0x400cd8,(%rax)\n * mov    %rax,(%r14)\n * mov    %rbx,%rdi\n * callq  *0x8(%rbx)\n * mov    %rbx,%rdi\n * callq  0x400880  _ZdlPv@plt \n * mov    %r14,%rax\n * add    $0x8,%rsp\n * pop    %rbx\n * pop    %r14\n * retq\n */   Compile-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions          Boost.DI header  Time [s]      #include  boost/di.hpp  0.050s     Legend:\n    ctor    = raw constructor: T(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(T, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector T  configure();   * 4248897537 instances created\n* 132 different types\n* 10 modules    * 1862039751439806464 instances created\n* 200 different types\n* 10 modules    * 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules", 
            "title": "Performance"
        }, 
        {
            "location": "/overview/index.html#error-messages", 
            "text": "Error  type T ::is_abstract      Description  type  T  is abstract    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0, 1 -  no additional info, 2 -  info about why type  T  is abstract     #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 2\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct i {\n  virtual ~i() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct impl : i {};\n\nint main() {\n  di::make_injector(\n    di::bind i ().to impl () /** type impl ::is_abstract **/\n    /** unimplemented pure virtual method 'dummy' in 'impl' **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp      Error  type T ::is_bound_more_than_once      Description  type  T  is bound more than once     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind int .to(42) /** type int ::is_bound_more_than_once **/\n  , di::bind int .to(87) // [di::override]\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp      Error  abstract_type T ::is_not_bound      Description  config  T  requires only providable and callable types    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'type is not bound, did you forget to add: 'di::bind .to ()'?'     #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr interface ) {}\n};\n\nint main() {\n  di::make_injector().create example (); /** creatable constraint not satisfied **/\n  /** abstract_type interface ::is_not_bound\n   *  type is not bound, did you forget to add: \n   *   'di::bind interface .to implementation ()'?\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp   #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr interface ) {}\n};\n\nint main() {\n  di::injector example  injector = di::make_injector(); /** creatable constraint not satisfied **/\n  /** abstract_type interface ::is_not_bound\n   *  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'?\n   */\n  (void)injector;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp", 
            "title": "Error messages"
        }, 
        {
            "location": "/benchmarks/index.html", 
            "text": "C++ Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\nBoost.DI (\nSee Performance\n)\n\n\ndicpp\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\nVersion\n\n\n1.0.1\n\n\nHEAD\n\n\n2.0.2\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nC++11\n\n\nC++11\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\nheader only\n\n\nlibrary\n\n\n\n\n\n\nDependencies\n\n\n-\n\n\nboost system/boost thread\n\n\n-\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile/run-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors/exceptions\n\n\n\n\n\n\n\n\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\n$CXX -O2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a unique objects tree for each iteration\nTYPES: 64\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\nBaseline\n\n\nBoost.DI\n\n\ndicpp\n\n\nGoogle.Fruit\n\n\n\n\n\n\nCompilation time\n\n\n\n\n3.082s\n\n\n1m14.080s\n\n\n34.461s / FRUIT_NO_LOOP_CHECK\n\n\n\n\n\n\nExecution time\n\n\n\n\n0.002s\n\n\n-\n\n\n-\n\n\n\n\n\n\nMemory usage (stack/heap)\n\n\n\n\n1b/0b\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecutable size\n\n\n\n\n72kb\n\n\n4.4M\n\n\n5.1M\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExecution time\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMemory usage (stack/heap)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExecutable size\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make\n\n\n\n\n\n\nC++ vs Java vs C# Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\nBoost.DI\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nJava\n\n\nJava\n\n\nC#\n\n\n\n\n\n\nVersion\n\n\n1.0.1\n\n\n4.0\n\n\n2.4\n\n\n3.2\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\njar\n\n\njar\n\n\ndll\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile-time (annotation processor)\n\n\nrun-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors\n\n\nexceptions\n\n\n\n\n\n\n\n\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\n$CXX -O2/Java8/Mono4.2\n\n\n\n\n\n\n\n\n\n\n\n\nBaseline\n\n\nManual object creation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a unique objects tree for each iteration\nTYPES: 64\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7 -O2 / Java8 / Mono4.2 --aot\n\n\nBaseline\n\n\nBoost.DI\n\n\nGoogle.Fruit\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\nCompilation time\n\n\n0.063s\n\n\n0.376s\n\n\n2.329s / FRUIT_NO_LOOP_CHECK\n\n\n0.570s\n\n\n1.411s\n\n\n0.144s + 0.079s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.5K\n\n\n213K\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.002s\n\n\n0.002s\n\n\n0.037s\n\n\n0.528s\n\n\n0.157s\n\n\n1.131s\n\n\n\n\n\n\nTYPES: 128\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.082s\n\n\n0.706s\n\n\n4.375s / FRUIT_NO_LOOP_CHECK\n\n\n0.642s\n\n\n1.903s\n\n\n0.149s + 0.093s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.5K\n\n\n513K\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.002s\n\n\n0.002s\n\n\n0.074s\n\n\n0.544s\n\n\n0.210s\n\n\n2.230s\n\n\n\n\n\n\nTYPES: 256\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.131s\n\n\n1.328s\n\n\n9.641s / FRUIT_NO_LOOP_CHECK\n\n\n0.783s\n\n\n2.814s\n\n\n0.151s + 0.114s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.7K\n\n\n1.4M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.003s\n\n\n0.003s\n\n\n0.154s\n\n\n0.723s\n\n\n0.323s\n\n\n4.838s\n\n\n\n\n\n\nTYPES: 512\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.215s\n\n\n2.459s\n\n\n23.924s / FRUIT_NO_LOOP_CHECK\n\n\n1.054s\n\n\n4.231s\n\n\n0.157s + 0.161\n\n\n\n\n\n\nExecutable size\n\n\n8.2K\n\n\n13K\n\n\n4.2M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.003s\n\n\n0.003s\n\n\n0.328s\n\n\n0.943s\n\n\n0.547s\n\n\n11.123s\n\n\n\n\n\n\nTYPES: 1024\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.402s\n\n\n4.911s\n\n\n1m9.601s / FRUIT_NO_LOOP_CHECK\n\n\n1.357s\n\n\n5.943s\n\n\n0.167s + 0.258\n\n\n\n\n\n\nExecutable size\n\n\n12K\n\n\n17K\n\n\n15M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.004s\n\n\n0.004s\n\n\n0.765s\n\n\n1.334s\n\n\n0.998s\n\n\n21.808s\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make\n\n\n\n\n\n\nUsage of C++ vs Java vs C# Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Interface\n\n\nPerformance\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\nI\n.to\nImpl\n()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nstd::unique_ptr\nI\n();\n}\n\n\n\n\n\n#include \ndi/registry.hpp\n\n#include \ndi/injector.hpp\n\n#include \ndi/constructor.hpp\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry\n r) {\n  r.add(r.type\nI\n().implementation\nImpl\n());\n}\n\nstd::unique_ptr\nI\n test() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr\nI\n object{injector.construct\nI*\n()};\n  return object;\n}\n\n\n\n\n\n#include \nfruit/fruit.h\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component\nI\n module() {\n  return fruit::createComponent()\n    .bind\nI, Impl\n();\n}\n\nstd::unique_ptr\nI\n test() {\n  fruit::Injector\nI\n injector{module()};\n  // get\nunique_ptr\n is not supported\n  std::unique_ptr\nI\n object{injector.get\nI*\n()};\n  return object;\n}\n\n\n\n\n\nimport com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n  }\n}\n\n\n\n\nimport dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  @Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n   }\n}\n\n\n\n\nusing Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind\nI\n().To\nImpl\n();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get\nI\n();\n  }\n}\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Value\n\n\nPerformance\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\n.to(42)\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nint\n();\n}\n\n\n\n\n\n#include \ndi/registry.hpp\n\n#include \ndi/injector.hpp\n\n\nvoid module(di::registry\n r) {\n  r.add(r.type\nint\n().instance(new int{42}));\n}\n\nauto test() {\n  di::injector injector;\n  injector.install(module);\n  return injector.construct\nint\n();\n}\n\n\n\n\n\n#include \nfruit/fruit.h\n\n\nauto i = 42;  // bindInstance doesn't support l-value's\n\nfruit::Component\nint\n module() {\n  return fruit::createComponent().bindInstance(i);\n}\n\nauto test() {\n  fruit::Injector\nint\n injector{module()};\n  return injector.get\nint\n();\n}\n\n\n\n\n\nimport com.google.inject.*;\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(int.class).toInstance(42);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    injector.getInstance(int.class);\n  }\n}\n\n\n\n\nimport dagger.*;\n\n@Module\nclass AppModule {\n  @Provides int provideint() { return 42; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  int build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    Dagger_AppComponent.create().build();\n  }\n}\n\n\n\n\nusing Ninject;\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind\nint\n().To(42);\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    kernel.Get\nint\n();\n  }\n}\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nMissing Bindings Error\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    // di::bind\nI\n.to\nImpl\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  std::unique_ptr\nI\n object{injector.create\nI *\n()};\n  object-\ndummy();\n}\n\n/**\n * di.cpp:32:38: warning: 'create\nI *, 0\n' is deprecated: creatable constraint not satisfied\n *   std::unique_ptr\nI\n object{injector.create\nI *\n()};\n *                                      ^\n * boost/di.hpp:2420:3: note: 'create\nI *, 0\n' has been explicitly marked deprecated here\n *   create\n *   ^\n * boost/di.hpp:871:2: error: 'boost::di::v1_0_0::concepts::abstract_type\nI\n::is_not_bound::error'\n *  error(_ = \ntype is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n);\n *  ^\n */\n\n\n\n\n#include \ndi/registry.hpp\n\n#include \ndi/injector.hpp\n\n#include \ndi/constructor.hpp\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry\n r) {\n  // r.add(r.type\nI\n().implementation\nImpl\n());\n}\n\nint main() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr\nI\n object{injector.construct\nI*\n()};\n  object-\ndummy();\n}\n\n/**\n * terminate called after throwing an instance of 'std::runtime_error'\n * what():  Requested type without corresponding provider: di::type_key\nI*, void\n.\n * Double check if the type is abstract\n */\n\n\n\n\n#include \nfruit/fruit.h\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component\nI\n module() {\n  return fruit::createComponent();\n  //.bind\nI, Impl\n();\n}\n\nint main() {\n  fruit::Injector\nI\n injector{module()};\n  std::unique_ptr\nI\n object{injector.get\nI*\n()};\n  object-\ndummy();\n}\n\n/**\n  *  In file included from fruit.cpp:1:\n  *  In file included from .fruit/include/fruit/fruit.h:25:\n  * fruit/include/fruit/impl/injection_errors.h:33:3: error: static_assert failed\n  * \nNo explicit binding nor C::Inject definition was found for T.\n\n  *  static_assert(AlwaysFalse\nT\n::value,\n  * ^             ~~~~~~~~~~~~~~~~~~~~~\n  * fruit/include/fruit/impl/component.defn.h:41:9: note: in instantiation of\n  * 'fruit::impl::NoBindingFoundError\nI\n' requested here\n  * (void)typename fruit::impl::meta::CheckIfError\ntypename Op::Result\n::type();\n  * ^\n  *  fruit.cpp:6:12: note: in instantiation of function template specialization\n  *  'fruit::Component\nI\n::Component\n\n  *    fruit::impl::meta::ConsComp\n\n  *    fruit::impl::meta::Vector\n*,\n  *    fruit::impl::meta::Vector\n,\n  *    fruit::impl::meta::Vector\n, \n  *    fruit::impl::meta::Vector\n,\n  *    fruit::impl::meta::Vector\n\n  *    \n*\n' requested here\n  *  return fruit::createComponent();\n  */\n\n\n\n\nimport com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    //bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n    object.dummy();\n  }\n}\n\n/**\n  * Exception in thread \nmain\n com.google.inject.ConfigurationException:\n  * Guice configuration errors:\n  *\n  * 1) No implementation for I was bound.\n  * while locating I\n  *\n  * 1 error\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1042)\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1001)\n  * at com.google.inject.internal.InjectorImpl.getInstance(InjectorImpl.java:1051)\n  * at guice.main(guice.java:15)\n  *\n */\n\n\n\n\nimport dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  //@Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n    object.dummy();\n   }\n}\n\n/**\n * dagger2.java:13: error: I cannot be provided without an @Provides-annotated method.\n * I build();\n *   ^\n * 1 error\n */\n\n\n\n\nusing Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    //Bind\nI\n().To\nImpl\n();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get\nI\n();\n    object-\ndummy();\n  }\n}\n\n/**\n */", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/benchmarks/index.html#c-libraries", 
            "text": "Library  Boost.DI ( See Performance )  dicpp  Google.Fruit      Version  1.0.1  HEAD  2.0.2    Language  C++14  C++11  C++11    License  Boost 1.0  Boost 1.0  Apache 2.0    Linkage  header only  header only  library    Dependencies  -  boost system/boost thread  -    Approach  compile-time  run-time  compile/run-time    Errors  compile-time errors  exceptions  compile-time errors/exceptions      Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  $CXX -O2        Create a unique objects tree for each iteration TYPES: 64    BINDINGS: 0    ITERATIONS: 1024          Clang-3.7  Baseline  Boost.DI  dicpp  Google.Fruit    Compilation time   3.082s  1m14.080s  34.461s / FRUIT_NO_LOOP_CHECK    Execution time   0.002s  -  -    Memory usage (stack/heap)   1b/0b  -  -    Executable size   72kb  4.4M  5.1M           GCC-5.2        Compilation time        Execution time        Memory usage (stack/heap)        Executable size          To run benchmarks   cd benchmark   make", 
            "title": "C++ Libraries"
        }, 
        {
            "location": "/benchmarks/index.html#c-vs-java-vs-c-libraries", 
            "text": "Library  Boost.DI  Google.Guice  Dagger2  Ninject      Language  C++14  Java  Java  C#    Version  1.0.1  4.0  2.4  3.2    License  Boost 1.0  Apache 2.0  Apache 2.0  Apache 2.0    Linkage  header only  jar  jar  dll    Approach  compile-time  run-time  compile-time (annotation processor)  run-time    Errors  compile-time errors  exceptions  compile-time errors  exceptions      Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  $CXX -O2/Java8/Mono4.2       Baseline  Manual object creation        Create a unique objects tree for each iteration TYPES: 64    BINDINGS: 0    ITERATIONS: 1024            Clang-3.7 -O2 / Java8 / Mono4.2 --aot  Baseline  Boost.DI  Google.Fruit  Google.Guice  Dagger2  Ninject    Compilation time  0.063s  0.376s  2.329s / FRUIT_NO_LOOP_CHECK  0.570s  1.411s  0.144s + 0.079s    Executable size  4.2K  8.5K  213K  -  -  -    Execution time  0.002s  0.002s  0.037s  0.528s  0.157s  1.131s    TYPES: 128    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.082s  0.706s  4.375s / FRUIT_NO_LOOP_CHECK  0.642s  1.903s  0.149s + 0.093s    Executable size  4.2K  8.5K  513K  -  -  -    Execution time  0.002s  0.002s  0.074s  0.544s  0.210s  2.230s    TYPES: 256    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.131s  1.328s  9.641s / FRUIT_NO_LOOP_CHECK  0.783s  2.814s  0.151s + 0.114s    Executable size  4.2K  8.7K  1.4M  -  -  -    Execution time  0.003s  0.003s  0.154s  0.723s  0.323s  4.838s    TYPES: 512    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.215s  2.459s  23.924s / FRUIT_NO_LOOP_CHECK  1.054s  4.231s  0.157s + 0.161    Executable size  8.2K  13K  4.2M  -  -  -    Execution time  0.003s  0.003s  0.328s  0.943s  0.547s  11.123s    TYPES: 1024    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.402s  4.911s  1m9.601s / FRUIT_NO_LOOP_CHECK  1.357s  5.943s  0.167s + 0.258    Executable size  12K  17K  15M  -  -  -    Execution time  0.004s  0.004s  0.765s  1.334s  0.998s  21.808s      To run benchmarks   cd benchmark   make", 
            "title": "C++ vs Java vs C# Libraries"
        }, 
        {
            "location": "/benchmarks/index.html#usage-of-c-vs-java-vs-c-libraries", 
            "text": "Library  Bind Interface  Performance      #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    di::bind I .to Impl ()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create std::unique_ptr I ();\n}  #include  di/registry.hpp \n#include  di/injector.hpp \n#include  di/constructor.hpp \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry  r) {\n  r.add(r.type I ().implementation Impl ());\n}\n\nstd::unique_ptr I  test() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr I  object{injector.construct I* ()};\n  return object;\n}  #include  fruit/fruit.h \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component I  module() {\n  return fruit::createComponent()\n    .bind I, Impl ();\n}\n\nstd::unique_ptr I  test() {\n  fruit::Injector I  injector{module()};\n  // get unique_ptr  is not supported\n  std::unique_ptr I  object{injector.get I* ()};\n  return object;\n}  import com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n  }\n}  import dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  @Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n   }\n}  using Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind I ().To Impl ();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get I ();\n  }\n}     Library  Bind Value  Performance      #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto module = [] {\n  return di::make_injector(\n    di::bind .to(42)\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create int ();\n}  #include  di/registry.hpp \n#include  di/injector.hpp \n\nvoid module(di::registry  r) {\n  r.add(r.type int ().instance(new int{42}));\n}\n\nauto test() {\n  di::injector injector;\n  injector.install(module);\n  return injector.construct int ();\n}  #include  fruit/fruit.h \n\nauto i = 42;  // bindInstance doesn't support l-value's\n\nfruit::Component int  module() {\n  return fruit::createComponent().bindInstance(i);\n}\n\nauto test() {\n  fruit::Injector int  injector{module()};\n  return injector.get int ();\n}  import com.google.inject.*;\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(int.class).toInstance(42);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    injector.getInstance(int.class);\n  }\n}  import dagger.*;\n\n@Module\nclass AppModule {\n  @Provides int provideint() { return 42; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  int build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    Dagger_AppComponent.create().build();\n  }\n}  using Ninject;\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind int ().To(42);\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    kernel.Get int ();\n  }\n}     Library  Missing Bindings Error      #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    // di::bind I .to Impl ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  std::unique_ptr I  object{injector.create I * ()};\n  object- dummy();\n}\n\n/**\n * di.cpp:32:38: warning: 'create I *, 0 ' is deprecated: creatable constraint not satisfied\n *   std::unique_ptr I  object{injector.create I * ()};\n *                                      ^\n * boost/di.hpp:2420:3: note: 'create I *, 0 ' has been explicitly marked deprecated here\n *   create\n *   ^\n * boost/di.hpp:871:2: error: 'boost::di::v1_0_0::concepts::abstract_type I ::is_not_bound::error'\n *  error(_ =  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'? );\n *  ^\n */  #include  di/registry.hpp \n#include  di/injector.hpp \n#include  di/constructor.hpp \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry  r) {\n  // r.add(r.type I ().implementation Impl ());\n}\n\nint main() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr I  object{injector.construct I* ()};\n  object- dummy();\n}\n\n/**\n * terminate called after throwing an instance of 'std::runtime_error'\n * what():  Requested type without corresponding provider: di::type_key I*, void .\n * Double check if the type is abstract\n */  #include  fruit/fruit.h \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component I  module() {\n  return fruit::createComponent();\n  //.bind I, Impl ();\n}\n\nint main() {\n  fruit::Injector I  injector{module()};\n  std::unique_ptr I  object{injector.get I* ()};\n  object- dummy();\n}\n\n/**\n  *  In file included from fruit.cpp:1:\n  *  In file included from .fruit/include/fruit/fruit.h:25:\n  * fruit/include/fruit/impl/injection_errors.h:33:3: error: static_assert failed\n  *  No explicit binding nor C::Inject definition was found for T. \n  *  static_assert(AlwaysFalse T ::value,\n  * ^             ~~~~~~~~~~~~~~~~~~~~~\n  * fruit/include/fruit/impl/component.defn.h:41:9: note: in instantiation of\n  * 'fruit::impl::NoBindingFoundError I ' requested here\n  * (void)typename fruit::impl::meta::CheckIfError typename Op::Result ::type();\n  * ^\n  *  fruit.cpp:6:12: note: in instantiation of function template specialization\n  *  'fruit::Component I ::Component \n  *    fruit::impl::meta::ConsComp \n  *    fruit::impl::meta::Vector *,\n  *    fruit::impl::meta::Vector ,\n  *    fruit::impl::meta::Vector , \n  *    fruit::impl::meta::Vector ,\n  *    fruit::impl::meta::Vector \n  *     * ' requested here\n  *  return fruit::createComponent();\n  */  import com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    //bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n    object.dummy();\n  }\n}\n\n/**\n  * Exception in thread  main  com.google.inject.ConfigurationException:\n  * Guice configuration errors:\n  *\n  * 1) No implementation for I was bound.\n  * while locating I\n  *\n  * 1 error\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1042)\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1001)\n  * at com.google.inject.internal.InjectorImpl.getInstance(InjectorImpl.java:1051)\n  * at guice.main(guice.java:15)\n  *\n */  import dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  //@Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n    object.dummy();\n   }\n}\n\n/**\n * dagger2.java:13: error: I cannot be provided without an @Provides-annotated method.\n * I build();\n *   ^\n * 1 error\n */  using Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    //Bind I ().To Impl ();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get I ();\n    object- dummy();\n  }\n}\n\n/**\n */", 
            "title": "Usage of C++ vs Java vs C# Libraries"
        }, 
        {
            "location": "/tutorial/index.html", 
            "text": "0. [Pre] Refactor towards DI\n\n\nIf you write a new application you can skip this step and go directly to \nstep 1\n.\nHowever, if you have a lot code which is not using DI and you wonder what can it be refactored,\nthen you are in the right place.\n\n\nBasically, there is a only one (big) step to get all benefits of Dependency Injection.\nYou have to separate creation logic from business logic, which means that your code\nshould be free of object creation inside other objects...\n\n\nclass controller {\npublic:\n  controller() : model_(new model{}) {}\n  ~controller() { delete model_; }\n  void run();\n\nprivate:\n  model* model_;\n};\n\nint main() {\n  controller controller_;\n  controller_.run();\n}\n\n\n\n\nInstead, DI approach would look like that...\n\n\nclass controller {\npublic:\n  explicit controller(model\n m) : model_(m) {}\n  void run();\n\nprivate:\n  model\n model_;\n};\n\nint main() {\n  model model_;\n  controller controller_{model_};\n  controller_.run();\n}\n\n\n\n\nSo, what happened here? We just took the responsibility of creation \nmodel\n out from the \ncontroller\n. In other words,\nwe have split the creation logic and the business logic.\n\n\nThat's basically everything you have to remember in order to create applications using DI.\nNevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,\nis NOT to pass an object into constructor if it won't be stored (\nLaw of Demeter\n).\n\n\nclass app {\npublic:\n  explicit app(model\n m) : controller_(m) {} // BAD\n  explicit app(controller\n c) : controller_(c) {} // GOOD\n\nprivate:\n  controller controller_;\n};\nclass controller {\npublic:\n  explicit controller(model\n);\n};\n\nint main() {\n  model model_;\n  app app_{model_};\n}\n\n\n\n\n1. [Basic] Create objects tree\n\n\nBefore we will get into creating objects tree, let's first create a 'dummy' example.\nIn order to do so, firstly, we have to include (one and only) \nboost/di.hpp\n header and\ndeclare a convenient \ndi\n namespace alias.\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\nThat is enough to try out \nBoost.DI\n!\n\n\nTo have a first complete and working example we just have to add \nmain\n function as usual.\n\n\nint main() {}\n\n\n\n\nand compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).\n\n\n$CXX -std=c++14 example.cpp\n\n\n\n\nCongrats, you are now ready to check out \nBoost.DI\n features!\n\n\n\n\nLet's move on to creating objects tree. Applications, usually, consists of a number of objects\nwhich have to be instantiated. For example, let's consider a simplified Model View Controller code...\n\n\n\n\nThe usual approach to create \napp\n would be following...\n\n\nrenderer renderer_;\nview view_{\n, renderer_};\nmodel model_;\ncontroller controller_{model_, view_};\nuser user_;\napp app_{controller_, user_};\n\n\n\n\nWhich is alright for a really small applications. However, it's really tedious to maintain.\nJust imagine, that we have to change something here. For instance, \nview\n may need a new object \nwindow\n\nor, even worse, we refactored the code and dependencies order has changed - yea \nORDER\n of above is important!\n\nANY\n change in these classes constructors require developer input to maintain above boilerplate code!\nNot fun, not fun at all :(\n\n\nRight now imagine that your maintain effort will be minimized almost to none. How does it sound?\nWell, that might be simply achieved with \nBoost.DI\n!\n\n\nThe same result might be achieved with one liner. Doesn't matter how big the hierarchy will be.\nWe just have to create \ninjector\n using \nmake_injector\n and create the \napp\n.\n\n\nauto app_{make_injector().create\napp\n()};\n\n\n\n\nMoreover, changes in the constructor of created objects will be handled automatically, so in our case\nwhen we add a \nwindow\n to \nview\n or change \nview\n to \nstd::shared_ptr\nview\n required effort will be\nexactly '0'. \nBoost.DI\n will take care of everything for us!\n\n\n\n\n\n\n\n\nType \nT\n\n\nIs allowed?\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\nReference with \nsingleton\n / Temporary with \nunique\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::weak_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nboost_shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\n\n\nFurthermore, there is no performance penalty for using \nBoost.DI\n (see \nPerformance\n)!\n\n\n \nNote\n\nBoost.DI can \ninject\n dependencies using direct initialization \nT(...)\n or uniform initialization \nT{...}\n for aggregate types.\n\n\n\nCheck it out yourself!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct renderer {\n  int device;\n};\n\nclass view {\n public:\n  view(std::string /*title*/, const renderer\n) {}\n};\n\nclass model {};\n\nclass controller {\n public:\n  controller(model\n, view\n) {}\n};\n\nclass user {};\n\nclass app {\n public:\n  app(controller\n, user\n) {}\n};\n\nint main() {\n  /**\n   * renderer renderer_;\n   * view view_{\n, renderer_};\n   * model model_;\n   * controller controller_{model_, view_};\n   * user user_;\n   * app app_{controller_, user_};\n   */\n\n  auto injector = di::make_injector();\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp\n\n\n\n\nCheck out also other examples. Please, notice that the diagram was also generated using \nBoost.DI\n but we will get into that a bit later.\n\n\n\n\n Hello World Example\n\n\n Automatic Injection Example\n\n\n UML Dumper Extension\n\n\n\n\n\n\n2. [Basic] First steps with bindings\n\n\nBut objects tree is not everything. A lot of classes uses interfaces or required a value to be passed.\n\nBoost.DI\n solution for this are \nbindings\n.\n\n\nFor purpose of this tutorial, let's change \nview\n class into interface \niview\n in order to support \ntext_view\n and \ngui_view\n.\n\n\nclass iview {\npublic:\n  virtual ~iview() noexcept = default;\n  virtual void update() =0;\n};\n\nclass gui_view: public iview {\npublic:\n  gui_view(std::string title, const renderer\n) {}\n  void update() override {}\n};\n\nclass text_view: public iview {\npublic:\n  void update() override {}\n};\n\n\n\n\nPlease, notice that \ntext_view\n doesn't require any constructor parameters, whilst \ngui_view\n does.\n\n\nSo, what will happen right now, when we try to create an \napp\n?\n\n\nauto app_{make_injector().create\napp\n()};\n\n\n\n\nCOMPILE error! (See also: \nError Messages\n)\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type\niview\n::is_not_bound::error'\n  error(_ = \ntype is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n);\n\n\n\n\n \nNote\n\nYou can get more info about error by increasing \nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n [0-2] value (default=1).\n\n\n\nAh, okay, we haven't bound \niview\n which means that \nBOOST.DI\n can't figure out whether we want \ntext_view\n or \ngui_view\n?\nWell, it's really simple to fix it, we just follow suggestion provided.\n\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n()\n);\n\n\n\n\nLet's try again. Yay! It's compiling.\n\n\nBut what about values? \nrenderer\n requires \ndevice\n, which, by default, was value initialized.\n\n\nstruct renderer {\n  int device;\n};\n\n\n\n\n \nNote\n\nIf you want change the default behaviour and be sure that all required dependencies are bound and not value initialized\ntake a look at \nconstructible\n policy.\n\n\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n()\n, di::bind\nint\n.to(42) // renderer device | Boost.DI can also deduce 'int' type for you -\n 'di::bind\n.to(42)'\n);\n\n\n\n\n \nNote\n\nBoost.DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved\ncorrectly. No runtime exceptions or runtime asserts, EVER!\n\n\n\nCheck it out yourself!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass iview {\n public:\n  virtual ~iview() noexcept = default;\n  virtual void update() = 0;\n};\n\nclass gui_view : public iview {\n public:\n  gui_view(std::string /*title*/, const renderer\n r) { assert(42 == r.device); }\n  void update() override {}\n};\n\nclass text_view : public iview {\n public:\n  void update() override {}\n};\n\n\nclass controller {\n public:\n  controller(model\n, iview\n) {}\n};\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\niview\n().to\ngui_view\n()\n  , di::bind\nint\n().to(42) // renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings.cpp\n\n\n\n\nGreat, but my code is more dynamic than that! I mean that I want to choose \ngui_view\n or \ntext_view\n at runtime.\n\nBoost.DI\n can handle that too!\n\n\nauto use_gui_view = ...;\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n    if (use_gui_view)\n      return injector.template create\ngui_view\n();\n    else\n      return injector.template create\ntext_view\n();\n  })\n, di::bind\n.to(42) // renderer device\n);\n\n\n\n\nNotice, that \ninjector\n was passed to lambda expression in order to create \ngui_view\n / \ntext_view\n.\nThis way \nBoost.DI\n can inject appropriate dependencies into chosen types. See \nbindings\n for more details.\n\n\nCheck it out yourself!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass user {};\n\nclass app {\n public:\n  app(controller\n, user\n) {}\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\nint\n().to(42) // renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_dynamic_bindings.cpp\n\n\n\n\nOkay, so what about the input. We have \nuser\n, however, in the real life, we will have more clients.\n\nBoost.DI\n allows multiple bindings to the same type for \narray/vector/set\n. Let's do it then!\n\n\nclass iclient {\n public:\n   virtual ~iclient() noexcept = default;\n   virtual void process() = 0;\n};\n\nclass user : public iclient {\n public:\n   void process() override {};\n};\n\nclass timer : public iclient {\n public:\n   void process() override {};\n};\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::unique_ptr\niclient\n);\n};\n\n\n\n\nAnd our bindings...\n\n\ndi::bind\niclient*[]\n.to\nuser, client\n()\n\n\n\n\nCheck it out yourself!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass user : public iclient {\n public:\n  void process() override{};\n};\n\nclass timer : public iclient {\n public:\n  void process() override{};\n};\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::unique_ptr\niclient\n v) {\n    assert(2 == v.size());\n    assert(dynamic_cast\nuser*\n(v[0].get()));\n    assert(dynamic_cast\ntimer*\n(v[1].get()));\n  }\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_multiple_bindings.cpp\n\n\n\n\nThe last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.\nWith \nBoost.DI\n you can easily do that with \noverride\n specifier.\n\n\nauto injector = di::make_injector(\n  di::bind\nint\n.to(42) // renderer device\n, di::bind\nint\n.to(123) [di::override] // override renderer device\n);\n\n\n\n\nWithout the \ndi::override\n following compilation error will occur...\n\n\nboost/di.hpp:281:3: error: static_assert failed \nconstraint not satisfied\n\nboost/di.hpp:2683:80: type\nint\n::is_bound_more_than_once\n  inline auto make_injector(TDeps... args) noexcept\n\n\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings_override.cpp\n\n\n\n\nCheck out also.\n\n\n\n\n Bindings Example\n\n\n Forward Bindings Example\n\n\n Dynamic Bindings Example\n\n\n Multiple Bindings Example\n\n\n Constructor Bindings Extension\n\n\n\n\n\n\n3. [Basic] Decide the life times\n\n\nSo far so good but where these objects are stored?\nWell, \nBoost.DI\n supports \nscopes\n which are response for maintaining the life time of created objects.\nBy default there are 4 scopes\n\n\n\n\ndeduce\n scope (default)\n\n\ninstance\n scope (bind\n.to(value) where value is maintained by the user)\n\n\nunique\n scope (one instance per request)\n\n\nsingleton\n scope (shared instance)\n\n\n\n\nBy default \ndeduce\n scope is used which means that scope is deduced based on a constructor parameter.\nFor instance, reference, shared_ptr will be deduced as \nsingleton\n scope and pointer, unique_ptr will be deduced as \nunique\n scope.\n\n\n\n\n\n\n\n\nType\n\n\nScope\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique\n (temporary) / \nsingleton\n\n\n\n\n\n\nT*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nstd::unique_ptr\n\n\nunique\n\n\n\n\n\n\nstd::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nboost::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nstd::weak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\nComing back to our example, we got quite a lot \nsingletons\n there as we just needed one instance per application life time.\nAlthough scope deduction is very useful, it's not always what we need and therefore \nBoost.DI\n allows changing the scope for given type.\n\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n().in(di::singleton) // explicitly specify singleton scope\n);\n\n\n\n\nWhat if I want to change \ngui_view\n to be a different instance per each request. Let's change the scope to \nunique\n then.\n\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n().in(di::unique)\n);\n\n\n\n\nIt's NOT compiling!\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:897:2: error: 'scoped\nscopes::unique, gui_view\n::is_not_convertible_to\niview \n::error'\n  error(_ = \nscoped object is not convertible to the requested type, did you mistake the scope: 'di::bind\nT\n.in(scope)'?\n);\n\n\n\n\nAh, reference doesn't make much sense with \nunique\n scope because it would mean that it has to be stored somewhere.\nIt would be better to use \nstd::unique_ptr\niview\n instead.\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\n\n\nHmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to\nuse \nstd::shared_ptr\n instead.\n\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::shared_ptr\niclient\n);\n};\n\n\n\n\nBut, it would be better if \ntimer\n was always created per request, although it's a \nshared_ptr\n.\nTo do so, we just need add scope when binding it, like this...\n\n\nauto injector = di::make_injector(\n  di::bind\ntimer\n.in(di::unique) // different per request\n);\n\n\n\n\nCheck out full example here.\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_decide_the_life_times.cpp\n\n\n\n\nSee also.\n\n\n\n\n Deduce Scope Example\n\n\n Scopes Example\n\n\n Eager Singletons Example\n\n\n\n\n\n\n4. [Basic] Annotations to the rescue\n\n\nAbove example are fine and dandy, nonetheless, they don't cover one important thing.\nHow \nBoost.DI\n knows which constructor to choose and what if they are ambiguous?\n\n\nWell, algorithm is very simple. The longest (most parameters), unique constructor will be chosen.\nOtherwise, \nBoost.DI\n will give up with compile time error. However, which constructor should\nbe chosen is configurable by \nBOOST_DI_INJECT\n.\n\n\nTo illustrate this, let modify \nmodel\n constructor.\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   model(int rows, int cols) { }\n};\n\n\n\n\nRight now, as expected, we get a compile time error!\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:942:4: error: 'type\nmodel\n::has_ambiguous_number_of_constructor_parameters::error'\n  error(_ = \nverify BOOST_DI_INJECT_TRAITS or di::ctor_traits\n);\n\n\n\n\nLet's fixed it using \nBOOST_DI_INJECT\n then!\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected\n};\n\n\n\n\n \nNote\n\nWe can also write \nmodel(int rows, int cols, ...)\n to get the same result.\n\n\n\nOkay, right now it compiles but, wait a minute, \n123\n (renderer device) was injected for both \nrows\n and \ncols\n!\nWell, it wasn't even closed to what we would like to, but we can fix it easily using \nnamed\n annotations.\n\n\nFirstly, we have to create names. That's easy as names are just unique objects.\n\n\nauto Rows = []{};\nauto Cols = []{};\n\n\n\n\nSecondly, we have to tell \nmodel\n constructor about it.\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected\n};\n\nmodel::model(int rows, int cols) {}\n\n\n\n\nPlease, notice that we have separated \nmodel\n constructor definition and declaration to show that definition doesn't\nrequire named annotations.\n\n\n \nNote\n\nIf you happen to use clang/gcc compiler you can use string literals instead of creating objects,\nfor example \n(named = \"Rows\"_s)\n.\n\n\n\nFinally, we have to bind our values.\n\n\nauto injector = di::make_injector(\n  di::bind\nint\n.named(Rows).to(6)\n, di::bind\nint\n.named(Cols).to(8)\n);\n\n\n\n\nThat's all.\n\n\n \nNote\n\nThe same result might be accomplished with having different types for rows and cols.\n\n\n\nFull example here.\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\nclass model {\n public:\n  model(int /*size*/, double /*precision*/) {}\n  BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols);\n};\n\nmodel::model(int rows, int cols) {\n  assert(6 == rows);\n  assert(8 == cols);\n}\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  , di::bind\nint\n().named(Rows).to(6)\n  , di::bind\nint\n().named(Cols).to(8)\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_annotations_to_the_rescue.cpp\n\n\n\n\nCheck out also.\n\n\n\n\n Constructor Injection Example\n\n\n Constructor Signature Example\n\n\n Annotations Example\n\n\n\n\n\n\n5. [Basic] Split your configuration\n\n\nBut my project has hundreds of interfaces and I would like to split my bindings into separate components.\nThere is nothing simpler than that with \nBoost.DI\n as \ninjector\n might be extended by other \ninjector\n.\n\n\nLet's split our configuration then and keep our \nmodel\n bindings separately from \napp\n bindings.\n\n\nauto model_module = [] {\n  return di::make_injector(\n    di::bind\nint\n.named(Rows).to(6)\n  , di::bind\nint\n.named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n.in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  );\n};\n\n\n\n\nAnd glue them into one injector the same way...\n\n\n  auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );\n\n\n\n\nCheck it out yourself!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto model_module = [] {\n  return di::make_injector(\n    di::bind\nint\n().named(Rows).to(6)\n  , di::bind\nint\n().named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  );\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration.cpp\n\n\n\n\nBut I would like to have a module in \ncpp\n file, how can I do that?\nSuch design might be achieved with \nBoost.DI\n using \ninjector\n and exposing given types.\nLet's refactor it then.\n\n\ndi::injector\nmodel\n model_module() {\n  return di::make_injector(\n    di::bind\nint\n.named(Rows).to(6)\n  , di::bind\nint\n.named(Cols).to(8)\n  );\n}\n\ndi::injector\napp\n app_module(const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n.in(di::unique) // different per request\n  , di::bind\niclient*[]\n.to\nuser, timer\n() // bind many clients\n  , model_module()\n  );\n}\n\n\n\n\nRight now you can easily separate definition and declaration between \nhpp\n and \ncpp\n files.\n\n\nCheck it out here!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\ndi::injector\nmodel\n model_module() {\n  return di::make_injector(\n    di::bind\nint\n().named(Rows).to(6)\n  , di::bind\nint\n().named(Cols).to(8)\n  );\n}\n\ndi::injector\napp\n app_module(const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  , model_module()\n  );\n}\n\nint main() {\n  auto use_gui_view = true;\n  auto injector = app_module(use_gui_view);\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration_expose.cpp\n\n\n\n\n \nNote\n\nYou can also expose named parameters using \ndi::injector\nBOOST_DI_EXPOSE((named = Rows) int)\n.\nDifferent variations of the same type have to be exposed explicitly using \ndi::injector\nmodel\n, std::unique_ptr\nmodel\n.\nExpose uses type erasure and therefore it has small performance overhead!\n\n\n\nMore examples.\n\n\n\n\n Modules Example\n\n\n Exposed Annotated Type Example\n\n\n Exposed Complex Types Example\n\n\n\n\n\n\nCongrats! You have finished the basic part of the tutorial.\nHopefully, you have noticed potential of DI and \nBoost.DI\n but if are still not convinced check out the \nAdvanced\n part.\n\n\n6. [Advanced] Dump/Limit your types\n\n\nIt's often a case that we would like to generate object diagram of our application in order to see code dependencies\nmore clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,\nif the responsibility for creation  objects will be given to \nBoost.DI\n we get such functionality for free.\nThe only thing we have to do is to implement how to dump our objects.\n\n\nLet's dump our dependencies using \nPlant UML\n format.\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/**\n * http://plantuml.sourceforge.net/objects.html\n * ./uml_dumper | java -jar plantuml.jar -p \n uml_dumper.png\n */\nclass uml_dumper : public di::config {\n public:\n  uml_dumper() { std::cout \n \n@startuml uml_dumper.png\n \n std::endl; }\n  ~uml_dumper() { std::cout \n \n@enduml\n \n std::endl; }\n\n  static auto policies(...) noexcept {\n    /*\ndefine `uml dumper` directly in policies configuration\n*/\n    return di::make_policies([\n](auto type) {\n      using T = decltype(type);\n      using name = typename T::name;\n      using given = typename T::given;\n\n      auto root = v[i - 1];\n      if (root != \ntypeid(nullptr)) {\n        std::cout \n \n\\\n \n root-\nname() \n \n\\\n .. \\\n \n typeid(given).name()\n                  \n ((*(name*)(0))() ? std::string(\n [\n) + (*(name*)(0))() + std::string(\n]\n) : \n) \n \n\\\n \n std::endl;\n      }\n\n      auto ctor_size = T::arity::value;\n      while (ctor_size--) {\n        v.insert((v.begin() + i), \ntypeid(given));\n      }\n      ++i;\n    });\n  }\n};\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector\numl_dumper\n(\n    di::bind\ni0\n().to\nc0\n()\n  , di::bind\nint\n().named(int_1).to(42)\n  , di::bind\nint\n().named(int_2).to(42)\n  );\n\n  /*\niterate through created objects with `types_dumper`\n*/\n  injector.create\nc3\n();\n\n  /*\noutput [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]]\n*/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp\n\n\n\n\n\n\nSee also.  \n\n\n \n Custom Policy Example\n\n\n \n Types Dumper Extension\n\n\n\n\nOn the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow\nsmart pointers and disallow raw pointers too. We may want to have a \nview\n only with const parameters being passed, etc.\n\nBoost.DI\n allows you to do so by using \nconstructible\n policy or writing a custom \npolicy\n.\n\n\nclass all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include \nboost/di.hpp\n\n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same\ndi::_, int\n{} || is_bound\ndi::_\n{}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create\nint\n());\n  // di::make_injector().create\ndouble\n(); // compile error\n  assert(42.0 == make_injector(di::bind\ndouble\n().to(42.0)).create\ndouble\n());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp\n\n\n\n\nSee also.\n\n\n\n\n Constructible Example\n\n\n\n\n\n\n7. [Advanced] Customize it\n\n\nBoost.DI\n was design having extensibility in mind. You can easily customize\n\n\n\n\nscopes\n - to have custom life time of an object\n\n\nproviders\n - to have custom way of creating objects, for example by using preallocated memory\n\n\n\n\npolicies\n - to have custom way of dumping types at run-time or limiting them at compile-time\n\n\n\n\n\n\n Custom Policy Example\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n\n\n\n\n8. [Advanced] Extend it\n\n\nAs mentioned before, \nBoost.DI\n is quite easy to extend and therefore a lot of extensions exists already.\nPlease check them out and write your own!\n\n\n\n\nConstructor Bindings\n\n\nAssisted Injection\n\n\nConcepts\n\n\nLazy\n\n\nNamed Parameters\n\n\nXML Injection\n\n\nTypes Dumper\n\n\nUML Dumper\n\n\nMocks Provider\n\n\nScoped Scope\n\n\nSession Scope\n\n\nShared Scope", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/index.html#0-pre-refactor-towards-di", 
            "text": "If you write a new application you can skip this step and go directly to  step 1 .\nHowever, if you have a lot code which is not using DI and you wonder what can it be refactored,\nthen you are in the right place.  Basically, there is a only one (big) step to get all benefits of Dependency Injection.\nYou have to separate creation logic from business logic, which means that your code\nshould be free of object creation inside other objects...  class controller {\npublic:\n  controller() : model_(new model{}) {}\n  ~controller() { delete model_; }\n  void run();\n\nprivate:\n  model* model_;\n};\n\nint main() {\n  controller controller_;\n  controller_.run();\n}  Instead, DI approach would look like that...  class controller {\npublic:\n  explicit controller(model  m) : model_(m) {}\n  void run();\n\nprivate:\n  model  model_;\n};\n\nint main() {\n  model model_;\n  controller controller_{model_};\n  controller_.run();\n}  So, what happened here? We just took the responsibility of creation  model  out from the  controller . In other words,\nwe have split the creation logic and the business logic.  That's basically everything you have to remember in order to create applications using DI.\nNevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,\nis NOT to pass an object into constructor if it won't be stored ( Law of Demeter ).  class app {\npublic:\n  explicit app(model  m) : controller_(m) {} // BAD\n  explicit app(controller  c) : controller_(c) {} // GOOD\n\nprivate:\n  controller controller_;\n};\nclass controller {\npublic:\n  explicit controller(model );\n};\n\nint main() {\n  model model_;\n  app app_{model_};\n}", 
            "title": "0. [Pre] Refactor towards DI"
        }, 
        {
            "location": "/tutorial/index.html#1-basic-create-objects-tree", 
            "text": "Before we will get into creating objects tree, let's first create a 'dummy' example.\nIn order to do so, firstly, we have to include (one and only)  boost/di.hpp  header and\ndeclare a convenient  di  namespace alias.  #include  boost/di.hpp \nnamespace di = boost::di;  That is enough to try out  Boost.DI !  To have a first complete and working example we just have to add  main  function as usual.  int main() {}  and compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).  $CXX -std=c++14 example.cpp  Congrats, you are now ready to check out  Boost.DI  features!   Let's move on to creating objects tree. Applications, usually, consists of a number of objects\nwhich have to be instantiated. For example, let's consider a simplified Model View Controller code...   The usual approach to create  app  would be following...  renderer renderer_;\nview view_{ , renderer_};\nmodel model_;\ncontroller controller_{model_, view_};\nuser user_;\napp app_{controller_, user_};  Which is alright for a really small applications. However, it's really tedious to maintain.\nJust imagine, that we have to change something here. For instance,  view  may need a new object  window \nor, even worse, we refactored the code and dependencies order has changed - yea  ORDER  of above is important! ANY  change in these classes constructors require developer input to maintain above boilerplate code!\nNot fun, not fun at all :(  Right now imagine that your maintain effort will be minimized almost to none. How does it sound?\nWell, that might be simply achieved with  Boost.DI !  The same result might be achieved with one liner. Doesn't matter how big the hierarchy will be.\nWe just have to create  injector  using  make_injector  and create the  app .  auto app_{make_injector().create app ()};  Moreover, changes in the constructor of created objects will be handled automatically, so in our case\nwhen we add a  window  to  view  or change  view  to  std::shared_ptr view  required effort will be\nexactly '0'.  Boost.DI  will take care of everything for us!     Type  T  Is allowed?  Note      T  \u2714  -    T*  \u2714  Ownership transfer!    const T*  \u2714  Ownership transfer!    T  \u2714  -    const T  \u2714  Reference with  singleton  / Temporary with  unique    T  \u2714  -    std::unique_ptr T  \u2714  -    std::shared_ptr T  \u2714  -    std::weak_ptr T  \u2714  -    boost_shared_ptr T  \u2714  -     Furthermore, there is no performance penalty for using  Boost.DI  (see  Performance )!    Note \nBoost.DI can  inject  dependencies using direct initialization  T(...)  or uniform initialization  T{...}  for aggregate types.  Check it out yourself!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct renderer {\n  int device;\n};\n\nclass view {\n public:\n  view(std::string /*title*/, const renderer ) {}\n};\n\nclass model {};\n\nclass controller {\n public:\n  controller(model , view ) {}\n};\n\nclass user {};\n\nclass app {\n public:\n  app(controller , user ) {}\n};\n\nint main() {\n  /**\n   * renderer renderer_;\n   * view view_{ , renderer_};\n   * model model_;\n   * controller controller_{model_, view_};\n   * user user_;\n   * app app_{controller_, user_};\n   */\n\n  auto injector = di::make_injector();\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp   Check out also other examples. Please, notice that the diagram was also generated using  Boost.DI  but we will get into that a bit later.    Hello World Example   Automatic Injection Example   UML Dumper Extension", 
            "title": "1. [Basic] Create objects tree"
        }, 
        {
            "location": "/tutorial/index.html#2-basic-first-steps-with-bindings", 
            "text": "But objects tree is not everything. A lot of classes uses interfaces or required a value to be passed. Boost.DI  solution for this are  bindings .  For purpose of this tutorial, let's change  view  class into interface  iview  in order to support  text_view  and  gui_view .  class iview {\npublic:\n  virtual ~iview() noexcept = default;\n  virtual void update() =0;\n};\n\nclass gui_view: public iview {\npublic:\n  gui_view(std::string title, const renderer ) {}\n  void update() override {}\n};\n\nclass text_view: public iview {\npublic:\n  void update() override {}\n};  Please, notice that  text_view  doesn't require any constructor parameters, whilst  gui_view  does.  So, what will happen right now, when we try to create an  app ?  auto app_{make_injector().create app ()};  COMPILE error! (See also:  Error Messages )  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type iview ::is_not_bound::error'\n  error(_ =  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'? );    Note \nYou can get more info about error by increasing  BOOST_DI_CFG_DIAGNOSTICS_LEVEL  [0-2] value (default=1).  Ah, okay, we haven't bound  iview  which means that  BOOST.DI  can't figure out whether we want  text_view  or  gui_view ?\nWell, it's really simple to fix it, we just follow suggestion provided.  auto injector = di::make_injector(\n  di::bind iview .to gui_view ()\n);  Let's try again. Yay! It's compiling.  But what about values?  renderer  requires  device , which, by default, was value initialized.  struct renderer {\n  int device;\n};    Note \nIf you want change the default behaviour and be sure that all required dependencies are bound and not value initialized\ntake a look at  constructible  policy.  auto injector = di::make_injector(\n  di::bind iview .to gui_view ()\n, di::bind int .to(42) // renderer device | Boost.DI can also deduce 'int' type for you -  'di::bind .to(42)'\n);    Note \nBoost.DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved\ncorrectly. No runtime exceptions or runtime asserts, EVER!  Check it out yourself!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass iview {\n public:\n  virtual ~iview() noexcept = default;\n  virtual void update() = 0;\n};\n\nclass gui_view : public iview {\n public:\n  gui_view(std::string /*title*/, const renderer  r) { assert(42 == r.device); }\n  void update() override {}\n};\n\nclass text_view : public iview {\n public:\n  void update() override {}\n};\n\n\nclass controller {\n public:\n  controller(model , iview ) {}\n};\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind iview ().to gui_view ()\n  , di::bind int ().to(42) // renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings.cpp   Great, but my code is more dynamic than that! I mean that I want to choose  gui_view  or  text_view  at runtime. Boost.DI  can handle that too!  auto use_gui_view = ...;\n\nauto injector = di::make_injector(\n  di::bind iview .to([ ](const auto  injector) -  iview  {\n    if (use_gui_view)\n      return injector.template create gui_view ();\n    else\n      return injector.template create text_view ();\n  })\n, di::bind .to(42) // renderer device\n);  Notice, that  injector  was passed to lambda expression in order to create  gui_view  /  text_view .\nThis way  Boost.DI  can inject appropriate dependencies into chosen types. See  bindings  for more details.  Check it out yourself!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass user {};\n\nclass app {\n public:\n  app(controller , user ) {}\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind int ().to(42) // renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_dynamic_bindings.cpp   Okay, so what about the input. We have  user , however, in the real life, we will have more clients. Boost.DI  allows multiple bindings to the same type for  array/vector/set . Let's do it then!  class iclient {\n public:\n   virtual ~iclient() noexcept = default;\n   virtual void process() = 0;\n};\n\nclass user : public iclient {\n public:\n   void process() override {};\n};\n\nclass timer : public iclient {\n public:\n   void process() override {};\n};\n\nclass app {\n public:\n  app(controller , std::vector std::unique_ptr iclient );\n};  And our bindings...  di::bind iclient*[] .to user, client ()  Check it out yourself!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass user : public iclient {\n public:\n  void process() override{};\n};\n\nclass timer : public iclient {\n public:\n  void process() override{};\n};\n\nclass app {\n public:\n  app(controller , std::vector std::unique_ptr iclient  v) {\n    assert(2 == v.size());\n    assert(dynamic_cast user* (v[0].get()));\n    assert(dynamic_cast timer* (v[1].get()));\n  }\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind int ().to(42) // renderer device\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_multiple_bindings.cpp   The last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.\nWith  Boost.DI  you can easily do that with  override  specifier.  auto injector = di::make_injector(\n  di::bind int .to(42) // renderer device\n, di::bind int .to(123) [di::override] // override renderer device\n);  Without the  di::override  following compilation error will occur...  boost/di.hpp:281:3: error: static_assert failed  constraint not satisfied \nboost/di.hpp:2683:80: type int ::is_bound_more_than_once\n  inline auto make_injector(TDeps... args) noexcept  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings_override.cpp   Check out also.    Bindings Example   Forward Bindings Example   Dynamic Bindings Example   Multiple Bindings Example   Constructor Bindings Extension", 
            "title": "2. [Basic] First steps with bindings"
        }, 
        {
            "location": "/tutorial/index.html#3-basic-decide-the-life-times", 
            "text": "So far so good but where these objects are stored?\nWell,  Boost.DI  supports  scopes  which are response for maintaining the life time of created objects.\nBy default there are 4 scopes   deduce  scope (default)  instance  scope (bind .to(value) where value is maintained by the user)  unique  scope (one instance per request)  singleton  scope (shared instance)   By default  deduce  scope is used which means that scope is deduced based on a constructor parameter.\nFor instance, reference, shared_ptr will be deduced as  singleton  scope and pointer, unique_ptr will be deduced as  unique  scope.     Type  Scope      T  unique    T  singleton    const T  unique  (temporary) /  singleton    T*  unique  (ownership transfer)    const T*  unique  (ownership transfer)    T  unique    std::unique_ptr  unique    std::shared_ptr  singleton    boost::shared_ptr  singleton    std::weak_ptr  singleton     Coming back to our example, we got quite a lot  singletons  there as we just needed one instance per application life time.\nAlthough scope deduction is very useful, it's not always what we need and therefore  Boost.DI  allows changing the scope for given type.  auto injector = di::make_injector(\n  di::bind iview .to gui_view ().in(di::singleton) // explicitly specify singleton scope\n);  What if I want to change  gui_view  to be a different instance per each request. Let's change the scope to  unique  then.  auto injector = di::make_injector(\n  di::bind iview .to gui_view ().in(di::unique)\n);  It's NOT compiling!  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:897:2: error: 'scoped scopes::unique, gui_view ::is_not_convertible_to iview  ::error'\n  error(_ =  scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind T .in(scope)'? );  Ah, reference doesn't make much sense with  unique  scope because it would mean that it has to be stored somewhere.\nIt would be better to use  std::unique_ptr iview  instead.     Type/Scope  unique  singleton  instance      T  \u2714  -  \u2714    T  -  \u2714  \u2714    const T  \u2714 (temporary)  \u2714  \u2714    T* (transfer ownership)  \u2714  -  -    const T*  \u2714  -  -    T  \u2714  -  \u2714    std::unique_ptr  \u2714  -  -    std::shared_ptr  \u2714  \u2714  \u2714    boost::shared_ptr  \u2714  \u2714  - / \u2714 converted to    std::weak_ptr  -  \u2714  - / \u2714 converted to     Hmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to\nuse  std::shared_ptr  instead.  class app {\n public:\n  app(controller , std::vector std::shared_ptr iclient );\n};  But, it would be better if  timer  was always created per request, although it's a  shared_ptr .\nTo do so, we just need add scope when binding it, like this...  auto injector = di::make_injector(\n  di::bind timer .in(di::unique) // different per request\n);  Check out full example here.  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_decide_the_life_times.cpp   See also.    Deduce Scope Example   Scopes Example   Eager Singletons Example", 
            "title": "3. [Basic] Decide the life times"
        }, 
        {
            "location": "/tutorial/index.html#4-basic-annotations-to-the-rescue", 
            "text": "Above example are fine and dandy, nonetheless, they don't cover one important thing.\nHow  Boost.DI  knows which constructor to choose and what if they are ambiguous?  Well, algorithm is very simple. The longest (most parameters), unique constructor will be chosen.\nOtherwise,  Boost.DI  will give up with compile time error. However, which constructor should\nbe chosen is configurable by  BOOST_DI_INJECT .  To illustrate this, let modify  model  constructor.  class model {\n public:\n   model(int size, double precision) { }\n   model(int rows, int cols) { }\n};  Right now, as expected, we get a compile time error!  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:942:4: error: 'type model ::has_ambiguous_number_of_constructor_parameters::error'\n  error(_ =  verify BOOST_DI_INJECT_TRAITS or di::ctor_traits );  Let's fixed it using  BOOST_DI_INJECT  then!  class model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected\n};    Note \nWe can also write  model(int rows, int cols, ...)  to get the same result.  Okay, right now it compiles but, wait a minute,  123  (renderer device) was injected for both  rows  and  cols !\nWell, it wasn't even closed to what we would like to, but we can fix it easily using  named  annotations.  Firstly, we have to create names. That's easy as names are just unique objects.  auto Rows = []{};\nauto Cols = []{};  Secondly, we have to tell  model  constructor about it.  class model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected\n};\n\nmodel::model(int rows, int cols) {}  Please, notice that we have separated  model  constructor definition and declaration to show that definition doesn't\nrequire named annotations.    Note \nIf you happen to use clang/gcc compiler you can use string literals instead of creating objects,\nfor example  (named = \"Rows\"_s) .  Finally, we have to bind our values.  auto injector = di::make_injector(\n  di::bind int .named(Rows).to(6)\n, di::bind int .named(Cols).to(8)\n);  That's all.    Note \nThe same result might be accomplished with having different types for rows and cols.  Full example here.  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\nclass model {\n public:\n  model(int /*size*/, double /*precision*/) {}\n  BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols);\n};\n\nmodel::model(int rows, int cols) {\n  assert(6 == rows);\n  assert(8 == cols);\n}\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  , di::bind int ().named(Rows).to(6)\n  , di::bind int ().named(Cols).to(8)\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_annotations_to_the_rescue.cpp   Check out also.    Constructor Injection Example   Constructor Signature Example   Annotations Example", 
            "title": "4. [Basic] Annotations to the rescue"
        }, 
        {
            "location": "/tutorial/index.html#5-basic-split-your-configuration", 
            "text": "But my project has hundreds of interfaces and I would like to split my bindings into separate components.\nThere is nothing simpler than that with  Boost.DI  as  injector  might be extended by other  injector .  Let's split our configuration then and keep our  model  bindings separately from  app  bindings.  auto model_module = [] {\n  return di::make_injector(\n    di::bind int .named(Rows).to(6)\n  , di::bind int .named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview .to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer .in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  );\n};  And glue them into one injector the same way...    auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );  Check it out yourself!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto model_module = [] {\n  return di::make_injector(\n    di::bind int ().named(Rows).to(6)\n  , di::bind int ().named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  );\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration.cpp   But I would like to have a module in  cpp  file, how can I do that?\nSuch design might be achieved with  Boost.DI  using  injector  and exposing given types.\nLet's refactor it then.  di::injector model  model_module() {\n  return di::make_injector(\n    di::bind int .named(Rows).to(6)\n  , di::bind int .named(Cols).to(8)\n  );\n}\n\ndi::injector app  app_module(const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview .to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer .in(di::unique) // different per request\n  , di::bind iclient*[] .to user, timer () // bind many clients\n  , model_module()\n  );\n}  Right now you can easily separate definition and declaration between  hpp  and  cpp  files.  Check it out here!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\ndi::injector model  model_module() {\n  return di::make_injector(\n    di::bind int ().named(Rows).to(6)\n  , di::bind int ().named(Cols).to(8)\n  );\n}\n\ndi::injector app  app_module(const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  , model_module()\n  );\n}\n\nint main() {\n  auto use_gui_view = true;\n  auto injector = app_module(use_gui_view);\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration_expose.cpp     Note \nYou can also expose named parameters using  di::injector BOOST_DI_EXPOSE((named = Rows) int) .\nDifferent variations of the same type have to be exposed explicitly using  di::injector model , std::unique_ptr model .\nExpose uses type erasure and therefore it has small performance overhead!  More examples.    Modules Example   Exposed Annotated Type Example   Exposed Complex Types Example    Congrats! You have finished the basic part of the tutorial.\nHopefully, you have noticed potential of DI and  Boost.DI  but if are still not convinced check out the  Advanced  part.", 
            "title": "5. [Basic] Split your configuration"
        }, 
        {
            "location": "/tutorial/index.html#6-advanced-dumplimit-your-types", 
            "text": "It's often a case that we would like to generate object diagram of our application in order to see code dependencies\nmore clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,\nif the responsibility for creation  objects will be given to  Boost.DI  we get such functionality for free.\nThe only thing we have to do is to implement how to dump our objects.  Let's dump our dependencies using  Plant UML  format.  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/**\n * http://plantuml.sourceforge.net/objects.html\n * ./uml_dumper | java -jar plantuml.jar -p   uml_dumper.png\n */\nclass uml_dumper : public di::config {\n public:\n  uml_dumper() { std::cout    @startuml uml_dumper.png    std::endl; }\n  ~uml_dumper() { std::cout    @enduml    std::endl; }\n\n  static auto policies(...) noexcept {\n    /* define `uml dumper` directly in policies configuration */\n    return di::make_policies([ ](auto type) {\n      using T = decltype(type);\n      using name = typename T::name;\n      using given = typename T::given;\n\n      auto root = v[i - 1];\n      if (root !=  typeid(nullptr)) {\n        std::cout    \\    root- name()    \\  .. \\    typeid(given).name()\n                    ((*(name*)(0))() ? std::string(  [ ) + (*(name*)(0))() + std::string( ] ) :  )    \\    std::endl;\n      }\n\n      auto ctor_size = T::arity::value;\n      while (ctor_size--) {\n        v.insert((v.begin() + i),  typeid(given));\n      }\n      ++i;\n    });\n  }\n};\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector uml_dumper (\n    di::bind i0 ().to c0 ()\n  , di::bind int ().named(int_1).to(42)\n  , di::bind int ().named(int_2).to(42)\n  );\n\n  /* iterate through created objects with `types_dumper` */\n  injector.create c3 ();\n\n  /* output [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]] */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp    See also.       Custom Policy Example     Types Dumper Extension   On the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow\nsmart pointers and disallow raw pointers too. We may want to have a  view  only with const parameters being passed, etc. Boost.DI  allows you to do so by using  constructible  policy or writing a custom  policy .  class all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include  boost/di.hpp \n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same di::_, int {} || is_bound di::_ {}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create int ());\n  // di::make_injector().create double (); // compile error\n  assert(42.0 == make_injector(di::bind double ().to(42.0)).create double ());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp   See also.    Constructible Example", 
            "title": "6. [Advanced] Dump/Limit your types"
        }, 
        {
            "location": "/tutorial/index.html#7-advanced-customize-it", 
            "text": "Boost.DI  was design having extensibility in mind. You can easily customize   scopes  - to have custom life time of an object  providers  - to have custom way of creating objects, for example by using preallocated memory   policies  - to have custom way of dumping types at run-time or limiting them at compile-time     Custom Policy Example    Custom Provider Example   Pool Provider Example", 
            "title": "7. [Advanced] Customize it"
        }, 
        {
            "location": "/tutorial/index.html#8-advanced-extend-it", 
            "text": "As mentioned before,  Boost.DI  is quite easy to extend and therefore a lot of extensions exists already.\nPlease check them out and write your own!   Constructor Bindings  Assisted Injection  Concepts  Lazy  Named Parameters  XML Injection  Types Dumper  UML Dumper  Mocks Provider  Scoped Scope  Session Scope  Shared Scope", 
            "title": "8. [Advanced] Extend it"
        }, 
        {
            "location": "/try_it/index.html", 
            "text": "#include \nboost/di.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace di = boost::di;\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n};\nstruct world : iworld {\n  world() { std::cout \n \n world!\n \n std::endl; }\n};\n\nstruct hello {\n  explicit hello(int i) {\n    assert(42 == i);\n    std::cout \n \nhello\n;\n  }\n};\n\nstruct example {\n  hello h;\n  iworld\n w;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\niworld\n().to\nworld\n()\n  , di::bind\n().to(42)\n  );\n\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/try_it.cpp", 
            "title": "Try It!"
        }, 
        {
            "location": "/user_guide/index.html", 
            "text": "Injector\n\n\ndi::make_injector\n\n\n\n\n\n\nBindings\n\n\ndi::bind\n\n\n\n\n\n\nInjections\n\n\nautomatic (default)\n\n\nBOOST_DI_INJECT\n\n\nBOOST_DI_INJECT_TRAITS\n\n\ndi::inject\n\n\ndi::ctor_traits\n\n\n\n\n\n\nAnnotations\n\n\n(named = name)\n\n\n\n\n\n\nScopes\n\n\ndi::deduce (default)\n\n\ndi::instance (di::bind\n.to(value))\n\n\ndi::singleton\n\n\ndi::unique\n\n\n\n\n\n\nModules\n\n\nBOOST_DI_EXPOSE\n\n\n\n\n\n\nProviders\n\n\ndi::providers::stack_over_heap (default)\n\n\ndi::providers::heap\n\n\n\n\n\n\nPolicies\n\n\ndi::policies::constructible\n\n\n\n\n\n\nConcepts\n\n\ndi::concepts::boundable\n\n\ndi::concepts::callable\n\n\ndi::concepts::configurable\n\n\ndi::concepts::creatable\n\n\ndi::concepts::providable\n\n\ndi::concepts::scopable\n\n\n\n\n\n\nConfiguration\n\n\ndi::config\n\n\n\n\n\n\n\n\n\n\nLet's assume all examples below include \nboost/di.hpp\n header and define a convenient \ndi\n\nnamespace alias as well as some basic interfaces and types.\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\nstruct i1 { virtual ~i1() = default; virtual void dummy1() = 0; };\nstruct i2 { virtual ~i2() = default; virtual void dummy2() = 0; };\nstruct impl1 : i1 { void dummy1() override { } };\nstruct impl2 : i2 { void dummy2() override { } };\nstruct impl : i1, i2 { void dummy1() override { } void dummy2() override { } };\n\n\n\n\nInjector\n\n\n\n\nInjector is a core component providing types creation functionality using \nbindings\n.\n\n\n--- \ndi::make_injector\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates \ninjector\n type.\n\n\nSemantics\n\n\ntemplate\nclass... TDeps\n requires boundable\nTDeps...\n\nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector\n) = default;\n  template \nclass... Ts\n // no requirements\n  injector(core::injector\nTs...\n) noexcept;\n  explicit injector(const TDeps\n...) noexcept;\n\n  template\nclass T\n requires creatable\nT\n\n  T create() const;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTDeps...\n\n\nboundable\nTDeps...>\n\n\nBindings\n to be used as configuration\n\n\n-\n\n\n\n\n\n\ncreate\nT\n()\n\n\ncreatable\nT>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType \nT\n\n\nIs allowed?\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\nReference with \nsingleton\n / Temporary with \nunique\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::weak_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nboost_shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\n\n\ntemplate\n\n  class TConfig = di::config\n, class... TBindings\n\n requires configurable\nTConfig\n \n boundable\nTBindings...\n\nauto make_injector(const TBindings\n...) noexcept;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTConfig\n\n\nconfigurable\nTConfig>\n\n\nConfiguration\n per \ninjector\n\n\n-\n\n\n\n\n\n\nmake_injector(const TBindings\n...)\n\n\nboundable\nTBindings...>\n\n\nCreates \ninjector\n with given \nBindings\n\n\ninjector\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector();\n\n  assert(0 == injector.create\nint\n());\n}\n\n\n\n\nExample\n\n\n\n\n Hello World Example\n\n\n Create Objects Tree Example\n\n\n\n\n\n\nBindings\n\n\nBindings define dependencies configuration describing what types will be created\nand what values will be passed into them.\n\n\n\n--- \ndi::bind\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nAllows to bind interface to implementation and associate value with it.\n\n\nSemantics\n\n\nstruct override; // overrides given configuration\n\nnamespace detail {\n  template\nclass I, class... Is/*any_of*/\n requires boundable\nI, Is...\n\n  struct bind {\n    bind(bind\n) noexcept = default;\n\n    template \nclass T\n requires !is_array\nI\n \n boundable\nI, T\n\n    auto to() noexcept;\n\n    template \nclass... Ts\n requires is_array\nI\n \n boundable\nTs...\n\n    auto to() noexcept;\n\n    template\nclass T\n requires boundable\nI, T\n\n    auto to(T\n) noexcept;\n\n    template\nclass TScope\n requires scopable\nTScope\n\n    auto in(const TScope\n = di::deduce) noexcept;\n\n    template\nclass TName\n // no requirements\n    auto named(const TName\n = {}) noexcept;\n\n    auto operator[](const override\n) noexcept;\n  };\n} // detail\n\ntemplate\nclass... Ts\n requires boundable\nTs...\n\ndetail::bind\nTs...\n bind{};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nI\n, \nIs...\n\n\nboundable\nI, Is...>\n\n\n'Interface' types\n\n\n-\n\n\n\n\n\n\nto\nT\n\n\nboundable\nT>\n\n\nBinds \nI, Is...\n to \nT\n type\n\n\nboundable\n\n\n\n\n\n\nto\nTs...\n\n\nboundable\nTs...>\n\n\nBinds \nI, Is...\n to \nTs...\n type\n\n\nboundable\n\n\n\n\n\n\nto(T\n)\n\n\nboundable\nT>\n\n\nBinds \nI, Is...\n to \nT\n object\n\n\nboundable\n\n\n\n\n\n\nin(const TScope\n)\n\n\nscopable\nTScope>\n\n\nBinds \nI, Is...\n in TScope`\n\n\nboundable\n\n\n\n\n\n\nnamed(const TName\n)\n\n\n-\n\n\nBinds \nI, Is...\n using \nnamed\n annotation\n\n\nboundable\n\n\n\n\n\n\noperator[](const override\n)\n\n\n-\n\n\nOverrides given binding\n\n\nboundable\n\n\n\n\n\n\n\n\n \nNote\n\nCheck out also \ninstance\n scope to read more about binding to values: \ndi::bind\n.to(value)\n.\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMultiple Interfaces\n\n\n\n\n\n\n\n\ndi::bind\nInterface1, Interface2, ...\n.to\nImplementation\n()\n\n\nBinds \nInterface1, Interface2, ...\n to \nImplementation\n using one object\n\n\n\n\n\n\nMultiple Bindings\n (std::array, std::vector, std::set)\n\n\n\n\n\n\n\n\ndi::bind\nint[]\n.to({1, 2, ...})\n\n\nBinds \nint\n to values \n1, 2, ...\n\n\n\n\n\n\ndi::bind\nInterface*[]\n.to\nImplementation1, Implementation2, ...\n()\n\n\nBinds \nInterface\n to \nImplementation1, Implementation2, ...\n\n\n\n\n\n\nDynamic Bindings\n\n\n\n\n\n\n\n\ndi::bind\nInterface\n.to([](const auto\n injector)\n{ return injector.template create\nImplementation\n()})\n\n\nAllows to bind \nInterface\n depending on a run-time condition\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  );\n\n  auto object = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(object.get()));\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  );\n\n  assert(42 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\n().to(42)\n  );\n\n  assert(42 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to\nstd::integral_constant\nint, 42\n()\n  );\n\n  assert(42 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1, i2\n().to\nimpl\n()\n  );\n\n  auto object1 = injector.create\nstd::shared_ptr\ni1\n();\n  auto object2 = injector.create\nstd::shared_ptr\ni2\n();\n  assert(dynamic_cast\nimpl*\n(object1.get()));\n  assert(dynamic_cast\nimpl*\n(object2.get()));\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().to([\n](const auto\n injector) -\n i1\n {\n      if (true)\n        return injector.template create\nimpl1\n();\n      else\n        return injector.template create\nimpl\n();\n    })\n  );\n\n  auto\n object = injector.create\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(\nobject));\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1*[]\n().to\nimpl, impl1\n()\n  );\n\n  auto v = injector.create\nstd::vector\nstd::unique_ptr\ni1\n();\n  assert(2 == v.size());\n  assert(dynamic_cast\nimpl*\n(v[0].get()));\n  assert(dynamic_cast\nimpl1*\n(v[1].get()));\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint[]\n().to({1, 2, 3}) // or int*[]\n  );\n\n  auto v = injector.create\nstd::vector\nint\n();\n  assert(3 == v.size());\n  assert(1 == v[0]);\n  assert(2 == v[1]);\n  assert(3 == v[2]);\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\nint\n().to(123) [di::override]\n  );\n\n  assert(123 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n#if defined(__cpp_variable_templates)\n      di::bind\ni1\n.to\nimpl1\n()\n#else\n      di::bind\ni1\n().to\nimpl1\n()  // no variable templates\n#endif\n          );\n\n  auto object = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(object.get()));\n}\n\n\n\n\nExample\n\n\n\n\n Bindings Example\n\n\n Forward Bindings Example\n\n\n Dynamic Bindings Example\n\n\n Multiple Bindings Example\n\n\n Constructor Bindings Extension\n\n\n\n\n\n\nInjections\n\n\nConstructor Injection\n is the most powerful of available injections.\nIt guarantees initialized state of data members. Boost.DI constructor injection is achieved without any additional work from the user.\n\n\n\n--- \nautomatic (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBoost.DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with\n\nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n or di::ctor_traits] or \ndi::inject\n.\n\n\n \nNote\n\nAutomatic constructor parameters deduction is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nSemantics\n\n\nclass T {\npublic:\n  T(auto parameter1, auto parameter2, ..., auto parameterN);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nparameter1-parameterN\n\n\n-\n\n\nN\n constructor parameter\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\nBoost.DI is not able to automatically distinguish between ambiguous constructors with the same (longest) number of parameters.\nUse \nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n or \ndi::ctor_traits\n or \ndi::inject\n to explicitly mark constructor to be injected.\n\n\n\nTest\n\n\n\nstruct T {\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  int a;     // = 0;\n  double d;  // = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  T();\n  T(int a) : a(a) {}\n  T(int a, double d) : a(a), d(d) {}  // longest will be chosen\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d, ...) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Automatic Injection Example\n\n\n Constructor Signature Example\n\n\n Lazy Extension\n\n\n XML Injection Extension\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT is a macro definition used to explicitly say Boost.DI which constructor should be used as well as to annotate types - see \nannotations\n for further reding.\nWhen class has more than one constructor Boost.DI will by default choose the one with the longest parameter list.\nIn case of constructors ambiguity, Boost.DI is not able to choose the best one.\nThen BOOST_DI_INJECT becomes handy to point which constructor should be used.\n\n\nSemantics\n\n\nstruct T {\n    BOOST_DI_INJECT(T, ...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\nClass/Struct name\n\n\n-\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\nBOOST_DI_INJECT constructor parameters is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nTest\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  BOOST_DI_INJECT(T, int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n Concepts Extension\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT_TRAITS\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.\n\n\nSemantics\n\n\nstruct T {\n  BOOST_DI_INJECT_TRAITS(...) { }\n  T(...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\nBOOST_DI_INJECT_TRAITS constructor parameters is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nTest\n\n\n\nstruct T {\n  BOOST_DI_INJECT_TRAITS(int, double);\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nclass example {\n public:\n  BOOST_DI_INJECT_TRAITS(int);\n  explicit example(int i, double d = 42.0) : i(i), d(d) {}\n\n  int i = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector();\n  auto object = injector.create\nexample\n();\n  assert(0 == object.i);\n  assert(42.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n\n\n\n\n\n--- \ndi::inject\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\ndi::inject\n informs Boost.DI about constructor parameters.\nIt's useful for generated/generic classes as it doesn't have constructor parameters size limitations.\n\n\nSemantics\n\n\nstruct T {\n  using boost_di_inject__ = di::inject\n...\n;\n  T(...) {}\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\n\ndi::inject\n has no limitations if it comes to constructor parameters, however, \nnamed\n parameters are not allowed.\nMoreover, you can replace \ndi::inject\n with any variadic type list type to remove dependency to Boost.DI.\nFor example, \ntemplate\nclass...\n struct type_list{};\n \nusing boost_di_inject__ = type_list\n...\n;\n\n\n\n\nTest\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n  using boost_di_inject__ = di::inject\nint, double\n;\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  using boost_di_inject__ = di::inject\n\n    int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n;\n\n  T(int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int) { }\n};\n\nint main() {\n  auto injector = di::make_injector();\n  injector.create\nT\n();  // compile clean\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n\n\n\n\n\n--- \ndi::ctor_traits\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\ndi::ctor_traits\n is a trait in which constructor parameters for type \nT\n might be specified.\nIt's useful for third party classes you don't have access to and which can't be created using \nautomatic\n injection.\n\n\nSemantics\n\n\nnamespace boost {\nnamespace di {\n  template \n\n  struct ctor_traits\nT\n {\n    BOOST_DI_INJECT_TRAITS(...); // or using type = di::inject\n...\n;\n  };\n}}\n\n\n\nTest\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate \n\nstruct ctor_traits\nT\n {\n  BOOST_DI_INJECT_TRAITS(int, double);\n};\n}\n}  // boost::di\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n\n\n\n\nAnnotations\n\n\nAnnotations are type properties specified in order to refer to a type by the name instead of the type it self.\nThey are useful when constructor has more than one parameter of the same type.\nFor example, \nT(int, int)\n.\n\n\n\n--- \n(named = name)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nNamed parameters are handy to distinguish different constructor parameters of the same type.\n\n\n  T(int value1, int value2);\n\n\n\n\nIn order to inject proper values into \nvalue1\n and \nvalue2\n they have to be differentiate somehow.\nBoost.DI solution for this problem are annotations.\n\n\n \nNote\n\nAnnotations might be set only when constructor is marked using \nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n.\n\n\n\nSemantics\n\n\nauto Name = []{}; // just an object\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nName\n\n\n-\n\n\nObject representing named type\n\n\n-\n\n\n\n\n\n\n\n\nExample\n\n\nBOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);\n\n\n\n \nNote\n\nImplementation of constructor doesn't require annotations, only constructor definition requires them.\n\n\n\nTest\n\n\n\nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(int1).to(42)\n  , di::bind\nint\n().named(int2).to(87)\n  );\n  {\n    auto object = injector.create\nT\n();\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n  {\n    auto object = T(42, 87);\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n}\n\n\n\n\n\nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b);\n  int a = 0;\n  int b = 0;\n};\n\nT::T(int a, int b) : a(a), b(b) {}\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(int1).to(42)\n  , di::bind\nint\n().named(int2).to(87)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}\n\n\n\n\n\nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  T(int a, int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate \n\nstruct ctor_traits\nT\n {\n  BOOST_DI_INJECT_TRAITS((named = int1) int, (named = int2) int);\n};\n}\n}  // boost::di\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(int1).to(42)\n  , di::bind\nint\n().named(int2).to(87)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}\n\n\n\n\n\nauto n1 = [] {};\nauto n2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = n1) int i1\n                   , (named = n1) int i2\n                   , (named = n2) int i3\n                   , int i4\n                   , (named = n1)std::string s)\n    : i1(i1), i2(i2), i3(i3), i4(i4), s(s) {}\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n  int i4 = 0;\n  std::string s;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(n1).to(42)\n  , di::bind\nint\n().named(n2).to(87)\n  , di::bind\nstd::string\n().named(n1).to(\nstr\n)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.i1);\n  assert(42 == object.i2);\n  assert(87 == object.i3);\n  assert(0 == object.i4);\n  assert(\nstr\n == object.s);\n}\n\n\n\n\nExample\n\n\n\n\n Annotations Example\n\n\n Named Parameters Extension\n\n\n Assisted Injection Extension\n\n\n\n\n\n\nScopes\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given, \ndeduce\n scope will be assumed.\n\n\nSemantics\n\n\ntemplate \nclass TExpected, class TGiven\n\nstruct scope {\n  template \nclass T\n\n  using is_referable;\n\n  template \nclass T, class TName, class TProvider\n\n  static auto try_create(const TProvider\n);\n\n  template \nclass T, class TName, class TProvider\n\n  auto create(const TProvider\n);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\n\n\nTest\n\n\n\nstruct custom_scope {\n  template \nclass TExpected, class\n\n  struct scope {\n    template \nclass\n\n    using is_referable = std::false_type;\n\n    template \nclass T, class, class TProvider\n\n    static auto try_create(const TProvider\n provider) -\n decltype(std::shared_ptr\nTExpected\n{provider.get()});\n\n    template \nclass T, class, class TProvider\n\n    auto create(const TProvider\n provider) {\n      return std::shared_ptr\nTExpected\n{provider.get()};\n    }\n  };\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().in(custom_scope{}).to\nimpl1\n()\n  );\n  assert(injector.create\nstd::shared_ptr\ni1\n() != injector.create\nstd::shared_ptr\ni1\n());\n}\n\n\n\n\nExample\n\n\n\n\n Custom Scope Example\n\n\n Scoped Scope Extension\n\n\n Session Scope Extension\n\n\n Shared Scope Extension\n\n\n\n\n\n\n\n--- \ndi::deduce (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nDefault scope which will be converted to one of the scopes depending on the type.\n\n\n\n\n\n\n\n\nType\n\n\nScope\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique\n (temporary) / \nsingleton\n\n\n\n\n\n\nT*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nstd::unique_ptr\n\n\nunique\n\n\n\n\n\n\nstd::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nboost::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nstd::weak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct deduce {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::deduce deduce;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nstruct T {\n  T(const std::shared_ptr\ni1\n sp, std::unique_ptr\ni2\n up, int\n i, double d) : sp(sp), up(std::move(up)), i(i), d(d) {}\n\n  std::shared_ptr\ni1\n sp; /*singleton*/\n  std::unique_ptr\ni2\n up; /*unique*/\n  int\n i;                 /*instance*/\n  double d;               /*unique*/\n};\n\nint main() {\n  auto i = 42;\n  auto injector = di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  , di::bind\nint\n().to(i)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object1 = injector.create\nstd::unique_ptr\nT\n();\n  auto object2 = injector.create\nstd::unique_ptr\nT\n();\n  assert(object1-\nsp == object2-\nsp);\n  assert(object1-\nup != object2-\nup);\n  assert(42 == object1-\ni);\n  assert(\ni == \nobject1-\ni);\n  assert(42 == object2-\ni);\n  assert(\ni == \nobject2-\ni);\n  assert(87.0 == object1-\nd);\n  assert(87.0 == object2-\nd);\n  i = 12;\n  assert(i == object2-\ni);\n  assert(\ni == \nobject2-\ni);\n}\n\n\n\n\nExample\n\n\n\n\n Deduce Scope Example\n\n\n Scopes Example\n\n\n\n\n\n\n\n--- \ndi::instance (di::bind\n.to(value))\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing values - passed externally. The life time of the object depends on the user.\nBoost.DI is not maintaining the life time of these objects, however, values and strings will be copied and managed by the library.\n\n\n\n\n\n\n\n\nType\n\n\ninstance[in] (\nbind\n.to(in)\n)\n\n\ninstance[out] (\ninjector.create\nout\n()\n)\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT*\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct instance {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto l = 42l;\n  auto b = false;\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(0)\n  , di::bind\nint\n().to(42)[di::override]\n  , di::bind\ni1\n().to(std::make_shared\nimpl\n())\n  , di::bind\nlong\n().to(l)\n  , di::bind\nshort\n().to([] { return 87; })\n  , di::bind\ni2\n().to([\n](const auto\n injector) -\n std::shared_ptr\ni2\n {\n      return b ? injector.template create\nstd::shared_ptr\nimpl2\n() : nullptr; })\n  );\n\n  assert(42 == injector.create\nint\n());\n  assert(injector.create\nstd::shared_ptr\ni1\n() == injector.create\nstd::shared_ptr\ni1\n());\n  assert(l == injector.create\nlong\n());\n  assert(\nl == \ninjector.create\nlong\n());\n  assert(87 == injector.create\nshort\n());\n  {\n    auto object = injector.create\nstd::shared_ptr\ni2\n();\n    assert(nullptr == object);\n  }\n  {\n    b = true;\n    auto object = injector.create\nstd::shared_ptr\ni2\n();\n    assert(dynamic_cast\nimpl2*\n(object.get()));\n  }\n}\n\n\n\n\nExample\n\n\n\n\n Scopes Example\n\n\n Bindings Example\n\n\n\n\n\n\n\n--- \ndi::singleton\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing shared value between all instances as well as threads.\nSingleton scope will be deduced in case of reference, \nstd::shared_ptr\n, \nboost::shared_ptr\n or \nstd::weak_ptr\n.\n\n\n \nNote\n\nSingleton scope will convert automatically between \nstd::shared_ptr\n and \nboost::shared_ptr\n if required.\n\n\n\n\n\n\n\n\n\nType\n\n\nsingleton\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\n\n\n\n\nT*\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n-\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n\u2714\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct singleton {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::singleton singleton;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().in(di::singleton).to\nimpl1\n()\n  );\n\n  assert(injector.create\nstd::shared_ptr\ni1\n() == injector.create\nstd::shared_ptr\ni1\n());\n}\n\n\n\n\nExample\n\n\n\n\n Scopes Example\n\n\n Eager Singletons Example\n\n\n\n\n\n\n\n--- \ndi::unique\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing unique/per request value. A new instance will be provided each time type will be requested.\n\n\n\n\n\n\n\n\nType\n\n\nunique\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\n\n\n\nT*\n\n\n\u2714 (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\n\u2714 (ownership transfer)\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct unique {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::unique unique;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().in(di::unique).to\nimpl1\n()\n  );\n\n  assert(injector.create\nstd::shared_ptr\ni1\n() != injector.create\nstd::shared_ptr\ni1\n());\n}\n\n\n\n\nExample\n\n\n\n\n Scopes Example\n\n\n\n\n\n\nModules\n\n\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nModules allow to split \nbindings\n configuration into smaller \ninjectors\n.\nModule might be installed by passing it into \nmake_injector\n.\n\n\nSemantics\n\n\nauto module = di::make_injector(...);\ndi::injector\nTs...\n module = di::make_injector(...);\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nauto module = di::make_injector(...)\n\n\nAll types are exposed from \nmodule\n\n\nmodule.create\nT\n()\n is allowed for any \nT\n\n\n\n\n\n\ndi::injector\nTs...\n module = di::make_injector(...)\n\n\nOnly \nTs...\n types are exposed from \nmodule\n\n\nmodule.create\nT\n()\n is allowed only for \nT\n \n= \nTs...\n\n\n\n\n\n\n\n\nTest\n\n\n\nstruct T {\n  T(std::unique_ptr\ni1\n i1, std::unique_ptr\ni2\n i2, int i) : i1_(std::move(i1)), i2_(std::move(i2)), i(i) {}\n\n  std::unique_ptr\ni1\n i1_;\n  std::unique_ptr\ni2\n i2_;\n  int i = 0;\n};\n\nauto module1 = [] {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\nint\n().to(42)\n  );\n};\n\nauto module2 = [] {\n  return di::make_injector(\n    di::bind\ni2\n().to\nimpl2\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module1(), module2());\n  auto object = injector.create\nstd::unique_ptr\nT\n();\n  assert(dynamic_cast\nimpl1*\n(object-\ni1_.get()));\n  assert(dynamic_cast\nimpl2*\n(object-\ni2_.get()));\n  assert(42 == object-\ni);\n  auto up1 = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(up1.get()));\n  auto up2 = injector.create\nstd::unique_ptr\ni2\n();\n  assert(dynamic_cast\nimpl2*\n(up2.get()));\n}\n\n\n\n\n\nstruct T {\n  T(std::shared_ptr\ni1\n i1, std::shared_ptr\ni2\n i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr\ni1\n i1_;\n  std::shared_ptr\ni2\n i2_;\n  int i;\n};\n\ndi::injector\nT\n module(const int\n i) noexcept {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  , di::bind\nint\n().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  auto object = injector.create\nT\n();\n  assert(dynamic_cast\nimpl1*\n(object.i1_.get()));\n  assert(dynamic_cast\nimpl2*\n(object.i2_.get()));\n  assert(42 == object.i);\n  // injector.create\nstd::unique_ptr\ni1\n(); // compile error\n  // injector.create\nstd::unique_ptr\ni2\n(); // compile error\n}\n\n\n\n\n\nauto module = []() -\n di::injector\nstd::unique_ptr\ni1\n, std::unique_ptr\ni2\n {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto up1 = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(up1.get()));\n  auto up2 = injector.create\nstd::unique_ptr\ni2\n();\n  assert(dynamic_cast\nimpl2*\n(up2.get()));\n}\n\n\n\n\nExample\n\n\n\n\n Modules Example\n\n\n\n\n\n\n\n--- \nBOOST_DI_EXPOSE\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_EXPOSE is a macro definition allowing to expose \nnamed\n parameters via module/\ninjector\n.\n\n\nSemantics\n\n\ndi::injector\nBOOST_DI_EXPOSE((named = Name) T), ...\n;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nName\n\n\n-\n\n\nNamed object\n\n\n-\n\n\n\n\n\n\n...\n\n\n-\n\n\nMore types to be exposed\n\n\n-\n\n\n\n\n\n\n\n\nTest\n\n\n\nauto my_name = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = my_name)std::unique_ptr\ni1\n up) : up(std::move(up)) {}\n  std::unique_ptr\ni1\n up;\n};\n\nauto module = []() -\n di::injector\nBOOST_DI_EXPOSE((named = my_name)std::unique_ptr\ni1\n)\n {\n  return di::make_injector(\n    di::bind\ni1\n().named(my_name).to\nimpl1\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto object = injector.create\nstd::unique_ptr\nT\n();\n  assert(dynamic_cast\nimpl1*\n(object-\nup.get()));\n}\n\n\n\n\n\nstruct T {\n  T(std::shared_ptr\ni1\n i1, std::shared_ptr\ni2\n i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr\ni1\n i1_;\n  std::shared_ptr\ni2\n i2_;\n  int i;\n};\n\n__BOOST_DI_UNUSED auto name = [] {};\n\ndi::injector\nT, std::unique_ptr\nT\n, BOOST_DI_EXPOSE((named = name)T)\n module(const int\n i) noexcept {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  , di::bind\nint\n().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  {\n    auto object = injector.create\nT\n();\n    assert(dynamic_cast\nimpl1*\n(object.i1_.get()));\n    assert(dynamic_cast\nimpl2*\n(object.i2_.get()));\n    assert(42 == object.i);\n  }\n  {\n    auto object = injector.create\nstd::unique_ptr\nT\n();\n    assert(dynamic_cast\nimpl1*\n(object-\ni1_.get()));\n    assert(dynamic_cast\nimpl2*\n(object-\ni2_.get()));\n    assert(42 == object-\ni);\n  }\n  {\n    struct example {\n      BOOST_DI_INJECT(example, (named = name)T object) : object(object) {}\n      T object;\n    };\n\n    auto object = injector.create\nexample\n().object;\n    assert(dynamic_cast\nimpl1*\n(object.i1_.get()));\n    assert(dynamic_cast\nimpl2*\n(object.i2_.get()));\n    assert(42 == object.i);\n  }\n}\n\n\n\n\nExample\n\n\n\n\n Modules Example\n\n\n\n\n\n\nProviders\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProviders are responsible for creating objects using given \nConfiguration\n.\n\n\nSemantics\n\n\nnamespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\nstruct config : di::config {\n  template\nclass TInjector\n\n  static auto provider(const TInjector\n) noexcept { return providers::stack_over_heap{}; }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTInjector\n\n\n-\n\n\ninjector\n\n\n-\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\n \nNote\n\nProvider used by \ninjector\n might changed locally via \nmake_injector\n or globally via \nBOOST_DI_CFG\n.\n\n\n\nTest\n\n\n\nclass heap_no_throw {\n public:\n  template \nclass...\n\n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template \nclass T         // implementation\n          , class TInit     // direct()/uniform{}\n          , class TMemory   // heap/stack\n          , class... TArgs\n\n  auto get(const TInit\n, const TMemory\n, TArgs\n... args) const noexcept {\n    return new (std::nothrow) T{std::forward\nTArgs\n(args)...};\n  }\n};\n\nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return heap_no_throw{}; }\n};\n\nint main() {\n  auto injector = di::make_injector\nmy_provider\n();\n  assert(0 == injector.create\nint\n());\n}\n\n\n\n\nExample\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n\n\n\n\n\n--- \ndi::providers::stack_over_heap (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates objects on the stack whenever possible, otherwise on the heap.\n\n\nSemantics\n\n\nnamespace providers {\n  class stack_over_heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nTMemory\n\n\n\n\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nconst T\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT*\n\n\nheap\n\n\n\n\n\n\nconst T*\n\n\nheap\n\n\n\n\n\n\nstd::unique_ptr\n\n\nheap\n\n\n\n\n\n\nstd::shared_ptr\n\n\nheap\n\n\n\n\n\n\nstd::weak_ptr\n\n\nheap\n\n\n\n\n\n\nboost::shared_ptr\n\n\nheap\n\n\n\n\n\n\nis_polymorphic\nT\n\n\nheap\n\n\n\n\n\n\n\n\nTest\n\n\n\nclass my_provider : public di::config {\n public:\n  // this is default in di::config\n  static auto provider(...) noexcept { return di::providers::stack_over_heap{}; }\n};\n\nint main() {\n  auto injector = di::make_injector\nmy_provider\n();\n  injector.create\nint\n();                           // stack\n  std::unique_ptr\nint\n i{injector.create\nint*\n()};  // heap\n  (void)i;\n}\n\n\n\n\nExample\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n\n\n\n\n\n--- \ndi::providers::heap\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBasic provider creates objects on the heap (always).\n\n\nSemantics\n\n\nnamespace providers {\n  class heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return di::providers::heap{}; }\n};\n\nint main() {\n  auto injector = di::make_injector\nmy_provider\n();\n  injector.create\nint\n();                           // heap\n  std::unique_ptr\nint\n i{injector.create\nint*\n()};  // heap\n  (void)i;\n}\n\n\n\n\nExample\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n Mocks Provider Extension\n\n\n\n\n\n\nPolicies\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via \nConfiguration\n.\n\n\n \nNote\n\nBy default Boost.DI has no policies enabled.\n\n\n\nSemantics\n\n\ntemplate \nclass... TPolicies\n requires callable\nTPolicies...\n\nauto make_policies(TPolicies...) noexcept;\n\nstruct config : di::config {\n  template\nclass TInjector\n\n  static auto policies(const TInjector\n) noexcept { return make_policies(...); }\n};                                                                        |\n                                                                          |\n// policy                                                                 /\ntemplate\nclass T\n   \n-----------------------------------------------------\nvoid operator()(const T\n);\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTInjector\n\n\n-\n\n\ninjector\n\n\n-\n\n\n\n\n\n\nmake_policies\nTPolicies...\n\n\ncallable\nTPolicies...>\n\n\nCreates policies\n\n\ncallable\n list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nT::type\n\n\nType to be created\n\n\nstd::shared_ptr\nint\n\n\n\n\n\n\nT::expected\n\n\nDecayed 'Interface' type\n\n\ninterface\n\n\n\n\n\n\nT::given\n\n\nDecayed 'Given' type\n\n\nimplementatoin\n\n\n\n\n\n\nT::name\n\n\nAnnotation name\n\n\nmy_name\n\n\n\n\n\n\nT::arity\n\n\nNumber of constructor arguments\n\n\nintegral_constant\nint, 3\n\n\n\n\n\n\nT::scope\n\n\nscope\n\n\nsingleton\n\n\n\n\n\n\nT::is_root\n\n\nIs the root object (a type \ncreate\n was called with)\n\n\ntrue_type\n/\nfalse_type\n\n\n\n\n\n\n\n\n \nNote\n\nIn order for injector to verify policies they have to be created using \nconfig\n and passed via \nTConfig\n in \nmake_injector\n\nor set it globally via \nBOOST_DI_CFG\n.\n\n\n\nTest\n\n\n\nclass print_types_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto type) {\n      using arg = typename decltype(type)::type;\n      std::cout \n typeid(arg).name() \n std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\nprint_types_policy\n();\n  injector.create\nint\n();  // output: int\n}\n\n\n\n\n\nclass print_types_info_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto arg) {\n      using T = decltype(arg);\n      using type = typename T::type;\n      using name = typename T::name;\n      using expected = typename T::expected;\n      using given = typename T::given;\n      using scope = typename T::scope;\n      auto ctor_size = T::arity::value;\n\n      std::cout \n ctor_size \n std::endl\n                \n typeid(type).name() \n std::endl\n                \n typeid(expected).name() \n std::endl\n                \n typeid(given).name() \n std::endl\n                \n typeid(name).name() \n std::endl\n                \n typeid(scope).name() \n std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\nprint_types_info_policy\n(\n    di::bind\ni1\n().to\nimpl1\n()\n  );\n  injector.create\nstd::unique_ptr\ni1\n();\n}\n\n\n\n\nExample\n\n\n\n\n Custom Policy Example\n\n\n Types Dumper Extension\n\n\n UML Dumper Extension\n\n\n\n\n\n\n\n--- \ndi::policies::constructible\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nConstructible policy limits constructor parameters to explicitly allowed.\n\n\n \nNote\n\nBy default constructible policy disables creation of any constructor parameters.\n\n\n\nSemantics\n\n\nnamespace policies {\n  struct _ { }; // placeholder\n\n  template\nclass T\n\n  struct is_bound; // true when type is bound with 'di::bind\nT\n'\n\n  template \nclass T\n\n  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'\n\n  template\nclass T\n\n  auto constructible(const T\n) noexcept;\n}\n\nnamespace operators {\n  template\nclass X\n\n  inline auto operator!(const X\n)\n\n  template\nclass X, class Y\n\n  inline auto operator\n(const X\n, const Y\n);\n\n  template\nclass X, class Y\n\n  inline auto operator||(const X\n, const Y\n);\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_bound\nT\n\n\n-\n\n\nVerify whether type \nT\n is bound\n\n\ntrue_type/false_type\n\n\n\n\n\n\nis_injected\nT\n\n\n-\n\n\nVerify whether type \nT\n is injected via \nBOOST_DI_INJECT\n\n\ntrue_type/false_type\n\n\n\n\n\n\n\n\n \nNote\n\nIn order to allow logic operators using namespace \nboost::di::policies::operators\n has to be used.\n\n\n\nTest\n\n\n#include \nboost/di.hpp\n\n\n\nclass injected_and_bound : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(\n      constructible(is_injected\ndi::_\n{} \n is_bound\ndi::_\n{})\n    );\n  }\n};\n\nstruct T {\n  BOOST_DI_INJECT(T, int, double) {}\n};\n\nint main() {\n  auto injector = di::make_injector\ninjected_and_bound\n(\n    di::bind\n().to(42)\n  , di::bind\n().to(87.0)\n  );\n\n  injector.create\nT\n();\n}\n\n\n\n\nclass all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include \nboost/di.hpp\n\n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same\ndi::_, int\n{} || is_bound\ndi::_\n{}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create\nint\n());\n  // di::make_injector().create\ndouble\n(); // compile error\n  assert(42.0 == make_injector(di::bind\ndouble\n().to(42.0)).create\ndouble\n());\n}\n\n\n\n\n \nNote\n\nSTL type traits are supported and might be combined with Boost.DI traits in order to limit constructor types\nFor example, \nstd::is_same\n_, int\n{} || std::is_constructible\n_, int, int\n{} || std::is_base_of\nint, _\n{}\n, etc...\n\n\n\nExample\n\n\n\n\n Custom Policy Example\n\n\n Types Dumper Extension\n\n\n UML Dumper Extension\n\n\n\n\n\n\nConcepts\n\n\nConcepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.\n\n\n\n--- \ndi::concepts::boundable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBindings\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass TExpected, class TGiven\n\nconcept bool boundable() {\n  return is_complete\nTExpected\n()\n      \n is_complete\nTGiven\n()\n      \n (is_base_of\nTExpected, TGiven\n() || is_convertible\nTGiven, TExpected\n());\n}\n\ntemplate \nclass... Ts\n\nconcept bool boundable() {\n  return is_supported\nTs\n()...\n      \n is_movable\nTs\n()...\n      \n (is_base_of\ninjector, Ts\n()... || is_base_of\ndependency, Ts\n()...);\n}\n\n\n\nSemantics\n\n\nboundable\nT\n\nboundable\nTs...\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTs...\n\n\nBindings to be verified\n\n\ntrue_type if constraint is satisfied, \nError\n otherwise\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_disallowed_qualifiers\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has disallowed qualifiers\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind\nint*\n().to(42) /** type\nint*\n::has_disallowed_qualifiers **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_has_disallowed_qualifiers.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_abstract\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is abstract\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0, 1 -\n no additional info, 2 -\n info about why type \nT\n is abstract\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 2\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct i {\n  virtual ~i() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct impl : i {};\n\nint main() {\n  di::make_injector(\n    di::bind\ni\n().to\nimpl\n() /** type\nimpl\n::is_abstract **/\n    /** unimplemented pure virtual method 'dummy' in 'impl' **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_not_related_to\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is not related to type \nU\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind\nint\n().to\ndouble\n() /** type\ndouble\n::is_not_related_to\nint\n **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_not_related_to.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_bound_more_than_once\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is bound more than once\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind\nint\n.to(42) /** type\nint\n::is_bound_more_than_once **/\n  , di::bind\nint\n.to(87) // [di::override]\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_neither_a_dependency_nor_an_injector\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is neither a dependency nor an injector\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    dummy{} /** type\ndummy\n::is_neither_a_dependency_nor_an_injector **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_neither_a_dependency_nor_an_injector.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::callable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicy\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}\n\n\n\nSemantics\n\n\ncallable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\npolicy\nTPolicy\n::requires_\ncall_operator\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\npolicy \nTPolicy\n requires a call operator\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto policies(...) { return di::make_policies(dummy{}); }\n  };\n\n  di::make_injector\ntest_config\n();\n  /** policy\ntest_config::dummy\n::requires_\ncall_operator\n **/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/callable_requires_call_operator.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::configurable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nConfiguration\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool configurable() {\n  return requires(T object) {\n    return providable\ndecltype(T::provider(...))\n \n callable\ndecltype(T::policies(...))\n();\n  }\n}\n\n\n\nSemantics\n\n\nconfigurable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nconfig\nTConfig\n::requires_\nprovider\nprovidable_type (...)\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nconfig \nT\n requires only providable and callable types\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config /*: di::config*/ {\n    static auto policies(...) { return di::make_policies(); }\n  };\n\n  di::make_injector\ntest_config\n();\n  /** config\ntest_config\n::requires_\nprovider\nprovidable_type (...)\n **/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/configurable_requires_callable_and_providable.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::creatable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nRequirement for type \nT\n which is going to be created via \ninjector\n.create\nT\n()\n\n\nSynopsis\n\n\nnamespace type_traits {\n  template\nclass T\n\n  using ctor_traits; // returns list of constructor parameters\n}\n\ntemplate \nclass T, class... TArgs\n\nconcept bool creatable() {\n  return is_constructible\nT, TArgs...\n() \n\n         is_constructible\nTArgs, type_traits::ctor_traits\nTArgs\n...\n();\n}\n\n\n\nSemantics\n\n\ncreatable\nT, TArgs...\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nabstract_type\nT\n::is_not_bound\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nabstract type \nT\n is not bound\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'type is not bound, did you forget to add: 'di::bind\n.to\n()'?'\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr\ninterface\n) {}\n};\n\nint main() {\n  di::make_injector().create\nexample\n(); /** creatable constraint not satisfied **/\n  /** abstract_type\ninterface\n::is_not_bound\n   *  type is not bound, did you forget to add: \n   *   'di::bind\ninterface\n.to\nimplementation\n()'?\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr\ninterface\n) {}\n};\n\nint main() {\n  di::injector\nexample\n injector = di::make_injector(); /** creatable constraint not satisfied **/\n  /** abstract_type\ninterface\n::is_not_bound\n   *  type is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n   */\n  (void)injector;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_ambiguous_number_of_constructor_parameters::given\nGiven\n::expected\nExpected\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has ambiguous number of constructor parameters where \nGiven\n were provided but \nExpected\n were expected\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    BOOST_DI_INJECT_TRAITS(int, int);  // 2 parameters\n    T(int, int, int, int) {}           // 4 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** type\nT\n::has_ambiguous_number_of_constructor_parameters::given\n2\n::expected\n4\n\n   * verify BOOST_DI_INJECT_TRAITS or di::ctor_traits\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_ambiguous_number_of_constructor_parameters.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_to_many_constructor_parameters::max\nMax\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has to many constructor parameter where maximum number is \nMax\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_CTOR_LIMIT_SIZE 2  // specify max number of constructor parameters\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int, int, int) {}  // 3 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** type\nT\n::has_to_many_constructor_parameters::max\n2\n\n   *  increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_to_many_constructor_parameters.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\nTScope\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind\n.in(scope)'?'\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int*) {}\n  };\n  auto injector = di::make_injector(\n    di::bind\nint\n().in(di::singleton)\n  );\n\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** scoped\nsingleton\n::is_not_convertible_to\nint *\n\n   *  scoped object is not convertible to the requested type,\n   *    did you mistake the scope: 'di::bind\nT\n.in(scope)'?\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_scoped_is_not_convertible_to.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\ninstance\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ninstance is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'instance is not convertible to the requested type, verify binding: 'di::bind\n.to(value)'?'\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int\n) {}\n  };\n  auto injector = di::make_injector(\n    di::bind\n().to(42)\n  );\n\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** scoped\ninstance\n::is_not_convertible_to\nint \n\n   *  instance is not convertible to the requested type,\n   *    verify binding: 'di::bind\nT\n.to(value)'?\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_instance_is_not_convertible_to.cpp\n\n\n\n\n \nNote\n\nSuggestions are not supported/displayed by MSVC-2015.\n\n\n\n\n\n\n--- \ndi::concepts::providable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProvider\n type requirement.\n\n\nSynopsis\n\n\nnamespace type_traits {\n  struct direct;\n  struct uniform;\n  struct stack;\n  struct heap;\n}\n\ntemplate \nclass T\n\nconcept bool providable() {\n  return requires(T object) {\n    { object.template get\n_\n(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n    { object.template is_creatable\n_\n(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n  }\n}\n\n\n\nSemantics\n\n\nprovidable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nprovider\nTProvider\n::requires_\nget\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nprovider \nTProvider\n requires \nget\n method\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto provider(...) { return dummy{}; }\n  };\n  di::make_injector\ntest_config\n(); /** provider\ntest_config::dummy\n::requires_\nget\n **/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/providable_requires_get.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::scopable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope\n type requirement.\n\n\nSynopsis\n\n\nstruct _ {}; // any type\n\ntemplate \nclass T\n\nconcept bool scopable() {\n  return requires(T) {\n    typename scope\n_, _\n::is_referable;\n    { T::scope\n_, _\n{}.try_create() };\n    { T::scope\n_, _\n{}.create() };\n  }\n}\n\n\n\nSemantics\n\n\nscopable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nscope\nTScope\n::requires_\ncreate\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n requires \ncreate\n method\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    di::bind\nint\n().in(dummy{})); /** scope\ndummy\n::requires_\ncreate\n **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/scopable_requires_create.cpp\n\n\n\n\n\n\nConfiguration\n\n\n\n--- \ndi::config\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nInjector\n configuration.\n\n\nSynopsis\n\n\nstruct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nprovider()\n\n\nprovidable\n\n\nCreates provider\n\n\nprovidable\n\n\n\n\n\n\npolicies()\n\n\ncallable\n\n\nCreates policies\n\n\ncallable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies\n\n\n\n\n\n\n\n\nSemantics\n\n\ndi::make_injector\nconfig\n(...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)\n\n\n\nTest\n\n\nclass all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include \nboost/di.hpp\n\n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same\ndi::_, int\n{} || is_bound\ndi::_\n{}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create\nint\n());\n  // di::make_injector().create\ndouble\n(); // compile error\n  assert(42.0 == make_injector(di::bind\ndouble\n().to(42.0)).create\ndouble\n());\n}\n\n\n\n\nExample\n\n\n\n\n Configuration Example\n\n\n Custom Policy Example\n\n\n Custom Provider Example", 
            "title": "User Guide"
        }, 
        {
            "location": "/user_guide/index.html#injector", 
            "text": "Injector is a core component providing types creation functionality using  bindings .  ---  di::make_injector  ---  Header  #include  boost/di.hpp   Description  Creates  injector  type.  Semantics  template class... TDeps  requires boundable TDeps... \nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector ) = default;\n  template  class... Ts  // no requirements\n  injector(core::injector Ts... ) noexcept;\n  explicit injector(const TDeps ...) noexcept;\n\n  template class T  requires creatable T \n  T create() const;\n};     Expression  Requirement  Description  Returns      TDeps...  boundable TDeps...>  Bindings  to be used as configuration  -    create T ()  creatable T>  Creates type  T  T        Type  T  Is allowed?  Note      T  \u2714  -    T*  \u2714  Ownership transfer!    const T*  \u2714  Ownership transfer!    T  \u2714  -    const T  \u2714  Reference with  singleton  / Temporary with  unique    T  \u2714  -    std::unique_ptr T  \u2714  -    std::shared_ptr T  \u2714  -    std::weak_ptr T  \u2714  -    boost_shared_ptr T  \u2714  -     template \n  class TConfig = di::config\n, class... TBindings  requires configurable TConfig    boundable TBindings... \nauto make_injector(const TBindings ...) noexcept;     Expression  Requirement  Description  Returns      TConfig  configurable TConfig>  Configuration  per  injector  -    make_injector(const TBindings ...)  boundable TBindings...>  Creates  injector  with given  Bindings  injector     Test  \nint main() {\n  auto injector = di::make_injector();\n\n  assert(0 == injector.create int ());\n}  Example    Hello World Example   Create Objects Tree Example", 
            "title": "Injector"
        }, 
        {
            "location": "/user_guide/index.html#bindings", 
            "text": "Bindings define dependencies configuration describing what types will be created\nand what values will be passed into them.  \n---  di::bind  ---  Header  #include  boost/di.hpp   Description  Allows to bind interface to implementation and associate value with it.  Semantics  struct override; // overrides given configuration\n\nnamespace detail {\n  template class I, class... Is/*any_of*/  requires boundable I, Is... \n  struct bind {\n    bind(bind ) noexcept = default;\n\n    template  class T  requires !is_array I    boundable I, T \n    auto to() noexcept;\n\n    template  class... Ts  requires is_array I    boundable Ts... \n    auto to() noexcept;\n\n    template class T  requires boundable I, T \n    auto to(T ) noexcept;\n\n    template class TScope  requires scopable TScope \n    auto in(const TScope  = di::deduce) noexcept;\n\n    template class TName  // no requirements\n    auto named(const TName  = {}) noexcept;\n\n    auto operator[](const override ) noexcept;\n  };\n} // detail\n\ntemplate class... Ts  requires boundable Ts... \ndetail::bind Ts...  bind{};     Expression  Requirement  Description  Returns      I ,  Is...  boundable I, Is...>  'Interface' types  -    to T  boundable T>  Binds  I, Is...  to  T  type  boundable    to Ts...  boundable Ts...>  Binds  I, Is...  to  Ts...  type  boundable    to(T )  boundable T>  Binds  I, Is...  to  T  object  boundable    in(const TScope )  scopable TScope>  Binds  I, Is...  in TScope`  boundable    named(const TName )  -  Binds  I, Is...  using  named  annotation  boundable    operator[](const override )  -  Overrides given binding  boundable       Note \nCheck out also  instance  scope to read more about binding to values:  di::bind .to(value) .     Expression  Description      Multiple Interfaces     di::bind Interface1, Interface2, ... .to Implementation ()  Binds  Interface1, Interface2, ...  to  Implementation  using one object    Multiple Bindings  (std::array, std::vector, std::set)     di::bind int[] .to({1, 2, ...})  Binds  int  to values  1, 2, ...    di::bind Interface*[] .to Implementation1, Implementation2, ... ()  Binds  Interface  to  Implementation1, Implementation2, ...    Dynamic Bindings     di::bind Interface .to([](const auto  injector) { return injector.template create Implementation ()})  Allows to bind  Interface  depending on a run-time condition     Test  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().to impl1 ()\n  );\n\n  auto object = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (object.get()));\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  );\n\n  assert(42 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind ().to(42)\n  );\n\n  assert(42 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to std::integral_constant int, 42 ()\n  );\n\n  assert(42 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1, i2 ().to impl ()\n  );\n\n  auto object1 = injector.create std::shared_ptr i1 ();\n  auto object2 = injector.create std::shared_ptr i2 ();\n  assert(dynamic_cast impl* (object1.get()));\n  assert(dynamic_cast impl* (object2.get()));\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().to([ ](const auto  injector) -  i1  {\n      if (true)\n        return injector.template create impl1 ();\n      else\n        return injector.template create impl ();\n    })\n  );\n\n  auto  object = injector.create i1 ();\n  assert(dynamic_cast impl1* ( object));\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1*[] ().to impl, impl1 ()\n  );\n\n  auto v = injector.create std::vector std::unique_ptr i1 ();\n  assert(2 == v.size());\n  assert(dynamic_cast impl* (v[0].get()));\n  assert(dynamic_cast impl1* (v[1].get()));\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind int[] ().to({1, 2, 3}) // or int*[]\n  );\n\n  auto v = injector.create std::vector int ();\n  assert(3 == v.size());\n  assert(1 == v[0]);\n  assert(2 == v[1]);\n  assert(3 == v[2]);\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind int ().to(123) [di::override]\n  );\n\n  assert(123 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n#if defined(__cpp_variable_templates)\n      di::bind i1 .to impl1 ()\n#else\n      di::bind i1 ().to impl1 ()  // no variable templates\n#endif\n          );\n\n  auto object = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (object.get()));\n}  Example    Bindings Example   Forward Bindings Example   Dynamic Bindings Example   Multiple Bindings Example   Constructor Bindings Extension", 
            "title": "Bindings"
        }, 
        {
            "location": "/user_guide/index.html#injections", 
            "text": "Constructor Injection  is the most powerful of available injections.\nIt guarantees initialized state of data members. Boost.DI constructor injection is achieved without any additional work from the user.  \n---  automatic (default)  ---  Header  #include  boost/di.hpp   Description  Boost.DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS  or di::ctor_traits] or  di::inject .    Note \nAutomatic constructor parameters deduction is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Semantics  class T {\npublic:\n  T(auto parameter1, auto parameter2, ..., auto parameterN);\n};     Expression  Requirement  Description  Returns      parameter1-parameterN  -  N  constructor parameter  -       Note \nBoost.DI is not able to automatically distinguish between ambiguous constructors with the same (longest) number of parameters.\nUse  BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS  or  di::ctor_traits  or  di::inject  to explicitly mark constructor to be injected.  Test  \nstruct T {\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  int a;     // = 0;\n  double d;  // = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  T();\n  T(int a) : a(a) {}\n  T(int a, double d) : a(a), d(d) {}  // longest will be chosen\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d, ...) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  Example    Automatic Injection Example   Constructor Signature Example   Lazy Extension   XML Injection Extension    \n---  BOOST_DI_INJECT  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_INJECT is a macro definition used to explicitly say Boost.DI which constructor should be used as well as to annotate types - see  annotations  for further reding.\nWhen class has more than one constructor Boost.DI will by default choose the one with the longest parameter list.\nIn case of constructors ambiguity, Boost.DI is not able to choose the best one.\nThen BOOST_DI_INJECT becomes handy to point which constructor should be used.  Semantics  struct T {\n    BOOST_DI_INJECT(T, ...) { }\n};     Expression  Requirement  Description  Returns      T  -  Class/Struct name  -    ...  -  T  constructor parameters  -       Note \nBOOST_DI_INJECT constructor parameters is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Test  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  BOOST_DI_INJECT(T, int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  Example    Constructor Injection Example   Concepts Extension    \n---  BOOST_DI_INJECT_TRAITS  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.  Semantics  struct T {\n  BOOST_DI_INJECT_TRAITS(...) { }\n  T(...) { }\n};     Expression  Requirement  Description  Returns      ...  -  T  constructor parameters  -       Note \nBOOST_DI_INJECT_TRAITS constructor parameters is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Test  \nstruct T {\n  BOOST_DI_INJECT_TRAITS(int, double);\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nclass example {\n public:\n  BOOST_DI_INJECT_TRAITS(int);\n  explicit example(int i, double d = 42.0) : i(i), d(d) {}\n\n  int i = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector();\n  auto object = injector.create example ();\n  assert(0 == object.i);\n  assert(42.0 == object.d);\n}  Example    Constructor Injection Example    \n---  di::inject  ---  Header  #include  boost/di.hpp   Description  di::inject  informs Boost.DI about constructor parameters.\nIt's useful for generated/generic classes as it doesn't have constructor parameters size limitations.  Semantics  struct T {\n  using boost_di_inject__ = di::inject ... ;\n  T(...) {}\n};     Expression  Requirement  Description  Returns      ...  -  T  constructor parameters  -       Note  di::inject  has no limitations if it comes to constructor parameters, however,  named  parameters are not allowed.\nMoreover, you can replace  di::inject  with any variadic type list type to remove dependency to Boost.DI.\nFor example,  template class...  struct type_list{};   using boost_di_inject__ = type_list ... ;   Test  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n  using boost_di_inject__ = di::inject int, double ;\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  using boost_di_inject__ = di::inject \n    int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int ;\n\n  T(int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int) { }\n};\n\nint main() {\n  auto injector = di::make_injector();\n  injector.create T ();  // compile clean\n}  Example    Constructor Injection Example    \n---  di::ctor_traits  ---  Header  #include  boost/di.hpp   Description  di::ctor_traits  is a trait in which constructor parameters for type  T  might be specified.\nIt's useful for third party classes you don't have access to and which can't be created using  automatic  injection.  Semantics  namespace boost {\nnamespace di {\n  template  \n  struct ctor_traits T  {\n    BOOST_DI_INJECT_TRAITS(...); // or using type = di::inject ... ;\n  };\n}}  Test  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate  \nstruct ctor_traits T  {\n  BOOST_DI_INJECT_TRAITS(int, double);\n};\n}\n}  // boost::di\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  Example    Constructor Injection Example", 
            "title": "Injections"
        }, 
        {
            "location": "/user_guide/index.html#annotations", 
            "text": "Annotations are type properties specified in order to refer to a type by the name instead of the type it self.\nThey are useful when constructor has more than one parameter of the same type.\nFor example,  T(int, int) .  \n---  (named = name)  ---  Header  #include  boost/di.hpp   Description  Named parameters are handy to distinguish different constructor parameters of the same type.    T(int value1, int value2);  In order to inject proper values into  value1  and  value2  they have to be differentiate somehow.\nBoost.DI solution for this problem are annotations.    Note \nAnnotations might be set only when constructor is marked using  BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS .  Semantics  auto Name = []{}; // just an object\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);\n};     Expression  Requirement  Description  Returns      Name  -  Object representing named type  -     Example  BOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);    Note \nImplementation of constructor doesn't require annotations, only constructor definition requires them.  Test  \nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(int1).to(42)\n  , di::bind int ().named(int2).to(87)\n  );\n  {\n    auto object = injector.create T ();\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n  {\n    auto object = T(42, 87);\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n}  \nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b);\n  int a = 0;\n  int b = 0;\n};\n\nT::T(int a, int b) : a(a), b(b) {}\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(int1).to(42)\n  , di::bind int ().named(int2).to(87)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}  \nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  T(int a, int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate  \nstruct ctor_traits T  {\n  BOOST_DI_INJECT_TRAITS((named = int1) int, (named = int2) int);\n};\n}\n}  // boost::di\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(int1).to(42)\n  , di::bind int ().named(int2).to(87)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}  \nauto n1 = [] {};\nauto n2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = n1) int i1\n                   , (named = n1) int i2\n                   , (named = n2) int i3\n                   , int i4\n                   , (named = n1)std::string s)\n    : i1(i1), i2(i2), i3(i3), i4(i4), s(s) {}\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n  int i4 = 0;\n  std::string s;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(n1).to(42)\n  , di::bind int ().named(n2).to(87)\n  , di::bind std::string ().named(n1).to( str )\n  );\n  auto object = injector.create T ();\n  assert(42 == object.i1);\n  assert(42 == object.i2);\n  assert(87 == object.i3);\n  assert(0 == object.i4);\n  assert( str  == object.s);\n}  Example    Annotations Example   Named Parameters Extension   Assisted Injection Extension", 
            "title": "Annotations"
        }, 
        {
            "location": "/user_guide/index.html#scopes", 
            "text": "Header  #include  boost/di.hpp   Description  Scopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given,  deduce  scope will be assumed.  Semantics  template  class TExpected, class TGiven \nstruct scope {\n  template  class T \n  using is_referable;\n\n  template  class T, class TName, class TProvider \n  static auto try_create(const TProvider );\n\n  template  class T, class TName, class TProvider \n  auto create(const TProvider );\n};     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T        Type/Scope  unique  singleton  instance      T  \u2714  -  \u2714    T  -  \u2714  \u2714    const T  \u2714 (temporary)  \u2714  \u2714    T* (transfer ownership)  \u2714  -  -    const T*  \u2714  -  -    T  \u2714  -  \u2714    std::unique_ptr  \u2714  -  -    std::shared_ptr  \u2714  \u2714  \u2714    boost::shared_ptr  \u2714  \u2714  - / \u2714 converted to    std::weak_ptr  -  \u2714  - / \u2714 converted to     Test  \nstruct custom_scope {\n  template  class TExpected, class \n  struct scope {\n    template  class \n    using is_referable = std::false_type;\n\n    template  class T, class, class TProvider \n    static auto try_create(const TProvider  provider) -  decltype(std::shared_ptr TExpected {provider.get()});\n\n    template  class T, class, class TProvider \n    auto create(const TProvider  provider) {\n      return std::shared_ptr TExpected {provider.get()};\n    }\n  };\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().in(custom_scope{}).to impl1 ()\n  );\n  assert(injector.create std::shared_ptr i1 () != injector.create std::shared_ptr i1 ());\n}  Example    Custom Scope Example   Scoped Scope Extension   Session Scope Extension   Shared Scope Extension    \n---  di::deduce (default)  ---  Header  #include  boost/di.hpp   Description  Default scope which will be converted to one of the scopes depending on the type.     Type  Scope      T  unique    T  singleton    const T  unique  (temporary) /  singleton    T*  unique  (ownership transfer)    const T*  unique  (ownership transfer)    T  unique    std::unique_ptr  unique    std::shared_ptr  singleton    boost::shared_ptr  singleton    std::weak_ptr  singleton     Semantics  namespace scopes {\n  struct deduce {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::deduce deduce;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nstruct T {\n  T(const std::shared_ptr i1  sp, std::unique_ptr i2  up, int  i, double d) : sp(sp), up(std::move(up)), i(i), d(d) {}\n\n  std::shared_ptr i1  sp; /*singleton*/\n  std::unique_ptr i2  up; /*unique*/\n  int  i;                 /*instance*/\n  double d;               /*unique*/\n};\n\nint main() {\n  auto i = 42;\n  auto injector = di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  , di::bind int ().to(i)\n  , di::bind double ().to(87.0)\n  );\n  auto object1 = injector.create std::unique_ptr T ();\n  auto object2 = injector.create std::unique_ptr T ();\n  assert(object1- sp == object2- sp);\n  assert(object1- up != object2- up);\n  assert(42 == object1- i);\n  assert( i ==  object1- i);\n  assert(42 == object2- i);\n  assert( i ==  object2- i);\n  assert(87.0 == object1- d);\n  assert(87.0 == object2- d);\n  i = 12;\n  assert(i == object2- i);\n  assert( i ==  object2- i);\n}  Example    Deduce Scope Example   Scopes Example    \n---  di::instance (di::bind .to(value))  ---  Header  #include  boost/di.hpp   Description  Scope representing values - passed externally. The life time of the object depends on the user.\nBoost.DI is not maintaining the life time of these objects, however, values and strings will be copied and managed by the library.     Type  instance[in] ( bind .to(in) )  instance[out] ( injector.create out () )      T  \u2714  \u2714    T  \u2714  \u2714    const T  \u2714  \u2714    T*  -  -    const T*  -  -    T  \u2714  \u2714    std::unique_ptr  -  -    std::shared_ptr  \u2714  \u2714    boost::shared_ptr  -  \u2714    std::weak_ptr  -  \u2714     Semantics  namespace scopes {\n  struct instance {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nint main() {\n  auto l = 42l;\n  auto b = false;\n  auto injector = di::make_injector(\n    di::bind int ().to(0)\n  , di::bind int ().to(42)[di::override]\n  , di::bind i1 ().to(std::make_shared impl ())\n  , di::bind long ().to(l)\n  , di::bind short ().to([] { return 87; })\n  , di::bind i2 ().to([ ](const auto  injector) -  std::shared_ptr i2  {\n      return b ? injector.template create std::shared_ptr impl2 () : nullptr; })\n  );\n\n  assert(42 == injector.create int ());\n  assert(injector.create std::shared_ptr i1 () == injector.create std::shared_ptr i1 ());\n  assert(l == injector.create long ());\n  assert( l ==  injector.create long ());\n  assert(87 == injector.create short ());\n  {\n    auto object = injector.create std::shared_ptr i2 ();\n    assert(nullptr == object);\n  }\n  {\n    b = true;\n    auto object = injector.create std::shared_ptr i2 ();\n    assert(dynamic_cast impl2* (object.get()));\n  }\n}  Example    Scopes Example   Bindings Example    \n---  di::singleton  ---  Header  #include  boost/di.hpp   Description  Scope representing shared value between all instances as well as threads.\nSingleton scope will be deduced in case of reference,  std::shared_ptr ,  boost::shared_ptr  or  std::weak_ptr .    Note \nSingleton scope will convert automatically between  std::shared_ptr  and  boost::shared_ptr  if required.     Type  singleton      T  -    T  \u2714    const T  \u2714    T*  -    const T*  -    T  -    std::unique_ptr  -    std::shared_ptr  \u2714    boost::shared_ptr  \u2714    std::weak_ptr  \u2714     Semantics  namespace scopes {\n  struct singleton {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::singleton singleton;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().in(di::singleton).to impl1 ()\n  );\n\n  assert(injector.create std::shared_ptr i1 () == injector.create std::shared_ptr i1 ());\n}  Example    Scopes Example   Eager Singletons Example    \n---  di::unique  ---  Header  #include  boost/di.hpp   Description  Scope representing unique/per request value. A new instance will be provided each time type will be requested.     Type  unique      T  \u2714    T  -    const T  \u2714 (temporary)    T*  \u2714 (ownership transfer)    const T*  \u2714 (ownership transfer)    T  \u2714    std::unique_ptr  \u2714    std::shared_ptr  \u2714    boost::shared_ptr  \u2714    std::weak_ptr  -     Semantics  namespace scopes {\n  struct unique {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::unique unique;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().in(di::unique).to impl1 ()\n  );\n\n  assert(injector.create std::shared_ptr i1 () != injector.create std::shared_ptr i1 ());\n}  Example    Scopes Example", 
            "title": "Scopes"
        }, 
        {
            "location": "/user_guide/index.html#modules", 
            "text": "Header  #include  boost/di.hpp   Description  Modules allow to split  bindings  configuration into smaller  injectors .\nModule might be installed by passing it into  make_injector .  Semantics  auto module = di::make_injector(...);\ndi::injector Ts...  module = di::make_injector(...);     Expression  Description  Note      auto module = di::make_injector(...)  All types are exposed from  module  module.create T ()  is allowed for any  T    di::injector Ts...  module = di::make_injector(...)  Only  Ts...  types are exposed from  module  module.create T ()  is allowed only for  T   =  Ts...     Test  \nstruct T {\n  T(std::unique_ptr i1  i1, std::unique_ptr i2  i2, int i) : i1_(std::move(i1)), i2_(std::move(i2)), i(i) {}\n\n  std::unique_ptr i1  i1_;\n  std::unique_ptr i2  i2_;\n  int i = 0;\n};\n\nauto module1 = [] {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind int ().to(42)\n  );\n};\n\nauto module2 = [] {\n  return di::make_injector(\n    di::bind i2 ().to impl2 ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module1(), module2());\n  auto object = injector.create std::unique_ptr T ();\n  assert(dynamic_cast impl1* (object- i1_.get()));\n  assert(dynamic_cast impl2* (object- i2_.get()));\n  assert(42 == object- i);\n  auto up1 = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (up1.get()));\n  auto up2 = injector.create std::unique_ptr i2 ();\n  assert(dynamic_cast impl2* (up2.get()));\n}  \nstruct T {\n  T(std::shared_ptr i1  i1, std::shared_ptr i2  i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr i1  i1_;\n  std::shared_ptr i2  i2_;\n  int i;\n};\n\ndi::injector T  module(const int  i) noexcept {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  , di::bind int ().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  auto object = injector.create T ();\n  assert(dynamic_cast impl1* (object.i1_.get()));\n  assert(dynamic_cast impl2* (object.i2_.get()));\n  assert(42 == object.i);\n  // injector.create std::unique_ptr i1 (); // compile error\n  // injector.create std::unique_ptr i2 (); // compile error\n}  \nauto module = []() -  di::injector std::unique_ptr i1 , std::unique_ptr i2  {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto up1 = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (up1.get()));\n  auto up2 = injector.create std::unique_ptr i2 ();\n  assert(dynamic_cast impl2* (up2.get()));\n}  Example    Modules Example    \n---  BOOST_DI_EXPOSE  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_EXPOSE is a macro definition allowing to expose  named  parameters via module/ injector .  Semantics  di::injector BOOST_DI_EXPOSE((named = Name) T), ... ;     Expression  Requirement  Description  Returns      Name  -  Named object  -    ...  -  More types to be exposed  -     Test  \nauto my_name = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = my_name)std::unique_ptr i1  up) : up(std::move(up)) {}\n  std::unique_ptr i1  up;\n};\n\nauto module = []() -  di::injector BOOST_DI_EXPOSE((named = my_name)std::unique_ptr i1 )  {\n  return di::make_injector(\n    di::bind i1 ().named(my_name).to impl1 ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto object = injector.create std::unique_ptr T ();\n  assert(dynamic_cast impl1* (object- up.get()));\n}  \nstruct T {\n  T(std::shared_ptr i1  i1, std::shared_ptr i2  i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr i1  i1_;\n  std::shared_ptr i2  i2_;\n  int i;\n};\n\n__BOOST_DI_UNUSED auto name = [] {};\n\ndi::injector T, std::unique_ptr T , BOOST_DI_EXPOSE((named = name)T)  module(const int  i) noexcept {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  , di::bind int ().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  {\n    auto object = injector.create T ();\n    assert(dynamic_cast impl1* (object.i1_.get()));\n    assert(dynamic_cast impl2* (object.i2_.get()));\n    assert(42 == object.i);\n  }\n  {\n    auto object = injector.create std::unique_ptr T ();\n    assert(dynamic_cast impl1* (object- i1_.get()));\n    assert(dynamic_cast impl2* (object- i2_.get()));\n    assert(42 == object- i);\n  }\n  {\n    struct example {\n      BOOST_DI_INJECT(example, (named = name)T object) : object(object) {}\n      T object;\n    };\n\n    auto object = injector.create example ().object;\n    assert(dynamic_cast impl1* (object.i1_.get()));\n    assert(dynamic_cast impl2* (object.i2_.get()));\n    assert(42 == object.i);\n  }\n}  Example    Modules Example", 
            "title": "Modules"
        }, 
        {
            "location": "/user_guide/index.html#providers", 
            "text": "Header  #include  boost/di.hpp   Description  Providers are responsible for creating objects using given  Configuration .  Semantics  namespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}\n\nstruct config : di::config {\n  template class TInjector \n  static auto provider(const TInjector ) noexcept { return providers::stack_over_heap{}; }\n};     Expression  Requirement  Description  Returns      TInjector  -  injector  -    is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T       Note \nProvider used by  injector  might changed locally via  make_injector  or globally via  BOOST_DI_CFG .  Test  \nclass heap_no_throw {\n public:\n  template  class... \n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template  class T         // implementation\n          , class TInit     // direct()/uniform{}\n          , class TMemory   // heap/stack\n          , class... TArgs \n  auto get(const TInit , const TMemory , TArgs ... args) const noexcept {\n    return new (std::nothrow) T{std::forward TArgs (args)...};\n  }\n};\n\nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return heap_no_throw{}; }\n};\n\nint main() {\n  auto injector = di::make_injector my_provider ();\n  assert(0 == injector.create int ());\n}  Example    Custom Provider Example   Pool Provider Example    \n---  di::providers::stack_over_heap (default)  ---  Header  #include  boost/di.hpp   Description  Creates objects on the stack whenever possible, otherwise on the heap.  Semantics  namespace providers {\n  class stack_over_heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T        Type  TMemory      T  stack    T  stack    const T  stack    T  stack    T*  heap    const T*  heap    std::unique_ptr  heap    std::shared_ptr  heap    std::weak_ptr  heap    boost::shared_ptr  heap    is_polymorphic T  heap     Test  \nclass my_provider : public di::config {\n public:\n  // this is default in di::config\n  static auto provider(...) noexcept { return di::providers::stack_over_heap{}; }\n};\n\nint main() {\n  auto injector = di::make_injector my_provider ();\n  injector.create int ();                           // stack\n  std::unique_ptr int  i{injector.create int* ()};  // heap\n  (void)i;\n}  Example    Custom Provider Example   Pool Provider Example    \n---  di::providers::heap  ---  Header  #include  boost/di.hpp   Description  Basic provider creates objects on the heap (always).  Semantics  namespace providers {\n  class heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T     Test  \nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return di::providers::heap{}; }\n};\n\nint main() {\n  auto injector = di::make_injector my_provider ();\n  injector.create int ();                           // heap\n  std::unique_ptr int  i{injector.create int* ()};  // heap\n  (void)i;\n}  Example    Custom Provider Example   Pool Provider Example   Mocks Provider Extension", 
            "title": "Providers"
        }, 
        {
            "location": "/user_guide/index.html#policies", 
            "text": "Header  #include  boost/di.hpp   Description  Policies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via  Configuration .    Note \nBy default Boost.DI has no policies enabled.  Semantics  template  class... TPolicies  requires callable TPolicies... \nauto make_policies(TPolicies...) noexcept;\n\nstruct config : di::config {\n  template class TInjector \n  static auto policies(const TInjector ) noexcept { return make_policies(...); }\n};                                                                        |\n                                                                          |\n// policy                                                                 /\ntemplate class T     -----------------------------------------------------\nvoid operator()(const T );     Expression  Requirement  Description  Returns      TInjector  -  injector  -    make_policies TPolicies...  callable TPolicies...>  Creates policies  callable  list        T  Description  Example      T::type  Type to be created  std::shared_ptr int    T::expected  Decayed 'Interface' type  interface    T::given  Decayed 'Given' type  implementatoin    T::name  Annotation name  my_name    T::arity  Number of constructor arguments  integral_constant int, 3    T::scope  scope  singleton    T::is_root  Is the root object (a type  create  was called with)  true_type / false_type       Note \nIn order for injector to verify policies they have to be created using  config  and passed via  TConfig  in  make_injector \nor set it globally via  BOOST_DI_CFG .  Test  \nclass print_types_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto type) {\n      using arg = typename decltype(type)::type;\n      std::cout   typeid(arg).name()   std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector print_types_policy ();\n  injector.create int ();  // output: int\n}  \nclass print_types_info_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto arg) {\n      using T = decltype(arg);\n      using type = typename T::type;\n      using name = typename T::name;\n      using expected = typename T::expected;\n      using given = typename T::given;\n      using scope = typename T::scope;\n      auto ctor_size = T::arity::value;\n\n      std::cout   ctor_size   std::endl\n                  typeid(type).name()   std::endl\n                  typeid(expected).name()   std::endl\n                  typeid(given).name()   std::endl\n                  typeid(name).name()   std::endl\n                  typeid(scope).name()   std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector print_types_info_policy (\n    di::bind i1 ().to impl1 ()\n  );\n  injector.create std::unique_ptr i1 ();\n}  Example    Custom Policy Example   Types Dumper Extension   UML Dumper Extension    \n---  di::policies::constructible  ---  Header  #include  boost/di.hpp   Description  Constructible policy limits constructor parameters to explicitly allowed.    Note \nBy default constructible policy disables creation of any constructor parameters.  Semantics  namespace policies {\n  struct _ { }; // placeholder\n\n  template class T \n  struct is_bound; // true when type is bound with 'di::bind T '\n\n  template  class T \n  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'\n\n  template class T \n  auto constructible(const T ) noexcept;\n}\n\nnamespace operators {\n  template class X \n  inline auto operator!(const X )\n\n  template class X, class Y \n  inline auto operator (const X , const Y );\n\n  template class X, class Y \n  inline auto operator||(const X , const Y );\n}     Expression  Requirement  Description  Returns      is_bound T  -  Verify whether type  T  is bound  true_type/false_type    is_injected T  -  Verify whether type  T  is injected via  BOOST_DI_INJECT  true_type/false_type       Note \nIn order to allow logic operators using namespace  boost::di::policies::operators  has to be used.  Test  #include  boost/di.hpp \n\n\nclass injected_and_bound : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(\n      constructible(is_injected di::_ {}   is_bound di::_ {})\n    );\n  }\n};\n\nstruct T {\n  BOOST_DI_INJECT(T, int, double) {}\n};\n\nint main() {\n  auto injector = di::make_injector injected_and_bound (\n    di::bind ().to(42)\n  , di::bind ().to(87.0)\n  );\n\n  injector.create T ();\n}  class all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include  boost/di.hpp \n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same di::_, int {} || is_bound di::_ {}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create int ());\n  // di::make_injector().create double (); // compile error\n  assert(42.0 == make_injector(di::bind double ().to(42.0)).create double ());\n}    Note \nSTL type traits are supported and might be combined with Boost.DI traits in order to limit constructor types\nFor example,  std::is_same _, int {} || std::is_constructible _, int, int {} || std::is_base_of int, _ {} , etc...  Example    Custom Policy Example   Types Dumper Extension   UML Dumper Extension", 
            "title": "Policies"
        }, 
        {
            "location": "/user_guide/index.html#concepts", 
            "text": "Concepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.  \n---  di::concepts::boundable  ---  Header  #include  boost/di.hpp   Description  Bindings  type requirement.  Synopsis  template  class TExpected, class TGiven \nconcept bool boundable() {\n  return is_complete TExpected ()\n        is_complete TGiven ()\n        (is_base_of TExpected, TGiven () || is_convertible TGiven, TExpected ());\n}\n\ntemplate  class... Ts \nconcept bool boundable() {\n  return is_supported Ts ()...\n        is_movable Ts ()...\n        (is_base_of injector, Ts ()... || is_base_of dependency, Ts ()...);\n}  Semantics  boundable T \nboundable Ts...      Expression  Description  Returns      Ts...  Bindings to be verified  true_type if constraint is satisfied,  Error  otherwise     Example     Error  type T ::has_disallowed_qualifiers      Description  type  T  has disallowed qualifiers     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind int* ().to(42) /** type int* ::has_disallowed_qualifiers **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_has_disallowed_qualifiers.cpp      Error  type T ::is_abstract      Description  type  T  is abstract    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0, 1 -  no additional info, 2 -  info about why type  T  is abstract     #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 2\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct i {\n  virtual ~i() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct impl : i {};\n\nint main() {\n  di::make_injector(\n    di::bind i ().to impl () /** type impl ::is_abstract **/\n    /** unimplemented pure virtual method 'dummy' in 'impl' **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp      Error  type T ::is_not_related_to      Description  type  T  is not related to type  U     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind int ().to double () /** type double ::is_not_related_to int  **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_not_related_to.cpp      Error  type T ::is_bound_more_than_once      Description  type  T  is bound more than once     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind int .to(42) /** type int ::is_bound_more_than_once **/\n  , di::bind int .to(87) // [di::override]\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp      Error  type T ::is_neither_a_dependency_nor_an_injector      Description  type  T  is neither a dependency nor an injector     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    dummy{} /** type dummy ::is_neither_a_dependency_nor_an_injector **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_neither_a_dependency_nor_an_injector.cpp    \n---  di::concepts::callable  ---  Header  #include  boost/di.hpp   Description  Policy  type requirement.  Synopsis  template  class T \nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}  Semantics  callable T   Example     Error  policy TPolicy ::requires_ call_operator      Description  policy  TPolicy  requires a call operator     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto policies(...) { return di::make_policies(dummy{}); }\n  };\n\n  di::make_injector test_config ();\n  /** policy test_config::dummy ::requires_ call_operator  **/\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/callable_requires_call_operator.cpp    \n---  di::concepts::configurable  ---  Header  #include  boost/di.hpp   Description  Configuration  type requirement.  Synopsis  template  class T \nconcept bool configurable() {\n  return requires(T object) {\n    return providable decltype(T::provider(...))    callable decltype(T::policies(...)) ();\n  }\n}  Semantics  configurable T   Example     Error  config TConfig ::requires_ provider providable_type (...)      Description  config  T  requires only providable and callable types     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config /*: di::config*/ {\n    static auto policies(...) { return di::make_policies(); }\n  };\n\n  di::make_injector test_config ();\n  /** config test_config ::requires_ provider providable_type (...)  **/\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/configurable_requires_callable_and_providable.cpp    \n---  di::concepts::creatable  ---  Header  #include  boost/di.hpp   Description  Requirement for type  T  which is going to be created via  injector .create T ()  Synopsis  namespace type_traits {\n  template class T \n  using ctor_traits; // returns list of constructor parameters\n}\n\ntemplate  class T, class... TArgs \nconcept bool creatable() {\n  return is_constructible T, TArgs... ()  \n         is_constructible TArgs, type_traits::ctor_traits TArgs ... ();\n}  Semantics  creatable T, TArgs...   Example     Error  abstract_type T ::is_not_bound      Description  abstract type  T  is not bound    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'type is not bound, did you forget to add: 'di::bind .to ()'?'     #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr interface ) {}\n};\n\nint main() {\n  di::make_injector().create example (); /** creatable constraint not satisfied **/\n  /** abstract_type interface ::is_not_bound\n   *  type is not bound, did you forget to add: \n   *   'di::bind interface .to implementation ()'?\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp   #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr interface ) {}\n};\n\nint main() {\n  di::injector example  injector = di::make_injector(); /** creatable constraint not satisfied **/\n  /** abstract_type interface ::is_not_bound\n   *  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'?\n   */\n  (void)injector;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp      Error  type T ::has_ambiguous_number_of_constructor_parameters::given Given ::expected Expected      Description  type  T  has ambiguous number of constructor parameters where  Given  were provided but  Expected  were expected    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    BOOST_DI_INJECT_TRAITS(int, int);  // 2 parameters\n    T(int, int, int, int) {}           // 4 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** type T ::has_ambiguous_number_of_constructor_parameters::given 2 ::expected 4 \n   * verify BOOST_DI_INJECT_TRAITS or di::ctor_traits\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_ambiguous_number_of_constructor_parameters.cpp      Error  type T ::has_to_many_constructor_parameters::max Max      Description  type  T  has to many constructor parameter where maximum number is  Max    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'     #define BOOST_DI_CFG_CTOR_LIMIT_SIZE 2  // specify max number of constructor parameters\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int, int, int) {}  // 3 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** type T ::has_to_many_constructor_parameters::max 2 \n   *  increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_to_many_constructor_parameters.cpp      Error  scoped TScope ::is_not_convertible_to T      Description  scope  TScope  is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind .in(scope)'?'     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int*) {}\n  };\n  auto injector = di::make_injector(\n    di::bind int ().in(di::singleton)\n  );\n\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** scoped singleton ::is_not_convertible_to int * \n   *  scoped object is not convertible to the requested type,\n   *    did you mistake the scope: 'di::bind T .in(scope)'?\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_scoped_is_not_convertible_to.cpp      Error  scoped instance ::is_not_convertible_to T      Description  instance is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'instance is not convertible to the requested type, verify binding: 'di::bind .to(value)'?'     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int ) {}\n  };\n  auto injector = di::make_injector(\n    di::bind ().to(42)\n  );\n\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** scoped instance ::is_not_convertible_to int  \n   *  instance is not convertible to the requested type,\n   *    verify binding: 'di::bind T .to(value)'?\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_instance_is_not_convertible_to.cpp     Note \nSuggestions are not supported/displayed by MSVC-2015.   \n---  di::concepts::providable  ---  Header  #include  boost/di.hpp   Description  Provider  type requirement.  Synopsis  namespace type_traits {\n  struct direct;\n  struct uniform;\n  struct stack;\n  struct heap;\n}\n\ntemplate  class T \nconcept bool providable() {\n  return requires(T object) {\n    { object.template get _ (type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n    { object.template is_creatable _ (type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n  }\n}  Semantics  providable T   Example     Error  provider TProvider ::requires_ get      Description  provider  TProvider  requires  get  method     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto provider(...) { return dummy{}; }\n  };\n  di::make_injector test_config (); /** provider test_config::dummy ::requires_ get  **/\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/providable_requires_get.cpp    \n---  di::concepts::scopable  ---  Header  #include  boost/di.hpp   Description  Scope  type requirement.  Synopsis  struct _ {}; // any type\n\ntemplate  class T \nconcept bool scopable() {\n  return requires(T) {\n    typename scope _, _ ::is_referable;\n    { T::scope _, _ {}.try_create() };\n    { T::scope _, _ {}.create() };\n  }\n}  Semantics  scopable T   Example     Error  scope TScope ::requires_ create      Description  scope  TScope  requires  create  method     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    di::bind int ().in(dummy{})); /** scope dummy ::requires_ create  **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/scopable_requires_create.cpp", 
            "title": "Concepts"
        }, 
        {
            "location": "/user_guide/index.html#configuration", 
            "text": "---  di::config  ---  Header  #include  boost/di.hpp   Description  Injector  configuration.  Synopsis  struct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};     Expression  Requirement  Description  Returns      provider()  providable  Creates provider  providable    policies()  callable  Creates policies  callable        Expression  Description      BOOST_DI_CFG  Global configuration allows to customize provider and policies     Semantics  di::make_injector config (...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)  Test  class all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include  boost/di.hpp \n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same di::_, int {} || is_bound di::_ {}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create int ());\n  // di::make_injector().create double (); // compile error\n  assert(42.0 == make_injector(di::bind double ().to(42.0)).create double ());\n}  Example    Configuration Example   Custom Policy Example   Custom Provider Example", 
            "title": "Configuration"
        }, 
        {
            "location": "/examples/index.html", 
            "text": "Hello World\n\n\nBindings\n\n\nDynamic Bindings\n\n\nForward Bindings\n\n\nMultiple Bindings\n\n\nBinding Non-owning Pointer\n\n\nAutomatic Injection\n\n\nConstructor Signature\n\n\nConstructor Injection\n\n\nMultiple Interface\n\n\nAnnotations\n\n\nDeduce Scope\n\n\nCustom Scope\n\n\nEager Singletons\n\n\nModules\n\n\nModules (hpp/cpp)\n\n\nCustom Policy\n\n\nCustom Provider\n\n\nPool Provider\n\n\nConfiguration\n\n\n\n\n\n\nHello World\n\n\n#include \nboost/di.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace di = boost::di;\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n};\nstruct world : iworld {\n  world() { std::cout \n \n world!\n \n std::endl; }\n};\n\nstruct hello {\n  explicit hello(int i) {\n    assert(42 == i);\n    std::cout \n \nhello\n;\n  }\n};\n\nstruct example {\n  hello h;\n  iworld\n w;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\niworld\n().to\nworld\n()\n  , di::bind\n().to(42)\n  );\n\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/try_it.cpp\n\n\n\n\nBindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct service {\n  BOOST_DI_INJECT(service, const std::shared_ptr\ninterface1\n sp, bool b, int i, std::function\nint()\n f,\n                  (named = int_name) const int ni)\n      : sp(sp) {\n    assert(dynamic_cast\nimplementation1_2*\n(sp.get()));  // overridden\n    assert(!b);                                          // default initialization\n    assert(i == 42);\n    assert(f() == 87);\n    assert(ni == 123);\n  }\n\n  std::shared_ptr\ninterface1\n sp;\n};\n\nstruct app {\n  BOOST_DI_INJECT(app, service copy, std::shared_ptr\ninterface1\n sp, std::unique_ptr\ninterface2\n ap, int i,\n                  (named = some_name) const std::string\n s, float\n f, const double\n d)\n      : str(s), f(f), d(d) {\n    assert(dynamic_cast\nimplementation2*\n(ap.get()));\n    assert(dynamic_cast\nimplementation1_2*\n(sp.get()));  // overridden\n    assert(copy.sp.get() == sp.get());\n    assert(i == 42);\n    assert(str == \nmy_text\n);\n    assert(f == 0.f);\n    assert(d == 0.f);\n  }\n\n  app\n operator=(const app\n) = delete;\n\n  std::string str;\n  float\n f;\n  const double\n d;\n};\n\nint main() {\n  float f = 0.f;\n  double d = 0.0;\n\n  /*\ncreate injector with `interface` binding to `implementation1`\n*/\n  auto config = [] { return di::make_injector(di::bind\ninterface1\n().to\nimplementation1\n()); };\n\n  /*\ncreate injector with configuration\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface2\n().to\nimplementation2\n()\n  , di::bind\nint\n().to(42)\n  , di::bind\nstd::string\n().named(some_name).to(\nmy_text\n)\n  , di::bind\n().to(f)\n  , di::bind\n().to(d)\n  , di::bind\nstd::function\nint()\n().to([] { return 87; })\n  , di::bind\n().named(int_name).to(123)\n  , config()\n  , di::bind\ninterface1\n().to(std::make_shared\nimplementation1_2\n())[di::override]\n  );\n\n  /*\ncreate `service_app`\n*/\n  auto service_app = injector.create\napp\n();\n\n  /*\nverify parameter `f` affection by `service_app`\n*/\n  service_app.f = 42.f;\n  assert(f == 42.f);\n\n  d = 42.f;\n  assert(service_app.d == 42.f);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp\n\n\n\n\nDynamic Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\nmodule configuration\n*/\nauto dynamic_bindings = [](eid\n id) {\n  return di::make_injector(\n      /*\nbind `interface` to lazy lambda expression\n*/\n      di::bind\ninterface\n().to([\n](const auto\n injector) -\n std::shared_ptr\ninterface\n {\n        switch (id) {\n          default:\n            return nullptr;\n          case e1:\n            return injector.template create\nstd::shared_ptr\nimplementation1\n();\n          case e2:\n            return injector.template create\nstd::shared_ptr\nimplementation2\n();\n        }\n\n        return nullptr;\n      }));\n};\n\nint main() {\n  auto id = e1;\n\n  /*\ncreate interface with `id = e1`\n*/\n  auto injector = di::make_injector(dynamic_bindings(id));\n  assert(dynamic_cast\nimplementation1*\n(injector.create\nstd::shared_ptr\ninterface\n().get()));\n\n  id = e2;\n  /*\ncreate interface with `id = e2`\n*/\n  assert(dynamic_cast\nimplementation2*\n(injector.create\nstd::shared_ptr\ninterface\n().get()));\n  (void)id;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp\n\n\n\n\nForward Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nclass interface;\nclass implementation;\n\nauto configuration = [] {\n  return di::make_injector(\n    /*\nbinding using fwd declarations, no checking whether types are related*/\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n};\n\n/*\nbinding using fwd declarations, no checking whether types are related*/\nclass interface {\n public:\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\nclass implementation : public interface {\n public:\n  void dummy() override {}\n};\n\nint main() {\n  /*\nmake injector configuration\n*/\n  auto injector = configuration();\n  assert(dynamic_cast\nimplementation*\n(injector.create\nstd::unique_ptr\ninterface\n().get()));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp\n\n\n\n\nMultiple Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct example {\n  example(std::vector\nstd::unique_ptr\ninterface\n v, std::vector\nint\n i) {\n    assert(v.size() == 4);\n    assert(dynamic_cast\nimplementation1*\n(v[0].get()));\n    assert(dynamic_cast\nimplementation2*\n(v[1].get()));\n    assert(dynamic_cast\nimplementation1*\n(v[2].get()));\n    assert(dynamic_cast\nimplementation2*\n(v[3].get()));\n\n    assert(i.size() == 7);\n    assert(i[0] == 1);\n    assert(i[1] == 2);\n    assert(i[2] == 3);\n    assert(i[3] == 5);\n    assert(i[4] == 8);\n    assert(i[5] == 13);\n    assert(i[6] == 21);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint[]\n().to({1, 2, 3, 5, 8, 13, 21})\n  , di::bind\ninterface* []\n().to\nimplementation1, implementation2, interface, di::named\nclass Implementation2\n()\n  , di::bind\ninterface\n().to\nimplementation1\n()  // \n------------------/                         |\n  , di::bind\ninterface\n().named\nclass Implementation2\n().to\nimplementation2\n()  // \n-------------/\n  );\n\n  injector.create\nexample\n();\n\n  assert(injector.create\nstd::vector\nint\n().size() == 7);\n  assert(injector.create\nstd::set\nint\n().size() == 7);\n\n  assert(injector.create\nstd::vector\nstd::shared_ptr\ninterface\n().size() == 4);\n  assert(injector.create\nstd::set\nstd::shared_ptr\ninterface\n().size() == 4);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp\n\n\n\n\nBinding Non-owning Pointer\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nusing Pointer = int;\n\nauto module(Pointer* ptr) { return di::bind\nPointer\n().to(*ptr); }\n\nstruct app {\n  app(Pointer\n ptr) { assert(42 == ptr); }\n};\n\nint main() {\n  di::aux::owner\nPointer*\n ptr{new Pointer{42}};\n\n  auto injector = di::make_injector(module(ptr));\n  injector.create\napp\n();\n\n  delete ptr;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_non_owning_ptr.cpp\n\n\n\n\nAutomatic Injection\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n/*\nambiguous constructor with 2 parameters\n*/\nstruct example1 {\n  /*\nambiguous `example1` constructor taking 2 parameters\n*/\n  example1(double, int) { assert(false); }\n\n  /*\nambiguous `example1` constructor taking 2 parameters - marked to be injected by `...`\n*/\n  example1(int i, double d, ...) {\n    assert(i == 42);\n    assert(d == 87.0);\n  }\n};\n\nstruct example2 {\n  /*\nconstructor with 1 parameter marked to be injected by `...`\n*/\n  explicit example2(int i, ...) { assert(i == 42); }\n\n  /*\nconstructor with 3 parameters, but still constructor with 1 and `...` will be chosen\n*/\n  example2(int, double, float) { assert(false); }\n};\n\nint main() {\n  /*\nmake injector and bind named parameters\n*/\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n\n  /*\ncreate `example1`\n*/\n  injector.create\nexample1\n();\n\n  /*\ncreate `example2`\n*/\n  injector.create\nexample2\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp\n\n\n\n\nConstructor Signature\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ndefine `example` class as usual\n*/\nclass example {\n public:\n  example(std::unique_ptr\ninterface1\n up, std::shared_ptr\ninterface2\n sp, int i) {\n    assert(dynamic_cast\nimplementation1*\n(up.get()));\n    assert(dynamic_cast\nimplementation2*\n(sp.get()));\n    assert(42 == i);\n  }\n};\n\n/*\ndefine `example` class with different parameters order - won't require any changes in injector configuration\n*/\nclass example_with_different_parameters_order {\n public:\n  example_with_different_parameters_order(std::shared_ptr\ninterface2\n sp, int i, std::unique_ptr\ninterface1\n up) {\n    assert(dynamic_cast\nimplementation1*\n(up.get()));\n    assert(dynamic_cast\nimplementation2*\n(sp.get()));\n    assert(42 == i);\n  }\n};\n\n/*\ndefine `example` class with different parameters order and different types - won't require any changes in injector\n * configuration\n*/\nclass example_with_different_parameters_order_and_types {\n public:\n  example_with_different_parameters_order_and_types(std::unique_ptr\ninterface2\n sp, const int\n i, interface1* up) : up_(up) {\n    assert(dynamic_cast\nimplementation1*\n(up));\n    assert(dynamic_cast\nimplementation2*\n(sp.get()));\n    assert(42 == i);\n  }\n\n  // in order to delete pointer - Boost.DI always transfer ownership to user in case of pointers\n  std::shared_ptr\ninterface1\n up_;\n};\n\nint main() {\n  /*\nmake injector\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface1\n().to\nimplementation1\n()\n  , di::bind\ninterface2\n().to\nimplementation2\n()\n  , di::bind\nint\n().to(42)\n  );\n\n  /*\ncreate different examples using the same injector configuration\n*/\n  injector.create\nexample\n();\n  injector.create\nexample_with_different_parameters_order\n();\n  injector.create\nexample_with_different_parameters_order_and_types\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp\n\n\n\n\nConstructor Injection\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto name = [] {};\n\nstruct ctor_inject {\n  /*\nconstructor with intrusive named parameter explicitly selected\n*/\n  BOOST_DI_INJECT(ctor_inject, int i1, (named = name) int i2) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_inject_traits {\n  /*\nconstructor with less intrusive named parameter using traits\n*/\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n  explicit ctor_inject_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_di_traits {\n  /*\nclass without any changes\n*/\n  explicit ctor_di_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nnamespace boost {\nnamespace di {\n\ntemplate \n\nstruct ctor_traits\nctor_di_traits\n {\n  /*\nno intrusive way of defining named parameters\n*/\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n};\n\n}  // namespace di\n}  // namespace boost\n\nstruct ctor_inject_traits_no_limits {\n  /*\nconstructor with 20 parameters\n*/\n  using boost_di_inject__ =\n      di::inject\nint, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int\n;\n\n  ctor_inject_traits_no_limits(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int,\n                               int) {}\n};\n\nint main() {\n  /*\nmake injector\n*/\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(name).to(42)\n  );\n\n  /*\ncreate dependencies\n*/\n  injector.create\nctor_inject\n();\n  injector.create\nctor_inject_traits\n();\n  injector.create\nctor_di_traits\n();\n\n  injector.create\nctor_inject_traits_no_limits\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp\n\n\n\n\nMultiple Interface\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass multiple_interfaces {\n public:\n  multiple_interfaces(const std::shared_ptr\ninterface1\n interface1_, const std::shared_ptr\ninterface2\n interface2_) {\n    assert(dynamic_cast\nimplementation*\n(interface1_.get()));\n    assert(dynamic_cast\nimplementation*\n(interface2_.get()));\n    assert(static_cast\nimplementation*\n(interface1_.get()) == static_cast\nimplementation*\n(interface2_.get()));\n  }\n};\n\nint main() {\n  /*\ncreate injector with binding `implementation` to `interface1` and `interface2` using `di::any_of`\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface1, interface2\n().to\nimplementation\n()\n  );\n\n  injector.create\nmultiple_interfaces\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_interfaces.cpp\n\n\n\n\nAnnotations\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto int_1 = [] {};\nstruct int_2_t {\n} int_2;\n\nclass annotations1 {\n public:\n  /*\nConstructor with named parameters of the same `int` type\n*/\n  BOOST_DI_INJECT(annotations1, (named = int_1) int i1, (named = int_2) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nclass annotations2 {\n public:\n  /*\nConstructor with named parameters of the same `int` type\n*/\n  BOOST_DI_INJECT(annotations2, (named = int_1) int i1, (named = int_2) int i2, int i3);\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nannotations2::annotations2(int i1, int i2, int i3) {\n  assert(i1 == 42);\n  assert(i2 == 87);\n  assert(i3 == 123);\n}\n\n\nclass annotations3 {\n public:\n  /*\nConstructor with named parameters of the same `int` type\n*/\n  BOOST_DI_INJECT(annotations3, (named = \nint1\n_s) int i1, (named = \nint2\n_s) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nint main() {\n  {\n    /*\nmake injector and bind named parameters\n*/\n    auto injector = di::make_injector(\n      di::bind\nint\n().named(int_1).to(42)\n    , di::bind\nint\n().named(int_2).to(87)\n    , di::bind\nint\n().to(123)\n    );\n\n    /*\ncreate `annotations`\n*/\n    injector.create\nannotations1\n();\n    injector.create\nannotations2\n();\n  }\n\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp\n\n\n\n\nDeduce Scope\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct dependency1 {\n  dependency1(std::shared_ptr\ninterface\n spi /*shared*/\n              ,\n              const std::shared_ptr\ninterface\n spi_ /*shared*/)\n      : spi_(spi), spi__(spi_) {\n    assert(spi.get() == spi_.get());\n  }\n\n  std::shared_ptr\ninterface\n spi_;\n  std::shared_ptr\ninterface\n spi__;\n};\n\nstruct dependency2 {\n  dependency2(std::shared_ptr\ninterface\n spi /*shared*/, int i /*unique*/) : spi_(spi) { assert(i == 0); }\n\n  std::shared_ptr\ninterface\n spi_;\n};\n\nstruct example {\n  example(std::unique_ptr\ndependency1\n dependency1_ /*unique*/\n          ,\n          const dependency2\n dependency2_ /*unique temporary*/) {\n    assert(dependency2_.spi_.get() == dependency1_-\nspi_.get());\n    assert(dependency2_.spi_.get() == dependency1_-\nspi__.get());\n  }\n};\n\nint main() {\n  /*\ncreate injector with deduced `interface`\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()  // =\n di::bind\ninterface\n().to\nimplementation\n().in(di::deduce)\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp\n\n\n\n\nCustom Scope\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n/*\ndefine scope class\n*/\nclass custom_scope {\n public:\n  /*\ndefine `entry`, `exit` actions\n*/\n  class entry {};\n  class exit {};\n\n  template \nclass T, class\n\n  class scope {\n    /*\ndefine wrapper for shared_ptr conversion\n*/\n    class custom_wrapper {\n     public:\n      custom_wrapper(const std::shared_ptr\nT\n object)  // non explicit\n          : object_(object) {}\n\n      /*\nconversion operator to shared_ptr\n*/\n      inline operator std::shared_ptr\nT\n() const noexcept { return object_; }\n\n      std::shared_ptr\nT\n object_;\n    };\n\n   public:\n    template \nclass\n\n    using is_referable = std::false_type;\n\n    template \nclass, class, class TProvider\n\n    static custom_wrapper try_create(const TProvider\n);\n\n    /*\ncreate shared_ptr when in scope out of provider pointer\n*/\n    template \nclass, class, class TProvider\n\n    custom_wrapper create(const TProvider\n provider) const noexcept {\n      return std::shared_ptr\nT\n{provider.get()};\n    }\n  };\n};\n\nstruct example {\n  explicit example(const std::shared_ptr\nint\n sp) : sp_(sp) {}\n  std::shared_ptr\nint\n sp_;\n};\n\nint main() {\n  /*\ncreate injector with `int` in `custom scope`\n*/\n  auto injector = di::make_injector(\n    di::bind\nint\n().in(custom_scope{})\n  );\n\n  assert(injector.create\nexample\n().sp_);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_scope.cpp\n\n\n\n\nEager Singletons\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto configuration = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n().in(di::singleton)\n  , di::bind\nint\n().to(42)\n  );\n};\n\nstruct example {\n  example(int i, std::shared_ptr\ninterface\n object) {\n    assert(42 == i);\n    assert(dynamic_cast\nimplementation*\n(object.get()));\n  }\n};\n\nint main() {\n  /*\nmake injector configuration\n*/\n  auto injector = di::make_injector(configuration());\n  assert(0 == implementation::ctor_calls());\n\n  /*\neagerly initialize singletons\n*/\n  eager_singletons(injector);\n  assert(1 == implementation::ctor_calls());\n\n  /*\ncreate `example` with already initialized singletons\n*/\n  injector.create\nexample\n();\n  assert(1 == implementation::ctor_calls());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp\n\n\n\n\nModules\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct data {\n  std::shared_ptr\ninterface\n sp;\n};\n\nstruct app {\n  app(std::unique_ptr\ninterface\n up, int i, double d, const data\n data) {\n    assert(dynamic_cast\nimplementation1*\n(up.get()));\n    assert(i == 42);\n    assert(d == 87.0);\n    assert(dynamic_cast\nimplementation2*\n(data.sp.get()));\n  }\n};\n\n/*\n`module1` configuration\n*/\nauto module1 = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation1\n()\n  );\n};\n\n/*\n`module2` configuration\n*/\nauto module2(const int\n i) {\n  return di::make_injector(\n    di::bind\nint\n().to(i)\n  );\n}\n\n/*\nmodule configuration with exposed `data`\n*/\nauto exposed_module = []() -\n di::injector\nconst data\n {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation2\n()\n  );\n};\n\nint main() {\n  constexpr auto i = 42;\n  constexpr auto d = 87.0;\n\n  /*\nmodule configuration with movable injector\n*/\n  auto movable_injector = di::make_injector(\n    di::bind\ndouble\n().to(d)\n  );\n\n  /*\ncreate injector and pass `module1`, `module2` and `exposed_module`\n*/\n  auto injector = di::make_injector(\n    module1()\n  , module2(i)\n  , exposed_module()\n  , std::move(movable_injector)\n  );\n\n  /*\ncreate `app`\n*/\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp\n\n\n\n\nModules (hpp/cpp)\n\n\n\n\nSee \nhttps://github.com/boost-experimental/di/tree/cpp14/example/modules\n\n\n\n\nCustom Policy\n\n\nclass custom_policy;\n#define BOOST_DI_CFG custom_policy\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nclass custom_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(is_bound\ndi::_\n{}));\n  }\n};\n\nstruct example {\n  example(int, double) {}\n};\n\nint main() {\n  /*\ncreate shared_ptr `example` with per injector policy setting\n*/\n  {\n    auto injector = di::make_injector\ncustom_policy\n(\n      di::bind\nint\n().to(42)\n    , di::bind\ndouble\n().to(87.0)\n    );\n\n    injector.create\nexample\n();\n  }\n\n  /*\ncreate shared_ptr `example` with global policy setting\n*/\n  {\n    auto injector = di::make_injector(\n      di::bind\nint\n().to(42)\n    , di::bind\ndouble\n().to(87.0)\n    );\n\n    injector.create\nexample\n();\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp\n\n\n\n\nCustom Provider\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ndefine `example` class as usual\n*/\nstruct example {\n  explicit example(int i, std::unique_ptr\ninterface\n up) {\n    assert(i == 42);\n    assert(dynamic_cast\nimplementation*\n(up.get()));\n  }\n};\n\n/*\ndefine `custom provider`\n*/\nstruct custom_provider {\n  template \nclass...\n\n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template \nclass T, class TMemory, class... TArgs\n\n  auto get(const di::type_traits::direct\n, const TMemory\n  // stack/heap\n           ,\n           TArgs\n... args) const {\n    return new T(std::forward\nTArgs\n(args)...);\n  }\n\n  template \nclass T, class TMemory, class... TArgs\n\n  auto get(const di::type_traits::uniform\n, const TMemory\n  // stack/heap\n           ,\n           TArgs\n... args) const {\n    return new T{std::forward\nTArgs\n(args)...};\n  }\n};\n\n/*\noverride `di` provider configuration\n*/\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return custom_provider{}; }\n};\n\nint main() {\n  /*\nmake injector with simple configuration\n*/\n  auto injector = di::make_injector\nconfig\n(\n    di::bind\nint\n().to(42)\n  , di::bind\ninterface\n().to\nimplementation\n()\n  );\n\n  /*\ncreate `example` using `custom_provider`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp\n\n\n\n\nPool Provider\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ndefine `pool provider`\n*/\nstruct pool_provider {\n  template \nclass...\n\n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template \nclass T, class TInitialization, class TMemory, class... TArgs\n\n  auto get(const TInitialization\n  // direct/uniform\n           ,\n           const TMemory\n  // stack/heap\n           ,\n           TArgs\n... args) const {\n    auto memory = pool_allocator::allocate\nT\n();\n    return std::unique_ptr\nT, pool_deleter\n{new (memory) T(std::forward\nTArgs\n(args)...)};\n  }\n};\n\n/*\noverride `di` provider configuration\n*/\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return pool_provider{}; }\n};\n\n/*\ndefine `example` class as usual\n*/\nstruct example {\n  explicit example(int i, std::unique_ptr\ninterface, pool_deleter\n up, std::shared_ptr\ninterface\n sp) {\n    assert(i == 42);\n    assert(dynamic_cast\nimplementation*\n(up.get()));\n    assert(dynamic_cast\nimplementation*\n(sp.get()));\n  }\n};\n\nint main() {\n  /*\nmake injector with simple configuration\n*/\n  auto injector = di::make_injector\nconfig\n(\n    di::bind\nint\n().to(42)\n  , di::bind\ninterface\n().to\nimplementation\n()\n  );\n\n  /*\ncreate `example` using configuration with `pool_provider`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp\n\n\n\n\nConfiguration\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n#if (BOOST_DI_VERSION \n= 1'0'0)\n  std::cout \n \nstable\n;\n#else\n  std::cout \n \nunstable\n;\n#endif\n  std::cout \n \n version of boost.di [\n \n BOOST_DI_VERSION \n \n]\n \n std::endl;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/configuration.cpp", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/index.html#hello-world", 
            "text": "#include  boost/di.hpp \n#include  cassert \n#include  iostream \n\nnamespace di = boost::di;\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n};\nstruct world : iworld {\n  world() { std::cout     world!    std::endl; }\n};\n\nstruct hello {\n  explicit hello(int i) {\n    assert(42 == i);\n    std::cout    hello ;\n  }\n};\n\nstruct example {\n  hello h;\n  iworld  w;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind iworld ().to world ()\n  , di::bind ().to(42)\n  );\n\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/try_it.cpp", 
            "title": "Hello World"
        }, 
        {
            "location": "/examples/index.html#bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct service {\n  BOOST_DI_INJECT(service, const std::shared_ptr interface1  sp, bool b, int i, std::function int()  f,\n                  (named = int_name) const int ni)\n      : sp(sp) {\n    assert(dynamic_cast implementation1_2* (sp.get()));  // overridden\n    assert(!b);                                          // default initialization\n    assert(i == 42);\n    assert(f() == 87);\n    assert(ni == 123);\n  }\n\n  std::shared_ptr interface1  sp;\n};\n\nstruct app {\n  BOOST_DI_INJECT(app, service copy, std::shared_ptr interface1  sp, std::unique_ptr interface2  ap, int i,\n                  (named = some_name) const std::string  s, float  f, const double  d)\n      : str(s), f(f), d(d) {\n    assert(dynamic_cast implementation2* (ap.get()));\n    assert(dynamic_cast implementation1_2* (sp.get()));  // overridden\n    assert(copy.sp.get() == sp.get());\n    assert(i == 42);\n    assert(str ==  my_text );\n    assert(f == 0.f);\n    assert(d == 0.f);\n  }\n\n  app  operator=(const app ) = delete;\n\n  std::string str;\n  float  f;\n  const double  d;\n};\n\nint main() {\n  float f = 0.f;\n  double d = 0.0;\n\n  /* create injector with `interface` binding to `implementation1` */\n  auto config = [] { return di::make_injector(di::bind interface1 ().to implementation1 ()); };\n\n  /* create injector with configuration */\n  auto injector = di::make_injector(\n    di::bind interface2 ().to implementation2 ()\n  , di::bind int ().to(42)\n  , di::bind std::string ().named(some_name).to( my_text )\n  , di::bind ().to(f)\n  , di::bind ().to(d)\n  , di::bind std::function int() ().to([] { return 87; })\n  , di::bind ().named(int_name).to(123)\n  , config()\n  , di::bind interface1 ().to(std::make_shared implementation1_2 ())[di::override]\n  );\n\n  /* create `service_app` */\n  auto service_app = injector.create app ();\n\n  /* verify parameter `f` affection by `service_app` */\n  service_app.f = 42.f;\n  assert(f == 42.f);\n\n  d = 42.f;\n  assert(service_app.d == 42.f);\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp", 
            "title": "Bindings"
        }, 
        {
            "location": "/examples/index.html#dynamic-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* module configuration */\nauto dynamic_bindings = [](eid  id) {\n  return di::make_injector(\n      /* bind `interface` to lazy lambda expression */\n      di::bind interface ().to([ ](const auto  injector) -  std::shared_ptr interface  {\n        switch (id) {\n          default:\n            return nullptr;\n          case e1:\n            return injector.template create std::shared_ptr implementation1 ();\n          case e2:\n            return injector.template create std::shared_ptr implementation2 ();\n        }\n\n        return nullptr;\n      }));\n};\n\nint main() {\n  auto id = e1;\n\n  /* create interface with `id = e1` */\n  auto injector = di::make_injector(dynamic_bindings(id));\n  assert(dynamic_cast implementation1* (injector.create std::shared_ptr interface ().get()));\n\n  id = e2;\n  /* create interface with `id = e2` */\n  assert(dynamic_cast implementation2* (injector.create std::shared_ptr interface ().get()));\n  (void)id;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp", 
            "title": "Dynamic Bindings"
        }, 
        {
            "location": "/examples/index.html#forward-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nclass interface;\nclass implementation;\n\nauto configuration = [] {\n  return di::make_injector(\n    /* binding using fwd declarations, no checking whether types are related*/\n    di::bind interface ().to implementation ()\n  );\n};\n\n/* binding using fwd declarations, no checking whether types are related*/\nclass interface {\n public:\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\nclass implementation : public interface {\n public:\n  void dummy() override {}\n};\n\nint main() {\n  /* make injector configuration */\n  auto injector = configuration();\n  assert(dynamic_cast implementation* (injector.create std::unique_ptr interface ().get()));\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp", 
            "title": "Forward Bindings"
        }, 
        {
            "location": "/examples/index.html#multiple-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct example {\n  example(std::vector std::unique_ptr interface  v, std::vector int  i) {\n    assert(v.size() == 4);\n    assert(dynamic_cast implementation1* (v[0].get()));\n    assert(dynamic_cast implementation2* (v[1].get()));\n    assert(dynamic_cast implementation1* (v[2].get()));\n    assert(dynamic_cast implementation2* (v[3].get()));\n\n    assert(i.size() == 7);\n    assert(i[0] == 1);\n    assert(i[1] == 2);\n    assert(i[2] == 3);\n    assert(i[3] == 5);\n    assert(i[4] == 8);\n    assert(i[5] == 13);\n    assert(i[6] == 21);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int[] ().to({1, 2, 3, 5, 8, 13, 21})\n  , di::bind interface* [] ().to implementation1, implementation2, interface, di::named class Implementation2 ()\n  , di::bind interface ().to implementation1 ()  //  ------------------/                         |\n  , di::bind interface ().named class Implementation2 ().to implementation2 ()  //  -------------/\n  );\n\n  injector.create example ();\n\n  assert(injector.create std::vector int ().size() == 7);\n  assert(injector.create std::set int ().size() == 7);\n\n  assert(injector.create std::vector std::shared_ptr interface ().size() == 4);\n  assert(injector.create std::set std::shared_ptr interface ().size() == 4);\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp", 
            "title": "Multiple Bindings"
        }, 
        {
            "location": "/examples/index.html#binding-non-owning-pointer", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nusing Pointer = int;\n\nauto module(Pointer* ptr) { return di::bind Pointer ().to(*ptr); }\n\nstruct app {\n  app(Pointer  ptr) { assert(42 == ptr); }\n};\n\nint main() {\n  di::aux::owner Pointer*  ptr{new Pointer{42}};\n\n  auto injector = di::make_injector(module(ptr));\n  injector.create app ();\n\n  delete ptr;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_non_owning_ptr.cpp", 
            "title": "Binding Non-owning Pointer"
        }, 
        {
            "location": "/examples/index.html#automatic-injection", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n/* ambiguous constructor with 2 parameters */\nstruct example1 {\n  /* ambiguous `example1` constructor taking 2 parameters */\n  example1(double, int) { assert(false); }\n\n  /* ambiguous `example1` constructor taking 2 parameters - marked to be injected by `...` */\n  example1(int i, double d, ...) {\n    assert(i == 42);\n    assert(d == 87.0);\n  }\n};\n\nstruct example2 {\n  /* constructor with 1 parameter marked to be injected by `...` */\n  explicit example2(int i, ...) { assert(i == 42); }\n\n  /* constructor with 3 parameters, but still constructor with 1 and `...` will be chosen */\n  example2(int, double, float) { assert(false); }\n};\n\nint main() {\n  /* make injector and bind named parameters */\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n\n  /* create `example1` */\n  injector.create example1 ();\n\n  /* create `example2` */\n  injector.create example2 ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp", 
            "title": "Automatic Injection"
        }, 
        {
            "location": "/examples/index.html#constructor-signature", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* define `example` class as usual */\nclass example {\n public:\n  example(std::unique_ptr interface1  up, std::shared_ptr interface2  sp, int i) {\n    assert(dynamic_cast implementation1* (up.get()));\n    assert(dynamic_cast implementation2* (sp.get()));\n    assert(42 == i);\n  }\n};\n\n/* define `example` class with different parameters order - won't require any changes in injector configuration */\nclass example_with_different_parameters_order {\n public:\n  example_with_different_parameters_order(std::shared_ptr interface2  sp, int i, std::unique_ptr interface1  up) {\n    assert(dynamic_cast implementation1* (up.get()));\n    assert(dynamic_cast implementation2* (sp.get()));\n    assert(42 == i);\n  }\n};\n\n/* define `example` class with different parameters order and different types - won't require any changes in injector\n * configuration */\nclass example_with_different_parameters_order_and_types {\n public:\n  example_with_different_parameters_order_and_types(std::unique_ptr interface2  sp, const int  i, interface1* up) : up_(up) {\n    assert(dynamic_cast implementation1* (up));\n    assert(dynamic_cast implementation2* (sp.get()));\n    assert(42 == i);\n  }\n\n  // in order to delete pointer - Boost.DI always transfer ownership to user in case of pointers\n  std::shared_ptr interface1  up_;\n};\n\nint main() {\n  /* make injector */\n  auto injector = di::make_injector(\n    di::bind interface1 ().to implementation1 ()\n  , di::bind interface2 ().to implementation2 ()\n  , di::bind int ().to(42)\n  );\n\n  /* create different examples using the same injector configuration */\n  injector.create example ();\n  injector.create example_with_different_parameters_order ();\n  injector.create example_with_different_parameters_order_and_types ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp", 
            "title": "Constructor Signature"
        }, 
        {
            "location": "/examples/index.html#constructor-injection", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto name = [] {};\n\nstruct ctor_inject {\n  /* constructor with intrusive named parameter explicitly selected */\n  BOOST_DI_INJECT(ctor_inject, int i1, (named = name) int i2) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_inject_traits {\n  /* constructor with less intrusive named parameter using traits */\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n  explicit ctor_inject_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_di_traits {\n  /* class without any changes */\n  explicit ctor_di_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nnamespace boost {\nnamespace di {\n\ntemplate  \nstruct ctor_traits ctor_di_traits  {\n  /* no intrusive way of defining named parameters */\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n};\n\n}  // namespace di\n}  // namespace boost\n\nstruct ctor_inject_traits_no_limits {\n  /* constructor with 20 parameters */\n  using boost_di_inject__ =\n      di::inject int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int ;\n\n  ctor_inject_traits_no_limits(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int,\n                               int) {}\n};\n\nint main() {\n  /* make injector */\n  auto injector = di::make_injector(\n    di::bind int ().named(name).to(42)\n  );\n\n  /* create dependencies */\n  injector.create ctor_inject ();\n  injector.create ctor_inject_traits ();\n  injector.create ctor_di_traits ();\n\n  injector.create ctor_inject_traits_no_limits ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp", 
            "title": "Constructor Injection"
        }, 
        {
            "location": "/examples/index.html#multiple-interface", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass multiple_interfaces {\n public:\n  multiple_interfaces(const std::shared_ptr interface1  interface1_, const std::shared_ptr interface2  interface2_) {\n    assert(dynamic_cast implementation* (interface1_.get()));\n    assert(dynamic_cast implementation* (interface2_.get()));\n    assert(static_cast implementation* (interface1_.get()) == static_cast implementation* (interface2_.get()));\n  }\n};\n\nint main() {\n  /* create injector with binding `implementation` to `interface1` and `interface2` using `di::any_of` */\n  auto injector = di::make_injector(\n    di::bind interface1, interface2 ().to implementation ()\n  );\n\n  injector.create multiple_interfaces ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_interfaces.cpp", 
            "title": "Multiple Interface"
        }, 
        {
            "location": "/examples/index.html#annotations", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto int_1 = [] {};\nstruct int_2_t {\n} int_2;\n\nclass annotations1 {\n public:\n  /* Constructor with named parameters of the same `int` type */\n  BOOST_DI_INJECT(annotations1, (named = int_1) int i1, (named = int_2) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nclass annotations2 {\n public:\n  /* Constructor with named parameters of the same `int` type */\n  BOOST_DI_INJECT(annotations2, (named = int_1) int i1, (named = int_2) int i2, int i3);\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nannotations2::annotations2(int i1, int i2, int i3) {\n  assert(i1 == 42);\n  assert(i2 == 87);\n  assert(i3 == 123);\n}\n\n\nclass annotations3 {\n public:\n  /* Constructor with named parameters of the same `int` type */\n  BOOST_DI_INJECT(annotations3, (named =  int1 _s) int i1, (named =  int2 _s) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nint main() {\n  {\n    /* make injector and bind named parameters */\n    auto injector = di::make_injector(\n      di::bind int ().named(int_1).to(42)\n    , di::bind int ().named(int_2).to(87)\n    , di::bind int ().to(123)\n    );\n\n    /* create `annotations` */\n    injector.create annotations1 ();\n    injector.create annotations2 ();\n  }   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/index.html#deduce-scope", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct dependency1 {\n  dependency1(std::shared_ptr interface  spi /*shared*/\n              ,\n              const std::shared_ptr interface  spi_ /*shared*/)\n      : spi_(spi), spi__(spi_) {\n    assert(spi.get() == spi_.get());\n  }\n\n  std::shared_ptr interface  spi_;\n  std::shared_ptr interface  spi__;\n};\n\nstruct dependency2 {\n  dependency2(std::shared_ptr interface  spi /*shared*/, int i /*unique*/) : spi_(spi) { assert(i == 0); }\n\n  std::shared_ptr interface  spi_;\n};\n\nstruct example {\n  example(std::unique_ptr dependency1  dependency1_ /*unique*/\n          ,\n          const dependency2  dependency2_ /*unique temporary*/) {\n    assert(dependency2_.spi_.get() == dependency1_- spi_.get());\n    assert(dependency2_.spi_.get() == dependency1_- spi__.get());\n  }\n};\n\nint main() {\n  /* create injector with deduced `interface` */\n  auto injector = di::make_injector(\n    di::bind interface ().to implementation ()  // =  di::bind interface ().to implementation ().in(di::deduce)\n  );\n\n  /* create `example` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp", 
            "title": "Deduce Scope"
        }, 
        {
            "location": "/examples/index.html#custom-scope", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n/* define scope class */\nclass custom_scope {\n public:\n  /* define `entry`, `exit` actions */\n  class entry {};\n  class exit {};\n\n  template  class T, class \n  class scope {\n    /* define wrapper for shared_ptr conversion */\n    class custom_wrapper {\n     public:\n      custom_wrapper(const std::shared_ptr T  object)  // non explicit\n          : object_(object) {}\n\n      /* conversion operator to shared_ptr */\n      inline operator std::shared_ptr T () const noexcept { return object_; }\n\n      std::shared_ptr T  object_;\n    };\n\n   public:\n    template  class \n    using is_referable = std::false_type;\n\n    template  class, class, class TProvider \n    static custom_wrapper try_create(const TProvider );\n\n    /* create shared_ptr when in scope out of provider pointer */\n    template  class, class, class TProvider \n    custom_wrapper create(const TProvider  provider) const noexcept {\n      return std::shared_ptr T {provider.get()};\n    }\n  };\n};\n\nstruct example {\n  explicit example(const std::shared_ptr int  sp) : sp_(sp) {}\n  std::shared_ptr int  sp_;\n};\n\nint main() {\n  /* create injector with `int` in `custom scope` */\n  auto injector = di::make_injector(\n    di::bind int ().in(custom_scope{})\n  );\n\n  assert(injector.create example ().sp_);\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_scope.cpp", 
            "title": "Custom Scope"
        }, 
        {
            "location": "/examples/index.html#eager-singletons", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto configuration = [] {\n  return di::make_injector(\n    di::bind interface ().to implementation ().in(di::singleton)\n  , di::bind int ().to(42)\n  );\n};\n\nstruct example {\n  example(int i, std::shared_ptr interface  object) {\n    assert(42 == i);\n    assert(dynamic_cast implementation* (object.get()));\n  }\n};\n\nint main() {\n  /* make injector configuration */\n  auto injector = di::make_injector(configuration());\n  assert(0 == implementation::ctor_calls());\n\n  /* eagerly initialize singletons */\n  eager_singletons(injector);\n  assert(1 == implementation::ctor_calls());\n\n  /* create `example` with already initialized singletons */\n  injector.create example ();\n  assert(1 == implementation::ctor_calls());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp", 
            "title": "Eager Singletons"
        }, 
        {
            "location": "/examples/index.html#modules", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct data {\n  std::shared_ptr interface  sp;\n};\n\nstruct app {\n  app(std::unique_ptr interface  up, int i, double d, const data  data) {\n    assert(dynamic_cast implementation1* (up.get()));\n    assert(i == 42);\n    assert(d == 87.0);\n    assert(dynamic_cast implementation2* (data.sp.get()));\n  }\n};\n\n/* `module1` configuration */\nauto module1 = [] {\n  return di::make_injector(\n    di::bind interface ().to implementation1 ()\n  );\n};\n\n/* `module2` configuration */\nauto module2(const int  i) {\n  return di::make_injector(\n    di::bind int ().to(i)\n  );\n}\n\n/* module configuration with exposed `data` */\nauto exposed_module = []() -  di::injector const data  {\n  return di::make_injector(\n    di::bind interface ().to implementation2 ()\n  );\n};\n\nint main() {\n  constexpr auto i = 42;\n  constexpr auto d = 87.0;\n\n  /* module configuration with movable injector */\n  auto movable_injector = di::make_injector(\n    di::bind double ().to(d)\n  );\n\n  /* create injector and pass `module1`, `module2` and `exposed_module` */\n  auto injector = di::make_injector(\n    module1()\n  , module2(i)\n  , exposed_module()\n  , std::move(movable_injector)\n  );\n\n  /* create `app` */\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp", 
            "title": "Modules"
        }, 
        {
            "location": "/examples/index.html#modules-hppcpp", 
            "text": "See  https://github.com/boost-experimental/di/tree/cpp14/example/modules", 
            "title": "Modules (hpp/cpp)"
        }, 
        {
            "location": "/examples/index.html#custom-policy", 
            "text": "class custom_policy;\n#define BOOST_DI_CFG custom_policy\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nclass custom_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(is_bound di::_ {}));\n  }\n};\n\nstruct example {\n  example(int, double) {}\n};\n\nint main() {\n  /* create shared_ptr `example` with per injector policy setting */\n  {\n    auto injector = di::make_injector custom_policy (\n      di::bind int ().to(42)\n    , di::bind double ().to(87.0)\n    );\n\n    injector.create example ();\n  }\n\n  /* create shared_ptr `example` with global policy setting */\n  {\n    auto injector = di::make_injector(\n      di::bind int ().to(42)\n    , di::bind double ().to(87.0)\n    );\n\n    injector.create example ();\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp", 
            "title": "Custom Policy"
        }, 
        {
            "location": "/examples/index.html#custom-provider", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* define `example` class as usual */\nstruct example {\n  explicit example(int i, std::unique_ptr interface  up) {\n    assert(i == 42);\n    assert(dynamic_cast implementation* (up.get()));\n  }\n};\n\n/* define `custom provider` */\nstruct custom_provider {\n  template  class... \n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template  class T, class TMemory, class... TArgs \n  auto get(const di::type_traits::direct , const TMemory   // stack/heap\n           ,\n           TArgs ... args) const {\n    return new T(std::forward TArgs (args)...);\n  }\n\n  template  class T, class TMemory, class... TArgs \n  auto get(const di::type_traits::uniform , const TMemory   // stack/heap\n           ,\n           TArgs ... args) const {\n    return new T{std::forward TArgs (args)...};\n  }\n};\n\n/* override `di` provider configuration */\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return custom_provider{}; }\n};\n\nint main() {\n  /* make injector with simple configuration */\n  auto injector = di::make_injector config (\n    di::bind int ().to(42)\n  , di::bind interface ().to implementation ()\n  );\n\n  /* create `example` using `custom_provider` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp", 
            "title": "Custom Provider"
        }, 
        {
            "location": "/examples/index.html#pool-provider", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* define `pool provider` */\nstruct pool_provider {\n  template  class... \n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template  class T, class TInitialization, class TMemory, class... TArgs \n  auto get(const TInitialization   // direct/uniform\n           ,\n           const TMemory   // stack/heap\n           ,\n           TArgs ... args) const {\n    auto memory = pool_allocator::allocate T ();\n    return std::unique_ptr T, pool_deleter {new (memory) T(std::forward TArgs (args)...)};\n  }\n};\n\n/* override `di` provider configuration */\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return pool_provider{}; }\n};\n\n/* define `example` class as usual */\nstruct example {\n  explicit example(int i, std::unique_ptr interface, pool_deleter  up, std::shared_ptr interface  sp) {\n    assert(i == 42);\n    assert(dynamic_cast implementation* (up.get()));\n    assert(dynamic_cast implementation* (sp.get()));\n  }\n};\n\nint main() {\n  /* make injector with simple configuration */\n  auto injector = di::make_injector config (\n    di::bind int ().to(42)\n  , di::bind interface ().to implementation ()\n  );\n\n  /* create `example` using configuration with `pool_provider` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp", 
            "title": "Pool Provider"
        }, 
        {
            "location": "/examples/index.html#configuration", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n#if (BOOST_DI_VERSION  = 1'0'0)\n  std::cout    stable ;\n#else\n  std::cout    unstable ;\n#endif\n  std::cout     version of boost.di [    BOOST_DI_VERSION    ]    std::endl;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/configuration.cpp", 
            "title": "Configuration"
        }, 
        {
            "location": "/extensions/index.html", 
            "text": "Constructor Bindings\n\n\nContextual Bindings\n\n\nAssisted Injection\n\n\nConcepts\n\n\nFactory\n\n\nGenerics / Typed Erasure Interfaces\n\n\nLazy\n\n\nNamed Parameters\n\n\nXML Injection\n\n\nSerialize\n\n\nTypes Dumper\n\n\nUML Dumper\n\n\nMocks Provider\n\n\nScoped Scope\n\n\nSession Scope\n\n\nShared Scope\n\n\n\n\n\n\nConstructor Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\nnormal constructor - to_constructor binding is not needed for it\n*/\nstruct ctor {\n  ctor(int i, std::string s, std::unique_ptr\ninterface\n impl) {\n    assert(i == 2);\n    assert(s == \nhello\n);\n    assert(dynamic_cast\nimplementation*\n(impl.get()));\n  }\n};\n\n/*\nambiguous constructor\n*/\nstruct ambiguous_ctor {\n  ambiguous_ctor(int i, std::string s) {\n    assert(i == 2);\n    assert(s == \nhello\n);\n  }\n\n  ambiguous_ctor(std::string s, int i) {\n    assert(s == \nhello\n);\n    assert(i == 2);\n  }\n};\n\n/*\nvariadic constructor - has to be `explicit`\n*/\nstruct variadic {\n  template \nclass... Ts\n\n  explicit variadic(Ts\n... args) {  // has to be explicit\n    assert(sizeof...(Ts) == 3);\n    std::tuple\nTs...\n ts{std::forward\nTs\n(args)...};\n    assert(std::get\n0\n(ts) == 2);\n    assert(std::get\n1\n(ts) == \nhello\n);\n    assert(dynamic_cast\nimplementation*\n(std::get\n2\n(ts).get()));\n  }\n};\n\nint main() {\n  /*\ndefine constructor types\n*/\n  auto injector = di::make_injector(\n    di::bind\nctor\n().to(constructor\nint, std::string, std::unique_ptr\ninterface\n())\n  , di::bind\nambiguous_ctor\n().to(constructor\nint, std::string\n())\n  , di::bind\nvariadic\n().to(constructor\nint, std::string, std::unique_ptr\ninterface\n())\n\n      /*\nadditional bindings\n*/\n  , di::bind\ninterface\n().to\nimplementation\n()\n  , di::bind\nint\n().to(2), di::bind\nstd::string\n().to(\nhello\n)\n  );\n\n  /*\ncreate types using defined constructors\n*/\n  injector.create\nctor\n();\n  injector.create\nambiguous_ctor\n();\n  injector.create\nvariadic\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/bindings/constructor_bindings.cpp\n\n\n\n\nContextual Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct more_data {\n  int i;\n};\n\nstruct data {\n  int i;\n  more_data md;\n};\n\nclass example {\n public:\n  example(data\n d, int i, float f) {\n    assert(87 == d.i);\n    assert(99 == d.md.i);\n    assert(42 == i);\n    assert(123.f == f);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\ncontextual_bindings\n(\n      di::bind\n().to(123.f)\n    , di::bind\nint\n().to([](const auto\n injector) {\n        if (context(injector) == \nexample-\ndata\n) return 87;\n        if (context(injector) == \nexample-\ndata-\nmore_data\n) return 99;\n        return 42;\n      })\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/bindings/contextual_bindings.cpp\n\n\n\n\nAssisted Injection\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct example {\n  /*\ndefine `example` constructor using `assisted` as assisted_injection creation parameters\n*/\n  BOOST_DI_INJECT(example, (named = assisted) int date /*from assisted_injection*/\n                  ,\n                  std::unique_ptr\ninterface\n up /*from injector*/\n                  ,\n                  (named = assisted) double factor /*from assisted_injection*/\n                  ,\n                  int i /*from injector*/) {\n    assert(i == 87);\n    assert(dynamic_cast\nimplementation*\n(up.get()));\n    assert(date == 42);\n    assert(factor == 123.0);\n  }\n};\n\nint main() {\n  /*\nassisted_injection declaration using std function\n*/\n  using example_assisted_injection = std::function\nstd::unique_ptr\nexample\n(int, double)\n;\n\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(87)\n  , di::bind\ninterface\n().to\nimplementation\n()\n    /*\nbind `example_assisted_injection` to assisted_injection creating `example`\n*/\n  , di::bind\nexample_assisted_injection\n().to(assisted_injection\nexample\n())\n  );\n\n  auto f = injector.create\nexample_assisted_injection\n();\n  f(42, 123.0);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/assisted_injection.cpp\n\n\n\n\nConcepts\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\ntemplate \ntypename T\n\nconcept bool Dummy() {\n  return requires(T a) { {a.dummy()}; };\n}\n\nstruct DummyImpl {\n  void dummy() {}\n};\n\nauto dummy_concept = [] {};\n\nstruct example {\n  BOOST_DI_INJECT(example, int i, auto t, (named = dummy_concept)Dummy d, (named = dummy_concept)std::unique_ptr\nDummy\n up) {\n    assert(42 == i);\n    static_assert(std::is_same\ndecltype(t), int\n::value, \n);\n    assert(87 == t);\n    static_assert(std::is_same\ndecltype(d), DummyImpl\n::value, \n);\n    static_assert(std::is_same\ndecltype(up), std::unique_ptr\nDummyImpl\n::value, \n);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\nconcepts_provider_config\n(\n    di::bind\nint\n.to(42)\n  , di::bind\ndi::_\n.to(87)\n  , di::bind\ndi::_\n().named(dummy_concept).to\nDummyImpl\n()\n  );\n\n  injector.create\nexample\n();\n}\n\n#endif\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/concepts.cpp\n\n\n\n\nFactory\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct implementation : interface {\n  void dummy1() override {}\n};\n\nstruct implementation_with_args : interface {\n  implementation_with_args(int i, double d) {\n    assert(42 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\nstruct implementation_with_injected_args : interface {\n  implementation_with_injected_args(int i, double d) {\n    assert(123 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\n/*\nexample `example` class\n*/\nclass example {\n public:\n  example(const ifactory\ninterface\n f1, const ifactory\ninterface, int, double\n f2, const ifactory\ninterface, double\n f3) {\n    assert(dynamic_cast\nimplementation*\n(f1.create().get()));\n    assert(dynamic_cast\nimplementation_with_args*\n(f2.create(42, 87.0).get()));\n    assert(dynamic_cast\nimplementation_with_injected_args*\n(f3.create(87.0).get()));\n  }\n};\n\nint main() {\n  //\ndefine injector\n\n  auto module = [] { return di::make_injector(di::bind\n().to(123)); };\n\n  auto injector = di::make_injector(module()\n\n  //\nbind factory interface to implementation\n\n  , di::bind\nifactory\ninterface\n().to(factory\nimplementation\n{})\n\n  //\nbind factory interface with parameters to implementation_with_args\n\n  , di::bind\nifactory\ninterface, int, double\n().to(factory\nimplementation_with_args\n{})\n\n  //\nbind factory interface with some parameters injected to implementation_with_injected_args\n\n  , di::bind\nifactory\ninterface, double\n().to(factory\nimplementation_with_injected_args\n{})\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/factory.cpp\n\n\n\n\nGenerics / Typed Erasure Interfaces\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ngeneric interface\n*/\nstruct interface {\n  GENERIC(interface) {}\n  bool update(int i) REQUIRES(update, i);\n};\n\n/*\nimplementation without inheritance\n*/\nstruct implementation1 {\n  bool update(int i) { return i == 42; }\n};\n\n/*\nimplementation without inheritance\n*/\nstruct implementation2 {\n  bool update(int i) { return i != 42; }\n};\n\nstruct example {\n  BOOST_DI_INJECT(example, interface i) : i(i) {}\n  interface i;\n};\n\nint main() {\n  {\n    const auto injector = di::make_injector\ngenerics_provider_config\n(\n      di::bind\ninterface\n().to\nimplementation1\n()\n    );\n\n    auto object = injector.create\nexample\n();\n    assert(!object.i.update(0));  /// calls implementation1.update(0)\n    assert(object.i.update(42));  /// calls implementation1.update(42)\n  }\n\n  {\n    const auto injector = di::make_injector\ngenerics_provider_config\n(\n      di::bind\ninterface\n().to\nimplementation2\n()\n    );\n\n    auto object = injector.create\nexample\n();\n    assert(object.i.update(0));    /// calls implementation2.update(0)\n    assert(!object.i.update(42));  /// calls implementation2.update(42)\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/generics.cpp\n\n\n\n\nLazy\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\nexample `example` class\n*/\nclass example {\n public:\n  explicit example(lazy\nstd::unique_ptr\ninterface\n l) : l(l) {}\n\n  void initialize() {\n    auto object = l.get();\n    assert(dynamic_cast\ntype_expensive_to_create *\n(object.get()));\n  }\n\n private:\n  lazy\nstd::unique_ptr\ninterface\n l;\n};\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface\n().to\ntype_expensive_to_create\n()\n  );\n\n  /*\ncreate `example`\n*/\n  auto object = injector.create\nexample\n();\n  object.initialize();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/lazy.cpp\n\n\n\n\nNamed Parameters\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct example {\n  /*\ninject constructor using automatic named parameters\n*/\n  $inject(example, int i, std::unique_ptr\ninterface\n up, [[named(\nmy_value\n)]] int value) {\n    assert(i == 42);\n    assert(dynamic_cast\nimplementation*\n(up.get()));\n    assert(value == 87);\n  }\n};\n\nint main() {\n  /*\nbind named parameters\n*/\n  auto injector = di::make_injector(\n    di::bind\nint\n.to(42)\n  , di::bind\ninterface\n.to\nimplementation\n()\n  , di::bind\nint\n.named(\nmy_value\n_s).to(87)\n  );\n\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/named_parameters.cpp\n\n\n\n\nXML Injection\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\nixml_parser\n().to\nxml_parser_stub\n()\n  );\n};\n\nauto xml_module = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to(xml\nimplementation1, implementation2\n())\n  );\n};\n\nint main() {\n  /*\nmake injector\n*/\n  auto injector = di::make_injector(module(), xml_module());\n\n  /*\ncreate `interface` from xml configuration\n*/\n  {\n    auto object = injector.create\nstd::shared_ptr\ninterface\n();\n    assert(object.get());\n    assert(dynamic_cast\nimplementation1*\n(object.get()));\n  }\n\n  /*\ncreate `interface` from different xml configuration\n*/\n  {\n    auto object = injector.create\nstd::shared_ptr\ninterface\n();\n    assert(object.get());\n    assert(dynamic_cast\nimplementation2*\n(object.get()));\n  }\n\n  /*\ncreate `interface` from different xml configuration\n*/\n  {\n    auto object = injector.create\nstd::shared_ptr\ninterface\n();\n    assert(!object.get());\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/xml_injection.cpp\n\n\n\n\nSerialize\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct data {\n  unsigned int ui;\n  long l;\n  float f;\n};\n\nstruct even_more_data {\n  double d;\n  bool b;\n  long long ll;\n};\n\nstruct more_data {\n  int i;\n  long double ld;\n  even_more_data d;\n  short s;\n};\n\nstruct example {\n  example(data\n d, more_data\n md) : d(d), md(md) {}\n\n  void update() {\n    d.ui = 13;\n    d.l = 23l;\n    d.f = .33f;\n    md.i = 44;\n    md.ld = 42.0;\n    md.d.d = 55.0;\n    md.d.b = true;\n    md.d.ll = 66ll;\n    md.s = 77;\n  }\n\n  void reset() {\n    d.ui = {};\n    d.l = {};\n    d.f = {};\n    md.i = {};\n    md.ld = {};\n    md.d.d = {};\n    md.d.b = {};\n    md.d.ll = {};\n    md.s = {};\n  }\n\n  data\n d;\n  more_data\n md;\n};\n\nint main() {\n  auto injector = di::make_injector\nserializable_policy\n(\n      di::bind\n().to(42)\n  );\n\n  /*\ncreate `example`\n*/\n  auto object = injector.create\nexample\n();\n  {\n    assert(0 == object.d.ui);\n    assert(0 == object.d.l);\n    assert(.0f == object.d.f);\n    assert(42 == object.md.i);  // bound\n    assert(0.0 == object.md.ld);\n    assert(0.0 == object.md.d.d);\n    assert(false == object.md.d.b);\n    assert(0 == object.md.d.ll);\n    assert(0 == object.md.s);\n  }\n\n  /*\nupdate internal data\n*/\n  object.update();\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n\n  /*\nserialize internal data to the stream\n*/\n  std::stringstream str;\n  serialize(injector, str);\n\n  /*\nreset internal data\n*/\n  object.reset();\n\n  /*\ndeserialize from the stream\n*/\n  deserialize(injector, str);\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/serialize.cpp\n\n\n\n\nTypes Dumper\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ndefine `types dumper` directly in configuration\n*/\nclass types_dumper : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto type) {\n      using T = decltype(type);\n      using arg = typename T::type;\n      using name = typename T::name;\n      using given = typename T::given;\n\n      auto tab = v[i - 1];\n      while (tab--) {\n        std::clog \n \n    \n;\n      }\n\n      std::clog \n \n(\n \n typeid(arg).name() \n ((*(name*)(0))() ? std::string(\n[\n) + (*(name*)(0))() + std::string(\n]\n) : \n)\n                \n \n -\n \n \n typeid(given).name() \n \n)\n \n std::endl;\n\n      auto ctor_size = T::arity::value;\n      while (ctor_size--) {\n        v.insert((v.begin() + i), v[i - 1] + 1);\n      }\n      ++i;\n    });\n  }\n};\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector\ntypes_dumper\n(\n    di::bind\ni0\n().to\nc0\n()\n  , di::bind\nint\n().named(int_1).to(42)\n  , di::bind\nint\n().named(int_2).to(42)\n  );\n\n  /*\niterate through created objects with `types_dumper`\n*/\n  injector.create\nc3\n();\n\n  /*\n output [pre\n      (2c3 -\n 2c3)\n          (St10shared_ptrI2c1E -\n 2c1)\n              (St10shared_ptrI2i0E -\n 2c0)\n              (i -\n i)\n          (St10shared_ptrI2c2E -\n 2c2)\n              (i[first int] -\n i)\n              (i[second int] -\n i)\n              (c -\n c)\n  ]\n*/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/types_dumper.cpp\n\n\n\n\nUML Dumper\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/**\n * http://plantuml.sourceforge.net/objects.html\n * ./uml_dumper | java -jar plantuml.jar -p \n uml_dumper.png\n */\nclass uml_dumper : public di::config {\n public:\n  uml_dumper() { std::cout \n \n@startuml uml_dumper.png\n \n std::endl; }\n  ~uml_dumper() { std::cout \n \n@enduml\n \n std::endl; }\n\n  static auto policies(...) noexcept {\n    /*\ndefine `uml dumper` directly in policies configuration\n*/\n    return di::make_policies([\n](auto type) {\n      using T = decltype(type);\n      using name = typename T::name;\n      using given = typename T::given;\n\n      auto root = v[i - 1];\n      if (root != \ntypeid(nullptr)) {\n        std::cout \n \n\\\n \n root-\nname() \n \n\\\n .. \\\n \n typeid(given).name()\n                  \n ((*(name*)(0))() ? std::string(\n [\n) + (*(name*)(0))() + std::string(\n]\n) : \n) \n \n\\\n \n std::endl;\n      }\n\n      auto ctor_size = T::arity::value;\n      while (ctor_size--) {\n        v.insert((v.begin() + i), \ntypeid(given));\n      }\n      ++i;\n    });\n  }\n};\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector\numl_dumper\n(\n    di::bind\ni0\n().to\nc0\n()\n  , di::bind\nint\n().named(int_1).to(42)\n  , di::bind\nint\n().named(int_2).to(42)\n  );\n\n  /*\niterate through created objects with `types_dumper`\n*/\n  injector.create\nc3\n();\n\n  /*\noutput [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]]\n*/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp\n\n\n\n\n\n\nMocks Provider\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct c {\n  c(std::shared_ptr\ni1\n sp, std::unique_ptr\ni2\n up, int i) {\n    assert(sp-\nget() == 42);\n    assert(up-\nget() == 123);\n    assert(i == 87);\n  }\n};\n\n/*\ndefine simple unit test\n*/\ntest unit_test = [] {\n  /*\ncreate injector with `mocks_provider`\n*/\n  auto mi = mocks_injector();\n\n  /*\nset expectations\n*/\n  expect(mi, \ni1::get).will_return(42);\n  expect(mi, \ni2::get).will_return(123);\n\n  /*\ncreate object to test with interfaces to be injected by di and int value passed directly to constructor\n*/\n  c object{mi, mi, 87};\n};\n\ntest integration_test = [] {\n  struct impl1 : i1 {\n    int get() override { return 42; }\n  };\n\n  /*\ncreate injector with `mocks_provider`\n*/\n  auto mi = mocks_injector(\n    di::bind\nint\n().to(87) // custom value\n  , di::bind\ni1\n().to\nimpl1\n() // original implementation\n  );\n\n  /*\nset expectations\n*/\n  expect(mi, \ni2::get).will_return(123);  // fake\n\n  /*\ncreate object to test with mocked `i1` and original `i2` and injected int value\n*/\n  mi.create\nc\n();\n};\n\n/*\n`mock_provider` is just a simple mock framework - to check out di integration with full mock support framework see:\n * [@https://github.com/krzysztof-jusiak/mocks_injector]\n*/\nint main() {}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/providers/mocks_provider.cpp\n\n\n\n\nScoped Scope\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nclass scoped_scope {\n public:\n  template \nclass, class T\n\n  class scope {\n   public:\n    template \nclass T_\n\n    using is_referable = typename di::wrappers::shared\nscoped_scope, T\n::template is_referable\nT_\n;\n\n    template \nclass, class, class TProvider, class T_ = di::aux::decay_t\ndecltype(di::aux::declval\nTProvider\n().get())\n\n    static decltype(di::wrappers::shared\nscoped_scope, T_\n{\n        std::shared_ptr\nT_\n{std::shared_ptr\nT_\n{di::aux::declval\nTProvider\n().get()}}})\n    try_create(const TProvider \n);\n\n    template \nclass T_, class, class TProvider\n\n    auto create(const TProvider \nprovider) {\n      return create_impl\ndi::aux::decay_t\ndecltype(provider.get())\n(provider);\n    }\n\n    scope() = default;\n    scope(scope \nother) noexcept : object_(other.object_) { other.object_ = nullptr; }\n    ~scope() noexcept { delete object_; }\n\n   private:\n    template \nclass, class TProvider\n\n    auto create_impl(const TProvider \nprovider) {\n      if (!object_) {\n        object_ = new std::shared_ptr\nT\n{provider.get()};\n      }\n      return di::wrappers::shared\nscoped_scope, T, std::shared_ptr\nT\n \n{*object_};\n    }\n\n    std::shared_ptr\nT\n *object_ = nullptr;\n  };\n};\n\nstatic constexpr scoped_scope scoped{};\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\ninterface1\n().to\nimplementation1\n()\n  );\n};\n\nint main() {\n  assert(!implementation1::ctor_calls());\n  assert(!implementation1::dtor_calls());\n  assert(!implementation2::ctor_calls());\n  assert(!implementation2::dtor_calls());\n\n  auto parent_injector = module();\n  /*\ncreate `interface1` using deduced singleton scope\n*/\n  parent_injector.create\ninterface1 \n();\n  assert(1 == implementation1::ctor_calls());\n  {\n    /*\ncreate `child_injector` with `module` and binding using scoped singleton scope\n*/\n    auto child_injector = di::make_injector(\n      module()\n    , di::bind\ninterface2\n().to\nimplementation2\n().in(scoped)\n    );\n    child_injector.create\ninterface2 \n();\n    assert(1 == implementation2::ctor_calls());\n  }  // end of scoped\n  assert(1 == implementation2::dtor_calls());\n\n  /*\ncreate `interface1` again in singleton scope\n*/\n  parent_injector.create\ninterface1 \n();\n  /*\nalready created\n*/\n  assert(1 == implementation1::ctor_calls());\n  /*\n`implementation1` will die with the app (static storage)\n*/\n  assert(0 == implementation1::dtor_calls());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/scoped_scope.cpp\n\n\n\n\nSession Scope\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\ntemplate \nclass, class TScope\n\nclass session_scope {\n  class session_guard {\n   public:\n    explicit session_guard(bool\n guard) : guard_(guard) { guard = true; }\n    ~session_guard() { guard_ = false; }\n\n   private:\n    bool\n guard_;\n  };\n\n public:\n  template \nclass TExpected, class TGiven\n\n  class scope {\n    using scope_type = typename TScope::template scope\nTExpected, TGiven\n;\n\n   public:\n    template \nclass T\n\n    using is_referable = typename scope_type::template is_referable\nT\n;\n\n    template \nclass T, class TName, class TProvider\n\n    static auto try_create(const TProvider\n provider) -\n decltype(scope_type{}.template try_create\nT, TName\n(provider));\n\n    template \nclass T, class TName, class TProvider\n\n    auto create(const TProvider\n provider) {\n      static std::shared_ptr\nTGiven\n null{nullptr};\n      return get_session() ? scope_.template create\nT, TName\n(provider) : null;\n    }\n\n   private:\n    scope_type scope_;\n  };\n\n  auto operator()() const { return session_guard{get_session()}; }\n\n private:\n  static auto\n get_session() {\n    static auto is_in_session = false;\n    return is_in_session;\n  }\n};\n\ntemplate \nclass TName, class TScope = di::scopes::singleton\n\nauto session(const TName\n, const TScope\n = {}) {\n  return session_scope\nTName, TScope\n{};\n}\n\n\nauto my_session = [] {};\n\nint main() {\n  {\n    auto injector = di::make_injector(\n      di::bind\ninterface1\n().to\nimplementation1\n().in(session(my_session))\n    );\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n\n    {\n      auto ms = session(my_session)();\n      assert(injector.create\nstd::shared_ptr\ninterface1\n());\n    }  // end of my_session\n\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n  }\n\n  {\n    di::injector\nstd::shared_ptr\ninterface1\n injector =\n      di::make_injector(\n        di::bind\ninterface1\n().to\nimplementation1\n().in(session(my_session))\n      );\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n\n    {\n      auto ms = session(my_session)();\n      assert(injector.create\nstd::shared_ptr\ninterface1\n());\n    }  // end of my_session\n\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/session_scope.cpp\n\n\n\n\nShared Scope\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nclass shared_scope {\n public:\n  template \nclass, class T\n\n  class scope {\n   public:\n    template \nclass T_\n\n    using is_referable = typename di::wrappers::shared\nshared_scope, T\n::template is_referable\nT_\n;\n\n    template \nclass, class, class TProvider\n\n    static auto try_create(const TProvider\n provider)\n        -\n decltype(di::wrappers::shared\nshared_scope, T\n{std::shared_ptr\nT\n{provider.get()}});\n\n    template \nclass, class, class TProvider\n\n    auto create(const TProvider\n provider) {\n      if (!object_) {\n        object_ = std::shared_ptr\nT\n{provider.get()};\n      }\n      return di::wrappers::shared\nshared_scope, T\n{object_};\n    }\n\n   private:\n    std::shared_ptr\nT\n object_;\n  };\n};\n\nstatic constexpr shared_scope shared{};\n\n\nauto name = [] {};\n\nclass example {\n public:\n  BOOST_DI_INJECT(example, (named = name)std::shared_ptr\ninterface1\n sp1, (named = name)std::shared_ptr\ninterface1\n sp2,\n                  std::shared_ptr\ninterface1\n sp3) {\n    assert(sp1 == sp2);\n    assert(dynamic_cast\nimplementation2*\n(sp1.get()));\n    assert(dynamic_cast\nimplementation2*\n(sp2.get()));\n    assert(dynamic_cast\nimplementation1*\n(sp3.get()));\n  }\n};\n\nint main() {\n  {\n    auto injector = di::make_injector(\n      di::bind\ninterface1\n().to\nimplementation1\n().in(shared)  // di::unique will fail (sp1 == sp2)\n    , di::bind\ninterface1\n().to\nimplementation2\n().named(name).in(shared)\n    );\n    injector.create\nexample\n();\n  }\n\n  {\n    di::injector\nstd::shared_ptr\ninterface1\n injector =\n      di::make_injector(\n        di::bind\ninterface1\n().to\nimplementation1\n().in(shared)\n      );\n\n    injector.create\nstd::shared_ptr\ninterface1\n();\n    // injector.create\nstd::unique_ptr\ninterface1\n(); // error, std::unique_ptr\ninterface1\n is not exposed\n  }\n\n  {\n    di::injector\nBOOST_DI_EXPOSE((named = name)std::shared_ptr\ninterface1\n), std::shared_ptr\ninterface1\n injector =\n        di::make_injector(\n          di::bind\ninterface1\n().to\nimplementation1\n().in(shared).named(name)\n        , di::bind\ninterface1\n().to\nimplementation2\n().in(shared).named(name)[di::override]\n        , di::bind\ninterface1\n().to\nimplementation1\n().in(shared)\n        );\n\n    injector.create\nexample\n();\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/shared_scope.cpp", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/index.html#constructor-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* normal constructor - to_constructor binding is not needed for it */\nstruct ctor {\n  ctor(int i, std::string s, std::unique_ptr interface  impl) {\n    assert(i == 2);\n    assert(s ==  hello );\n    assert(dynamic_cast implementation* (impl.get()));\n  }\n};\n\n/* ambiguous constructor */\nstruct ambiguous_ctor {\n  ambiguous_ctor(int i, std::string s) {\n    assert(i == 2);\n    assert(s ==  hello );\n  }\n\n  ambiguous_ctor(std::string s, int i) {\n    assert(s ==  hello );\n    assert(i == 2);\n  }\n};\n\n/* variadic constructor - has to be `explicit` */\nstruct variadic {\n  template  class... Ts \n  explicit variadic(Ts ... args) {  // has to be explicit\n    assert(sizeof...(Ts) == 3);\n    std::tuple Ts...  ts{std::forward Ts (args)...};\n    assert(std::get 0 (ts) == 2);\n    assert(std::get 1 (ts) ==  hello );\n    assert(dynamic_cast implementation* (std::get 2 (ts).get()));\n  }\n};\n\nint main() {\n  /* define constructor types */\n  auto injector = di::make_injector(\n    di::bind ctor ().to(constructor int, std::string, std::unique_ptr interface ())\n  , di::bind ambiguous_ctor ().to(constructor int, std::string ())\n  , di::bind variadic ().to(constructor int, std::string, std::unique_ptr interface ())\n\n      /* additional bindings */\n  , di::bind interface ().to implementation ()\n  , di::bind int ().to(2), di::bind std::string ().to( hello )\n  );\n\n  /* create types using defined constructors */\n  injector.create ctor ();\n  injector.create ambiguous_ctor ();\n  injector.create variadic ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/bindings/constructor_bindings.cpp", 
            "title": "Constructor Bindings"
        }, 
        {
            "location": "/extensions/index.html#contextual-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct more_data {\n  int i;\n};\n\nstruct data {\n  int i;\n  more_data md;\n};\n\nclass example {\n public:\n  example(data  d, int i, float f) {\n    assert(87 == d.i);\n    assert(99 == d.md.i);\n    assert(42 == i);\n    assert(123.f == f);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector contextual_bindings (\n      di::bind ().to(123.f)\n    , di::bind int ().to([](const auto  injector) {\n        if (context(injector) ==  example- data ) return 87;\n        if (context(injector) ==  example- data- more_data ) return 99;\n        return 42;\n      })\n  );\n\n  /* create `example` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/bindings/contextual_bindings.cpp", 
            "title": "Contextual Bindings"
        }, 
        {
            "location": "/extensions/index.html#assisted-injection", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct example {\n  /* define `example` constructor using `assisted` as assisted_injection creation parameters */\n  BOOST_DI_INJECT(example, (named = assisted) int date /*from assisted_injection*/\n                  ,\n                  std::unique_ptr interface  up /*from injector*/\n                  ,\n                  (named = assisted) double factor /*from assisted_injection*/\n                  ,\n                  int i /*from injector*/) {\n    assert(i == 87);\n    assert(dynamic_cast implementation* (up.get()));\n    assert(date == 42);\n    assert(factor == 123.0);\n  }\n};\n\nint main() {\n  /* assisted_injection declaration using std function */\n  using example_assisted_injection = std::function std::unique_ptr example (int, double) ;\n\n  auto injector = di::make_injector(\n    di::bind int ().to(87)\n  , di::bind interface ().to implementation ()\n    /* bind `example_assisted_injection` to assisted_injection creating `example` */\n  , di::bind example_assisted_injection ().to(assisted_injection example ())\n  );\n\n  auto f = injector.create example_assisted_injection ();\n  f(42, 123.0);\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/assisted_injection.cpp", 
            "title": "Assisted Injection"
        }, 
        {
            "location": "/extensions/index.html#concepts", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\ntemplate  typename T \nconcept bool Dummy() {\n  return requires(T a) { {a.dummy()}; };\n}\n\nstruct DummyImpl {\n  void dummy() {}\n};\n\nauto dummy_concept = [] {};\n\nstruct example {\n  BOOST_DI_INJECT(example, int i, auto t, (named = dummy_concept)Dummy d, (named = dummy_concept)std::unique_ptr Dummy  up) {\n    assert(42 == i);\n    static_assert(std::is_same decltype(t), int ::value,  );\n    assert(87 == t);\n    static_assert(std::is_same decltype(d), DummyImpl ::value,  );\n    static_assert(std::is_same decltype(up), std::unique_ptr DummyImpl ::value,  );\n  }\n};\n\nint main() {\n  auto injector = di::make_injector concepts_provider_config (\n    di::bind int .to(42)\n  , di::bind di::_ .to(87)\n  , di::bind di::_ ().named(dummy_concept).to DummyImpl ()\n  );\n\n  injector.create example ();\n}\n\n#endif   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/concepts.cpp", 
            "title": "Concepts"
        }, 
        {
            "location": "/extensions/index.html#factory", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct implementation : interface {\n  void dummy1() override {}\n};\n\nstruct implementation_with_args : interface {\n  implementation_with_args(int i, double d) {\n    assert(42 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\nstruct implementation_with_injected_args : interface {\n  implementation_with_injected_args(int i, double d) {\n    assert(123 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\n/* example `example` class */\nclass example {\n public:\n  example(const ifactory interface  f1, const ifactory interface, int, double  f2, const ifactory interface, double  f3) {\n    assert(dynamic_cast implementation* (f1.create().get()));\n    assert(dynamic_cast implementation_with_args* (f2.create(42, 87.0).get()));\n    assert(dynamic_cast implementation_with_injected_args* (f3.create(87.0).get()));\n  }\n};\n\nint main() {\n  // define injector \n  auto module = [] { return di::make_injector(di::bind ().to(123)); };\n\n  auto injector = di::make_injector(module()\n\n  // bind factory interface to implementation \n  , di::bind ifactory interface ().to(factory implementation {})\n\n  // bind factory interface with parameters to implementation_with_args \n  , di::bind ifactory interface, int, double ().to(factory implementation_with_args {})\n\n  // bind factory interface with some parameters injected to implementation_with_injected_args \n  , di::bind ifactory interface, double ().to(factory implementation_with_injected_args {})\n  );\n\n  /* create `example` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/factory.cpp", 
            "title": "Factory"
        }, 
        {
            "location": "/extensions/index.html#generics-typed-erasure-interfaces", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* generic interface */\nstruct interface {\n  GENERIC(interface) {}\n  bool update(int i) REQUIRES(update, i);\n};\n\n/* implementation without inheritance */\nstruct implementation1 {\n  bool update(int i) { return i == 42; }\n};\n\n/* implementation without inheritance */\nstruct implementation2 {\n  bool update(int i) { return i != 42; }\n};\n\nstruct example {\n  BOOST_DI_INJECT(example, interface i) : i(i) {}\n  interface i;\n};\n\nint main() {\n  {\n    const auto injector = di::make_injector generics_provider_config (\n      di::bind interface ().to implementation1 ()\n    );\n\n    auto object = injector.create example ();\n    assert(!object.i.update(0));  /// calls implementation1.update(0)\n    assert(object.i.update(42));  /// calls implementation1.update(42)\n  }\n\n  {\n    const auto injector = di::make_injector generics_provider_config (\n      di::bind interface ().to implementation2 ()\n    );\n\n    auto object = injector.create example ();\n    assert(object.i.update(0));    /// calls implementation2.update(0)\n    assert(!object.i.update(42));  /// calls implementation2.update(42)\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/generics.cpp", 
            "title": "Generics / Typed Erasure Interfaces"
        }, 
        {
            "location": "/extensions/index.html#lazy", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* example `example` class */\nclass example {\n public:\n  explicit example(lazy std::unique_ptr interface  l) : l(l) {}\n\n  void initialize() {\n    auto object = l.get();\n    assert(dynamic_cast type_expensive_to_create * (object.get()));\n  }\n\n private:\n  lazy std::unique_ptr interface  l;\n};\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector(\n    di::bind interface ().to type_expensive_to_create ()\n  );\n\n  /* create `example` */\n  auto object = injector.create example ();\n  object.initialize();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/lazy.cpp", 
            "title": "Lazy"
        }, 
        {
            "location": "/extensions/index.html#named-parameters", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct example {\n  /* inject constructor using automatic named parameters */\n  $inject(example, int i, std::unique_ptr interface  up, [[named( my_value )]] int value) {\n    assert(i == 42);\n    assert(dynamic_cast implementation* (up.get()));\n    assert(value == 87);\n  }\n};\n\nint main() {\n  /* bind named parameters */\n  auto injector = di::make_injector(\n    di::bind int .to(42)\n  , di::bind interface .to implementation ()\n  , di::bind int .named( my_value _s).to(87)\n  );\n\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/named_parameters.cpp", 
            "title": "Named Parameters"
        }, 
        {
            "location": "/extensions/index.html#xml-injection", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind ixml_parser ().to xml_parser_stub ()\n  );\n};\n\nauto xml_module = [] {\n  return di::make_injector(\n    di::bind interface ().to(xml implementation1, implementation2 ())\n  );\n};\n\nint main() {\n  /* make injector */\n  auto injector = di::make_injector(module(), xml_module());\n\n  /* create `interface` from xml configuration */\n  {\n    auto object = injector.create std::shared_ptr interface ();\n    assert(object.get());\n    assert(dynamic_cast implementation1* (object.get()));\n  }\n\n  /* create `interface` from different xml configuration */\n  {\n    auto object = injector.create std::shared_ptr interface ();\n    assert(object.get());\n    assert(dynamic_cast implementation2* (object.get()));\n  }\n\n  /* create `interface` from different xml configuration */\n  {\n    auto object = injector.create std::shared_ptr interface ();\n    assert(!object.get());\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/injections/xml_injection.cpp", 
            "title": "XML Injection"
        }, 
        {
            "location": "/extensions/index.html#serialize", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct data {\n  unsigned int ui;\n  long l;\n  float f;\n};\n\nstruct even_more_data {\n  double d;\n  bool b;\n  long long ll;\n};\n\nstruct more_data {\n  int i;\n  long double ld;\n  even_more_data d;\n  short s;\n};\n\nstruct example {\n  example(data  d, more_data  md) : d(d), md(md) {}\n\n  void update() {\n    d.ui = 13;\n    d.l = 23l;\n    d.f = .33f;\n    md.i = 44;\n    md.ld = 42.0;\n    md.d.d = 55.0;\n    md.d.b = true;\n    md.d.ll = 66ll;\n    md.s = 77;\n  }\n\n  void reset() {\n    d.ui = {};\n    d.l = {};\n    d.f = {};\n    md.i = {};\n    md.ld = {};\n    md.d.d = {};\n    md.d.b = {};\n    md.d.ll = {};\n    md.s = {};\n  }\n\n  data  d;\n  more_data  md;\n};\n\nint main() {\n  auto injector = di::make_injector serializable_policy (\n      di::bind ().to(42)\n  );\n\n  /* create `example` */\n  auto object = injector.create example ();\n  {\n    assert(0 == object.d.ui);\n    assert(0 == object.d.l);\n    assert(.0f == object.d.f);\n    assert(42 == object.md.i);  // bound\n    assert(0.0 == object.md.ld);\n    assert(0.0 == object.md.d.d);\n    assert(false == object.md.d.b);\n    assert(0 == object.md.d.ll);\n    assert(0 == object.md.s);\n  }\n\n  /* update internal data */\n  object.update();\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n\n  /* serialize internal data to the stream */\n  std::stringstream str;\n  serialize(injector, str);\n\n  /* reset internal data */\n  object.reset();\n\n  /* deserialize from the stream */\n  deserialize(injector, str);\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/serialize.cpp", 
            "title": "Serialize"
        }, 
        {
            "location": "/extensions/index.html#types-dumper", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* define `types dumper` directly in configuration */\nclass types_dumper : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto type) {\n      using T = decltype(type);\n      using arg = typename T::type;\n      using name = typename T::name;\n      using given = typename T::given;\n\n      auto tab = v[i - 1];\n      while (tab--) {\n        std::clog         ;\n      }\n\n      std::clog    (    typeid(arg).name()   ((*(name*)(0))() ? std::string( [ ) + (*(name*)(0))() + std::string( ] ) :  )\n                    -      typeid(given).name()    )    std::endl;\n\n      auto ctor_size = T::arity::value;\n      while (ctor_size--) {\n        v.insert((v.begin() + i), v[i - 1] + 1);\n      }\n      ++i;\n    });\n  }\n};\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector types_dumper (\n    di::bind i0 ().to c0 ()\n  , di::bind int ().named(int_1).to(42)\n  , di::bind int ().named(int_2).to(42)\n  );\n\n  /* iterate through created objects with `types_dumper` */\n  injector.create c3 ();\n\n  /*  output [pre\n      (2c3 -  2c3)\n          (St10shared_ptrI2c1E -  2c1)\n              (St10shared_ptrI2i0E -  2c0)\n              (i -  i)\n          (St10shared_ptrI2c2E -  2c2)\n              (i[first int] -  i)\n              (i[second int] -  i)\n              (c -  c)\n  ] */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/types_dumper.cpp", 
            "title": "Types Dumper"
        }, 
        {
            "location": "/extensions/index.html#uml-dumper", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/**\n * http://plantuml.sourceforge.net/objects.html\n * ./uml_dumper | java -jar plantuml.jar -p   uml_dumper.png\n */\nclass uml_dumper : public di::config {\n public:\n  uml_dumper() { std::cout    @startuml uml_dumper.png    std::endl; }\n  ~uml_dumper() { std::cout    @enduml    std::endl; }\n\n  static auto policies(...) noexcept {\n    /* define `uml dumper` directly in policies configuration */\n    return di::make_policies([ ](auto type) {\n      using T = decltype(type);\n      using name = typename T::name;\n      using given = typename T::given;\n\n      auto root = v[i - 1];\n      if (root !=  typeid(nullptr)) {\n        std::cout    \\    root- name()    \\  .. \\    typeid(given).name()\n                    ((*(name*)(0))() ? std::string(  [ ) + (*(name*)(0))() + std::string( ] ) :  )    \\    std::endl;\n      }\n\n      auto ctor_size = T::arity::value;\n      while (ctor_size--) {\n        v.insert((v.begin() + i),  typeid(given));\n      }\n      ++i;\n    });\n  }\n};\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector uml_dumper (\n    di::bind i0 ().to c0 ()\n  , di::bind int ().named(int_1).to(42)\n  , di::bind int ().named(int_2).to(42)\n  );\n\n  /* iterate through created objects with `types_dumper` */\n  injector.create c3 ();\n\n  /* output [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]] */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/policies/uml_dumper.cpp", 
            "title": "UML Dumper"
        }, 
        {
            "location": "/extensions/index.html#mocks-provider", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct c {\n  c(std::shared_ptr i1  sp, std::unique_ptr i2  up, int i) {\n    assert(sp- get() == 42);\n    assert(up- get() == 123);\n    assert(i == 87);\n  }\n};\n\n/* define simple unit test */\ntest unit_test = [] {\n  /* create injector with `mocks_provider` */\n  auto mi = mocks_injector();\n\n  /* set expectations */\n  expect(mi,  i1::get).will_return(42);\n  expect(mi,  i2::get).will_return(123);\n\n  /* create object to test with interfaces to be injected by di and int value passed directly to constructor */\n  c object{mi, mi, 87};\n};\n\ntest integration_test = [] {\n  struct impl1 : i1 {\n    int get() override { return 42; }\n  };\n\n  /* create injector with `mocks_provider` */\n  auto mi = mocks_injector(\n    di::bind int ().to(87) // custom value\n  , di::bind i1 ().to impl1 () // original implementation\n  );\n\n  /* set expectations */\n  expect(mi,  i2::get).will_return(123);  // fake\n\n  /* create object to test with mocked `i1` and original `i2` and injected int value */\n  mi.create c ();\n};\n\n/* `mock_provider` is just a simple mock framework - to check out di integration with full mock support framework see:\n * [@https://github.com/krzysztof-jusiak/mocks_injector] */\nint main() {}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/providers/mocks_provider.cpp", 
            "title": "Mocks Provider"
        }, 
        {
            "location": "/extensions/index.html#scoped-scope", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nclass scoped_scope {\n public:\n  template  class, class T \n  class scope {\n   public:\n    template  class T_ \n    using is_referable = typename di::wrappers::shared scoped_scope, T ::template is_referable T_ ;\n\n    template  class, class, class TProvider, class T_ = di::aux::decay_t decltype(di::aux::declval TProvider ().get()) \n    static decltype(di::wrappers::shared scoped_scope, T_ {\n        std::shared_ptr T_ {std::shared_ptr T_ {di::aux::declval TProvider ().get()}}})\n    try_create(const TProvider  );\n\n    template  class T_, class, class TProvider \n    auto create(const TProvider  provider) {\n      return create_impl di::aux::decay_t decltype(provider.get()) (provider);\n    }\n\n    scope() = default;\n    scope(scope  other) noexcept : object_(other.object_) { other.object_ = nullptr; }\n    ~scope() noexcept { delete object_; }\n\n   private:\n    template  class, class TProvider \n    auto create_impl(const TProvider  provider) {\n      if (!object_) {\n        object_ = new std::shared_ptr T {provider.get()};\n      }\n      return di::wrappers::shared scoped_scope, T, std::shared_ptr T   {*object_};\n    }\n\n    std::shared_ptr T  *object_ = nullptr;\n  };\n};\n\nstatic constexpr scoped_scope scoped{};\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind interface1 ().to implementation1 ()\n  );\n};\n\nint main() {\n  assert(!implementation1::ctor_calls());\n  assert(!implementation1::dtor_calls());\n  assert(!implementation2::ctor_calls());\n  assert(!implementation2::dtor_calls());\n\n  auto parent_injector = module();\n  /* create `interface1` using deduced singleton scope */\n  parent_injector.create interface1  ();\n  assert(1 == implementation1::ctor_calls());\n  {\n    /* create `child_injector` with `module` and binding using scoped singleton scope */\n    auto child_injector = di::make_injector(\n      module()\n    , di::bind interface2 ().to implementation2 ().in(scoped)\n    );\n    child_injector.create interface2  ();\n    assert(1 == implementation2::ctor_calls());\n  }  // end of scoped\n  assert(1 == implementation2::dtor_calls());\n\n  /* create `interface1` again in singleton scope */\n  parent_injector.create interface1  ();\n  /* already created */\n  assert(1 == implementation1::ctor_calls());\n  /* `implementation1` will die with the app (static storage) */\n  assert(0 == implementation1::dtor_calls());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/scoped_scope.cpp", 
            "title": "Scoped Scope"
        }, 
        {
            "location": "/extensions/index.html#session-scope", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\ntemplate  class, class TScope \nclass session_scope {\n  class session_guard {\n   public:\n    explicit session_guard(bool  guard) : guard_(guard) { guard = true; }\n    ~session_guard() { guard_ = false; }\n\n   private:\n    bool  guard_;\n  };\n\n public:\n  template  class TExpected, class TGiven \n  class scope {\n    using scope_type = typename TScope::template scope TExpected, TGiven ;\n\n   public:\n    template  class T \n    using is_referable = typename scope_type::template is_referable T ;\n\n    template  class T, class TName, class TProvider \n    static auto try_create(const TProvider  provider) -  decltype(scope_type{}.template try_create T, TName (provider));\n\n    template  class T, class TName, class TProvider \n    auto create(const TProvider  provider) {\n      static std::shared_ptr TGiven  null{nullptr};\n      return get_session() ? scope_.template create T, TName (provider) : null;\n    }\n\n   private:\n    scope_type scope_;\n  };\n\n  auto operator()() const { return session_guard{get_session()}; }\n\n private:\n  static auto  get_session() {\n    static auto is_in_session = false;\n    return is_in_session;\n  }\n};\n\ntemplate  class TName, class TScope = di::scopes::singleton \nauto session(const TName , const TScope  = {}) {\n  return session_scope TName, TScope {};\n}\n\n\nauto my_session = [] {};\n\nint main() {\n  {\n    auto injector = di::make_injector(\n      di::bind interface1 ().to implementation1 ().in(session(my_session))\n    );\n    assert(!injector.create std::shared_ptr interface1 ());\n\n    {\n      auto ms = session(my_session)();\n      assert(injector.create std::shared_ptr interface1 ());\n    }  // end of my_session\n\n    assert(!injector.create std::shared_ptr interface1 ());\n  }\n\n  {\n    di::injector std::shared_ptr interface1  injector =\n      di::make_injector(\n        di::bind interface1 ().to implementation1 ().in(session(my_session))\n      );\n    assert(!injector.create std::shared_ptr interface1 ());\n\n    {\n      auto ms = session(my_session)();\n      assert(injector.create std::shared_ptr interface1 ());\n    }  // end of my_session\n\n    assert(!injector.create std::shared_ptr interface1 ());\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/session_scope.cpp", 
            "title": "Session Scope"
        }, 
        {
            "location": "/extensions/index.html#shared-scope", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nclass shared_scope {\n public:\n  template  class, class T \n  class scope {\n   public:\n    template  class T_ \n    using is_referable = typename di::wrappers::shared shared_scope, T ::template is_referable T_ ;\n\n    template  class, class, class TProvider \n    static auto try_create(const TProvider  provider)\n        -  decltype(di::wrappers::shared shared_scope, T {std::shared_ptr T {provider.get()}});\n\n    template  class, class, class TProvider \n    auto create(const TProvider  provider) {\n      if (!object_) {\n        object_ = std::shared_ptr T {provider.get()};\n      }\n      return di::wrappers::shared shared_scope, T {object_};\n    }\n\n   private:\n    std::shared_ptr T  object_;\n  };\n};\n\nstatic constexpr shared_scope shared{};\n\n\nauto name = [] {};\n\nclass example {\n public:\n  BOOST_DI_INJECT(example, (named = name)std::shared_ptr interface1  sp1, (named = name)std::shared_ptr interface1  sp2,\n                  std::shared_ptr interface1  sp3) {\n    assert(sp1 == sp2);\n    assert(dynamic_cast implementation2* (sp1.get()));\n    assert(dynamic_cast implementation2* (sp2.get()));\n    assert(dynamic_cast implementation1* (sp3.get()));\n  }\n};\n\nint main() {\n  {\n    auto injector = di::make_injector(\n      di::bind interface1 ().to implementation1 ().in(shared)  // di::unique will fail (sp1 == sp2)\n    , di::bind interface1 ().to implementation2 ().named(name).in(shared)\n    );\n    injector.create example ();\n  }\n\n  {\n    di::injector std::shared_ptr interface1  injector =\n      di::make_injector(\n        di::bind interface1 ().to implementation1 ().in(shared)\n      );\n\n    injector.create std::shared_ptr interface1 ();\n    // injector.create std::unique_ptr interface1 (); // error, std::unique_ptr interface1  is not exposed\n  }\n\n  {\n    di::injector BOOST_DI_EXPOSE((named = name)std::shared_ptr interface1 ), std::shared_ptr interface1  injector =\n        di::make_injector(\n          di::bind interface1 ().to implementation1 ().in(shared).named(name)\n        , di::bind interface1 ().to implementation2 ().in(shared).named(name)[di::override]\n        , di::bind interface1 ().to implementation1 ().in(shared)\n        );\n\n    injector.create example ();\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/scopes/shared_scope.cpp", 
            "title": "Shared Scope"
        }, 
        {
            "location": "/FAQ/index.html", 
            "text": "Dependency Inversion vs Dependency Injection\n\nIn principle Dependency Inversion might be implemented using DI or Service Locator (SL).\nThe latter is more like a 'God' object. It has a lot of benefits but, probably, the same\namount of cons such as that SL requires that SL will be the only constructor parameter for any class which can be created using it.\nDI, on the other hand, is less intrusive and easier to follow than SL.\n\n\n\n\n\n\n\n\n\n\nWhy C++14 is required for Boost.DI?\n\nAt first Boost.DI was implemented using C++03 standard with a switch to C++11 when available/possible.\nHowever, this approach, although was/is working just fine, was/is really slow to compile and hard to maintain too.\nMoreover, interface for \nmodules\n wasn't perfect due to missing return type deduction for functions in C++11.\nTherefore, I made a decision to reimplement the core using C++14 features which sped up compilation times dramatically\nand make the interface cleaner and easier to maintain. Nevertheless, effort was made to support the newest versions of\npopular C++ compilers including GCC/Clang and MSVC. If you are interested in C++03 version of the library, please, take\na look into \ncpp03\n branch. Please, also notice that this\nbranch is not maintained anymore.\n\n\n\n\n\n\n\n\n\n\nHow the constructor deduction works without reflection support in C++?\n\nPlease check out \ninjection\n design.\n\n\n\n\n\n\n\n\n\n\nCan I use XML in order to set-up bindings configuration?\n\nYes, however, XML injection is not part of the Boost.DI release.\nPlease, check out \nXML Extension\n.\n\n\n\n\n\n\n\n\n\n\nSince Boost.DI has a compile time approach can I have dynamic bindings?\n\nYes, Boost.DI supports dynamic bindings.\n\n\n\n\nauto use_gui_view = ...;\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n    if (use_gui_view)\n      return injector.template create\ngui_view\n();\n    else\n      return injector.template create\ntext_view\n();\n  })\n, di::bind\n.to(42) // renderer device\n);\n\n\n\n\nCheck out full example of \nDynamic Bindings\n.", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/index.html#dependency-inversion-vs-dependency-injection", 
            "text": "In principle Dependency Inversion might be implemented using DI or Service Locator (SL).\nThe latter is more like a 'God' object. It has a lot of benefits but, probably, the same\namount of cons such as that SL requires that SL will be the only constructor parameter for any class which can be created using it.\nDI, on the other hand, is less intrusive and easier to follow than SL.", 
            "title": "Dependency Inversion vs Dependency Injection"
        }, 
        {
            "location": "/FAQ/index.html#why-c14-is-required-for-boostdi", 
            "text": "At first Boost.DI was implemented using C++03 standard with a switch to C++11 when available/possible.\nHowever, this approach, although was/is working just fine, was/is really slow to compile and hard to maintain too.\nMoreover, interface for  modules  wasn't perfect due to missing return type deduction for functions in C++11.\nTherefore, I made a decision to reimplement the core using C++14 features which sped up compilation times dramatically\nand make the interface cleaner and easier to maintain. Nevertheless, effort was made to support the newest versions of\npopular C++ compilers including GCC/Clang and MSVC. If you are interested in C++03 version of the library, please, take\na look into  cpp03  branch. Please, also notice that this\nbranch is not maintained anymore.", 
            "title": "Why C++14 is required for Boost.DI?"
        }, 
        {
            "location": "/FAQ/index.html#how-the-constructor-deduction-works-without-reflection-support-in-c", 
            "text": "Please check out  injection  design.", 
            "title": "How the constructor deduction works without reflection support in C++?"
        }, 
        {
            "location": "/FAQ/index.html#can-i-use-xml-in-order-to-set-up-bindings-configuration", 
            "text": "Yes, however, XML injection is not part of the Boost.DI release.\nPlease, check out  XML Extension .", 
            "title": "Can I use XML in order to set-up bindings configuration?"
        }, 
        {
            "location": "/FAQ/index.html#since-boostdi-has-a-compile-time-approach-can-i-have-dynamic-bindings", 
            "text": "Yes, Boost.DI supports dynamic bindings.   auto use_gui_view = ...;\n\nauto injector = di::make_injector(\n  di::bind iview .to([ ](const auto  injector) -  iview  {\n    if (use_gui_view)\n      return injector.template create gui_view ();\n    else\n      return injector.template create text_view ();\n  })\n, di::bind .to(42) // renderer device\n);  Check out full example of  Dynamic Bindings .", 
            "title": "Since Boost.DI has a compile time approach can I have dynamic bindings?"
        }, 
        {
            "location": "/CHANGELOG/index.html", 
            "text": "1.0.1\n - 2016-05-04\n\n\n\n\nBreaking Changes\n\n\nSimplified interface for policies\n\n\n\n\n\n\n\n\nAdditions\n\n\nSupport for Clang-3.9\n\n\nSupport for GCC-6\n\n\n\n\nExtensions\n\n\nContextual Bindings\n\n\nSerialize\n\n\n\n\n\n\n\n\n\n\n\n\nBug Fixes\n\n\nLink error if di.hpp is included in two cpp-files\n\n\nCreation of empty injector crashes on MSVC 2015, Update 1, x64, Debug\n\n\n\n\n\n\n\n\n1.0.0\n - 2016-02-22\n\n\n\n\nSupport for MSVC-2015+\n\n\nSupport for GCC-5+\n\n\nSupport for CMake 2.8+\n\n\nSupport for libc++, libstdc++\n\n\nSupport for Mac OS\n\n\n\n\n0.5.0\n - 2015-01-12\n\n\n\n\nC++14 version\n\n\nSupport for Clang3.4+\n\n\n\n\n0.1.0\n - 2014-08-15\n\n\n\n\nC++03/C++11 version\n\n\nSupport for Clang3.2+", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/index.html#101-2016-05-04", 
            "text": "Breaking Changes  Simplified interface for policies     Additions  Support for Clang-3.9  Support for GCC-6   Extensions  Contextual Bindings  Serialize       Bug Fixes  Link error if di.hpp is included in two cpp-files  Creation of empty injector crashes on MSVC 2015, Update 1, x64, Debug", 
            "title": "1.0.1 - 2016-05-04"
        }, 
        {
            "location": "/CHANGELOG/index.html#100-2016-02-22", 
            "text": "Support for MSVC-2015+  Support for GCC-5+  Support for CMake 2.8+  Support for libc++, libstdc++  Support for Mac OS", 
            "title": "1.0.0 - 2016-02-22"
        }, 
        {
            "location": "/CHANGELOG/index.html#050-2015-01-12", 
            "text": "C++14 version  Support for Clang3.4+", 
            "title": "0.5.0 - 2015-01-12"
        }, 
        {
            "location": "/CHANGELOG/index.html#010-2014-08-15", 
            "text": "C++03/C++11 version  Support for Clang3.2+", 
            "title": "0.1.0 - 2014-08-15"
        }, 
        {
            "location": "/TODO/index.html", 
            "text": "https://waffle.io/boost-experimental/di", 
            "title": "TODO"
        }
    ]
}